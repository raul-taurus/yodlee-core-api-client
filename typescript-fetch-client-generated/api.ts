/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Yodlee Core APIs
 * This file describes the Yodlee Platform APIs using the swagger notation. You can use this swagger file to generate client side SDKs to the Yodlee Platform APIs for many different programming languages. You can generate a client SDK for Python, Java, JavaScript, PHP, or other languages according to your development needs. For more details about the APIs, refer to <a href=\"https://developer.envestnet.com/resources/yodlee/yodlee-api-overview/docs\">Yodlee API v1.1 - Overview</a>.<br><br>You will have to set the header before making the API call. The following headers apply to all the APIs:<ul><li>Authorization: This header holds the access token</li> <li> Api-Version: 1.1</li></ul><b>Note</b>: If there are any API-specific headers, they are mentioned explicitly in the respective API's description.
 *
 * OpenAPI spec version: 1.1.0
 * Contact: developer@yodlee.com
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "/".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AbstractAddress
 */
export interface AbstractAddress {
    /**
     * Zip.
     * @type {string}
     * @memberof AbstractAddress
     */
    zip?: string;
    /**
     * Country.
     * @type {string}
     * @memberof AbstractAddress
     */
    country?: string;
    /**
     * Address Line 3.
     * @type {string}
     * @memberof AbstractAddress
     */
    address3?: string;
    /**
     * Address Line 2.
     * @type {string}
     * @memberof AbstractAddress
     */
    address2?: string;
    /**
     * City.
     * @type {string}
     * @memberof AbstractAddress
     */
    city?: string;
    /**
     * Address Line 1.
     * @type {string}
     * @memberof AbstractAddress
     */
    address1?: string;
    /**
     * State.
     * @type {string}
     * @memberof AbstractAddress
     */
    state?: string;
}
/**
 * 
 * @export
 * @interface AccessTokens
 */
export interface AccessTokens {
    /**
     * The identifier of the application for which the access token is generated.<br><br><b>Endpoints</b>:<ul><li>GET user/accessTokens</li></ul>
     * @type {string}
     * @memberof AccessTokens
     */
    appId?: string;
    /**
     * Access token value used to invoke the widgets/apps.<br><br><b>Endpoints</b>:<ul><li>GET user/accessTokens</li></ul>
     * @type {string}
     * @memberof AccessTokens
     */
    value?: string;
    /**
     * Base URL using which the application is accessed.<br><br><b>Endpoints</b>:<ul><li>GET user/accessTokens</li></ul>
     * @type {string}
     * @memberof AccessTokens
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    availableCash?: Money;
    /**
     * Used to determine  whether an account to be considered in the networth calculation.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank,creditCard,loan,investment,insurance,realEstate,otherAssets,otherLiabilities<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {boolean}
     * @memberof Account
     */
    includeInNetWorth?: boolean;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    moneyMarketBalance?: Money;
    /**
     * Date on which the user is enrolled on the rewards program.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: reward<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof Account
     */
    enrollmentDate?: string;
    /**
     * The date on which the home value was estimated.<br><br><b>Aggregated / Manual</b>: Manual<br><b>Applicable containers</b>: realEstate<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof Account
     */
    estimatedDate?: string;
    /**
     * The additional description or notes given by the user.<br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof Account
     */
    memo?: string;
    /**
     * A nonprofit or state organization that works with lender, servicer, school, and the Department of Education to help successfully repay Federal Family Education Loan Program (FFELP) loans. If FFELP student loans default, the guarantor takes ownership of them.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof Account
     */
    guarantor?: string;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    interestPaidLastYear?: Money;
    /**
     * The date time the account information was last retrieved from the provider site and updated in the Yodlee system.<br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof Account
     */
    lastUpdated?: string;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    balance?: Money;
    /**
     * Type of home insurance, like -<ul><li>HOME_OWNER</li><li>RENTAL</li><li>RENTER</li><li>etc..</li></ul><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof Account
     */
    homeInsuranceType?: Account.HomeInsuranceTypeEnum;
    /**
     * The primary key of the account resource and the unique identifier for the account.<br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts </li><li>GET accounts/{accountId}</li><li>GET investmentOptions</li><li>GET accounts/historicalBalances</li><li>POST accounts</li><li>GET dataExtracts/userData</li></ul>
     * @type {number}
     * @memberof Account
     */
    id?: number;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    cash?: Money;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    totalCreditLine?: Money;
    /**
     * Service provider or institution name where the account originates. This belongs to the provider resource.<br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof Account
     */
    providerName?: string;
    /**
     * The valuation type indicates whether the home value is calculated either manually or by Yodlee Partners.<br><br><b>Aggregated / Manual</b>: Manual<br><b>Applicable containers</b>: realEstate<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof Account
     */
    valuationType?: Account.ValuationTypeEnum;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    marginBalance?: Money;
    /**
     * The annual percentage rate (APR) is the yearly rate of interest on the credit card account.<br><b>Additional Details:</b> The yearly percentage rate charged when a balance is held on a credit card. This rate of interest is applied every month on the outstanding credit card balance.<br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: creditCard<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {number}
     * @memberof Account
     */
    apr?: number;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    availableCredit?: Money;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    currentBalance?: Money;
    /**
     * Indicates if an account is aggregated from a site or it is a manual account i.e. account information manually provided by the user.<br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {boolean}
     * @memberof Account
     */
    isManual?: boolean;
    /**
     * 
     * @type {AccountProfile}
     * @memberof Account
     */
    profile?: AccountProfile;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    escrowBalance?: Money;
    /**
     * The eligible next level of the rewards program.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: reward<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof Account
     */
    nextLevel?: string;
    /**
     * The classification of the account such as personal, corporate, etc.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank, creditCard, investment, reward, loan, insurance<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof Account
     */
    classification?: Account.ClassificationEnum;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    loanPayoffAmount?: Money;
    /**
     * The type of the interest rate, for example, fixed or variable.<br><b>Applicable containers</b>: loan<br><b>Aggregated / Manual</b>: Aggregated<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof Account
     */
    interestRateType?: Account.InterestRateTypeEnum;
    /**
     * The date by which the payoff amount should be paid.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof Account
     */
    loanPayByDate?: string;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    faceAmount?: Money;
    /**
     * The date the insurance policy began.<br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof Account
     */
    policyFromDate?: string;
    /**
     * The number of years for which premium payments have to be made in a policy.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof Account
     */
    premiumPaymentTerm?: string;
    /**
     * The duration for which the policy is valid or in effect. For example, one year, five years, etc.<br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof Account
     */
    policyTerm?: string;
    /**
     * The type of repayment plan that the borrower prefers to repay the loan. <br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul><b>Applicable Values:</b><br>
     * @type {string}
     * @memberof Account
     */
    repaymentPlanType?: Account.RepaymentPlanTypeEnum;
    /**
     * The type of account that is aggregated.
     * @type {string}
     * @memberof Account
     */
    aggregatedAccountType?: string;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    availableBalance?: Money;
    /**
     * The status of the account that is updated by the consumer through an application or an API. Valid Values: AccountStatus<br><b>Additional Details:</b><br><b>ACTIVE:</b> All the added manual and aggregated accounts status will be made \"ACTIVE\" by default. <br><b>TO_BE_CLOSED:</b> If the aggregated accounts are not found or closed in the data provider site, Yodlee system marks the status as TO_BE_CLOSED<br><b>INACTIVE:</b> Users can update the status as INACTIVE to stop updating and to stop considering the account in other services<br><b>CLOSED:</b> Users can update the status as CLOSED, if the account is closed with the provider. <br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof Account
     */
    accountStatus?: Account.AccountStatusEnum;
    /**
     * Type of life insurance.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof Account
     */
    lifeInsuranceType?: Account.LifeInsuranceTypeEnum;
    /**
     * Full account number of the account that is included only when include = fullAccountNumber is provided in the request. For student loan account the account number that will be used for ACH or fund transfer<br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: bank, creditCard, investment, insurance, loan, reward, otherAssets, otherLiabilities <br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><b> Note : </b> fullAccountNumber is deprecated and is replaced with fullAccountNumberList in include parameter and response.</ul>
     * @type {string}
     * @memberof Account
     */
    fullAccountNumber?: string;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    premium?: Money;
    /**
     * The source through which the account(s) are added in the system.<br><b>Valid Values</b>: SYSTEM, USER<br><b>Applicable containers</b>: All Containers<br><b>Aggregated / Manual</b>: Both <br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof Account
     */
    aggregationSource?: Account.AggregationSourceEnum;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    overDraftLimit?: Money;
    /**
     * The nickname of the account as provided by the consumer to identify an account. The account nickname can be used instead of the account name.<br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof Account
     */
    nickname?: string;
    /**
     * The tenure for which the CD account is valid  or in case of loan, the number of years/months over which the loan amount  has to be repaid. <br><b>Additional Details:</b><br>  Bank: The Term field is only applicable for the account type CD.Loan: The period for which the loan agreement is in force. The period, before or at the end of which, the loan should either be repaid or renegotiated for another term.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank, loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof Account
     */
    term?: string;
    /**
     * <br><b>Bank:</b> The interest rate offered by a FI to its depositors on a bank account.<br><b>Loan:</b> Interest rate applied on the loan.<br><b>Additional Details:</b><br><b>Note:</b> The Interest Rate field is only applicable for the following account types: savings, checking, money market, and certificate of deposit.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank, loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {number}
     * @memberof Account
     */
    interestRate?: number;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    deathBenefit?: Money;
    /**
     * 
     * @type {AccountAddress}
     * @memberof Account
     */
    address?: AccountAddress;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    cashValue?: Money;
    /**
     * Holder details of the account.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
     * @type {Array<AccountHolder>}
     * @memberof Account
     */
    holder?: Array<AccountHolder>;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    _401kLoan?: Money;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    homeValue?: Money;
    /**
     * The account number as it appears on the site. (The POST accounts service response return this field as number)<br><b>Additional Details</b>:<b> Bank/ Loan/ Insurance/ Investment</b>:<br> The account number for the bank account as it appears at the site.<br><b>Credit Card</b>: The account number of the card account as it appears at the site,<br>i.e., the card number.The account number can be full or partial based on how it is displayed in the account summary page of the site.In most cases, the site does not display the full account number in the account summary page and additional navigation is required to aggregate it.<br><b>Applicable containers</b>: All Containers<br><b>Aggregated / Manual</b>: Both <br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>POST accounts</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof Account
     */
    accountNumber?: string;
    /**
     * The date on which the account is created in the Yodlee system.<br><b>Additional Details:</b> It is the date when the user links or aggregates the account(s) that are held with the provider to the Yodlee system.<br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof Account
     */
    createdDate?: string;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    interestPaidYTD?: Money;
    /**
     * The primary key of the provider account resource.<br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {number}
     * @memberof Account
     */
    providerAccountId?: number;
    /**
     * Property or possession offered to support a loan that can be seized on a default.<br><b>Applicable containers</b>: loan<br><b>Aggregated / Manual</b>: Aggregated<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof Account
     */
    collateral?: string;
    /**
     * Logical grouping of dataset attributes into datasets such as Basic Aggregation Data, Account Profile and Documents.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {Array<AccountDataset>}
     * @memberof Account
     */
    dataset?: Array<AccountDataset>;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    runningBalance?: Money;
    /**
     * A unique ID that the provider site has assigned to the account. The source ID is only available for the HELD accounts.<br><br><b>Applicable containers</b>: bank, creditCard, investment, insurance, loan, reward<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof Account
     */
    sourceId?: string;
    /**
     * The date on which the due amount has to be paid. <br><b>Additional Details:</b><br><b>Credit Card:</b> The monthly date by when the minimum payment is due to be paid on the credit card account. <br><b>Loan:</b> The date on or before which the due amount should be paid.<br><b>Note:</b> The due date at the account-level can differ from the due date field at the statement-level, as the information in the aggregated card account data provides an up-to-date information to the consumer.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: creditCard, loan, insurance<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof Account
     */
    dueDate?: string;
    /**
     * The frequency of the billing cycle of the account in case of card. The frequency in which premiums are paid in an insurance policy such as monthly, quarterly, and annually. The frequency in which due amounts are paid in a loan  account.<br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: creditCard, insurance, loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof Account
     */
    frequency?: Account.FrequencyEnum;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    maturityAmount?: Money;
    /**
     * The providerAccountIds that share the account with the primary providerAccountId that was created when the user had added the account for the first time.<br><b>Additional Details</b>: This attribute is returned in the response only if the account deduplication feature is enabled and the same account is mapped to more than one provider account IDs indicating the account is owned by more than one user, for example, joint accounts.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: All Containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {Array<number>}
     * @memberof Account
     */
    associatedProviderAccountId?: Array<number>;
    /**
     * The account to be considered as an asset or liability.<br><b>Applicable containers</b>: All Containers<br><b>Aggregated / Manual</b>: Both <br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {boolean}
     * @memberof Account
     */
    isAsset?: boolean;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    principalBalance?: Money;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    totalCashLimit?: Money;
    /**
     * The date when a certificate of deposit (CD/FD) matures or the final payment date of a loan at which point the principal amount (including pending interest) is due to be paid.<br><b>Additional Details:</b> The date when a certificate of deposit (CD) matures, i.e., the money in the CD can be withdrawn without paying an early withdrawal penalty.The final payment date of a loan, i.e., the principal amount (including pending interest) is due to be paid.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank, loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof Account
     */
    maturityDate?: string;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    minimumAmountDue?: Money;
    /**
     * Annual percentage yield (APY) is a normalized representation of an interest rate, based on a compounding period of one year. APY generally refers to the rate paid to a depositor by a financial institution on an account.<br><b>Applicable containers</b>: bank<br><b>Aggregated / Manual</b>: Aggregated<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {number}
     * @memberof Account
     */
    annualPercentageYield?: number;
    /**
     * The type of account that is aggregated, i.e., savings, checking, credit card, charge, HELOC, etc. The account type is derived based on the attributes of the account. <br><b>Valid Values:</b><br><b>Aggregated Account Type</b><br><b>bank</b><ul><li>CHECKING</li><li>SAVINGS</li><li>CD</li><li>PPF</li><li>RECURRING_DEPOSIT</li><li>FSA</li><li>MONEY_MARKET</li><li>IRA</li><li>PREPAID</li></ul><b>creditCard</b><ul><li>OTHER</li><li>CREDIT</li><li>STORE</li><li>CHARGE</li><li>OTHER</li></ul><b>investment (SN 1.0)</b><ul><li>BROKERAGE_MARGIN</li><li>HSA</li><li>IRA</li><li>BROKERAGE_CASH</li><li>401K</li><li>403B</li><li>TRUST</li><li>ANNUITY</li><li>SIMPLE</li><li>CUSTODIAL</li><li>BROKERAGE_CASH_OPTION</li><li>BROKERAGE_MARGIN_OPTION</li><li>INDIVIDUAL</li><li>CORPORATE</li><li>JTTIC</li><li>JTWROS</li><li>COMMUNITY_PROPERTY</li><li>JOINT_BY_ENTIRETY</li><li>CONSERVATORSHIP</li><li>ROTH</li><li>ROTH_CONVERSION</li><li>ROLLOVER</li><li>EDUCATIONAL</li><li>529_PLAN</li><li>457_DEFERRED_COMPENSATION</li><li>401A</li><li>PSP</li><li>MPP</li><li>STOCK_BASKET</li><li>LIVING_TRUST</li><li>REVOCABLE_TRUST</li><li>IRREVOCABLE_TRUST</li><li>CHARITABLE_REMAINDER</li><li>CHARITABLE_LEAD</li><li>CHARITABLE_GIFT_ACCOUNT</li><li>SEP</li><li>UTMA</li><li>UGMA</li><li>ESOPP</li><li>ADMINISTRATOR</li><li>EXECUTOR</li><li>PARTNERSHIP</li><li>SOLE_PROPRIETORSHIP</li><li>CHURCH</li><li>INVESTMENT_CLUB</li><li>RESTRICTED_STOCK_AWARD</li><li>CMA</li><li>EMPLOYEE_STOCK_PURCHASE_PLAN</li><li>PERFORMANCE_PLAN</li><li>BROKERAGE_LINK_ACCOUNT</li><li>MONEY_MARKET</li><li>SUPER_ANNUATION</li><li>REGISTERED_RETIREMENT_SAVINGS_PLAN</li><li>SPOUSAL_RETIREMENT_SAVINGS_PLAN</li><li>DEFERRED_PROFIT_SHARING_PLAN</li><li>NON_REGISTERED_SAVINGS_PLAN</li><li>REGISTERED_EDUCATION_SAVINGS_PLAN</li><li>GROUP_RETIREMENT_SAVINGS_PLAN</li><li>LOCKED_IN_RETIREMENT_SAVINGS_PLAN</li><li>RESTRICTED_LOCKED_IN_SAVINGS_PLAN</li><li>LOCKED_IN_RETIREMENT_ACCOUNT</li><li>REGISTERED_PENSION_PLAN</li><li>TAX_FREE_SAVINGS_ACCOUNT</li><li>LIFE_INCOME_FUND</li><li>REGISTERED_RETIREMENT_INCOME_FUND</li><li>SPOUSAL_RETIREMENT_INCOME_FUND</li><li>LOCKED_IN_REGISTERED_INVESTMENT_FUND</li><li>PRESCRIBED_REGISTERED_RETIREMENT_INCOME_FUND</li><li>GUARANTEED_INVESTMENT_CERTIFICATES</li><li>REGISTERED_DISABILITY_SAVINGS_PLAN</li><li>DIGITAL_WALLET</li><li>OTHER</li></ul><b>investment (SN 2.0)</b><ul><li>BROKERAGE_CASH</li><li>BROKERAGE_MARGIN</li><li>INDIVIDUAL_RETIREMENT_ACCOUNT_IRA</li><li>EMPLOYEE_RETIREMENT_ACCOUNT_401K</li><li>EMPLOYEE_RETIREMENT_SAVINGS_PLAN_403B</li><li>TRUST</li><li>ANNUITY</li><li>SIMPLE_IRA</li><li>CUSTODIAL_ACCOUNT</li><li>BROKERAGE_CASH_OPTION</li><li>BROKERAGE_MARGIN_OPTION</li><li>INDIVIDUAL</li><li>CORPORATE_INVESTMENT_ACCOUNT</li><li>JOINT_TENANTS_TENANCY_IN_COMMON_JTIC</li><li>JOINT_TENANTS_WITH_RIGHTS_OF_SURVIVORSHIP_JTWROS</li><li>JOINT_TENANTS_COMMUNITY_PROPERTY</li><li>JOINT_TENANTS_TENANTS_BY_ENTIRETY</li><li>CONSERVATOR</li><li>ROTH_IRA</li><li>ROTH_CONVERSION</li><li>ROLLOVER_IRA</li><li>EDUCATIONAL</li><li>EDUCATIONAL_SAVINGS_PLAN_529</li><li>DEFERRED_COMPENSATION_PLAN_457</li><li>MONEY_PURCHASE_RETIREMENT_PLAN_401A</li><li>PROFIT_SHARING_PLAN</li><li>MONEY_PURCHASE_PLAN</li><li>STOCK_BASKET_ACCOUNT</li><li>LIVING_TRUST</li><li>REVOCABLE_TRUST</li><li>IRREVOCABLE_TRUST</li><li>CHARITABLE_REMAINDER_TRUST</li><li>CHARITABLE_LEAD_TRUST</li><li>CHARITABLE_GIFT_ACCOUNT</li><li>SEP_IRA</li><li>UNIFORM_TRANSFER_TO_MINORS_ACT_UTMA</li><li>UNIFORM_GIFT_TO_MINORS_ACT_UGMA</li><li>EMPLOYEE_STOCK_OWNERSHIP_PLAN_ESOP</li><li>ADMINISTRATOR</li><li>EXECUTOR</li><li>PARTNERSHIP</li><li>PROPRIETORSHIP</li><li>CHURCH_ACCOUNT</li><li>INVESTMENT_CLUB</li><li>RESTRICTED_STOCK_AWARD</li><li>CASH_MANAGEMENT_ACCOUNT</li><li>EMPLOYEE_STOCK_PURCHASE_PLAN_ESPP</li><li>PERFORMANCE_PLAN</li><li>BROKERAGE_LINK_ACCOUNT</li><li>MONEY_MARKET_ACCOUNT</li><li>SUPERANNUATION</li><li>REGISTERED_RETIREMENT_SAVINGS_PLAN_RRSP</li><li>SPOUSAL_RETIREMENT_SAVINGS_PLAN_SRSP</li><li>DEFERRED_PROFIT_SHARING_PLAN_DPSP</li><li>NON_REGISTERED_SAVINGS_PLAN_NRSP</li><li>REGISTERED_EDUCATION_SAVINGS_PLAN_RESP</li><li>GROUP_RETIREMENT_SAVINGS_PLAN_GRSP</li><li>LOCKED_IN_RETIREMENT_SAVINGS_PLAN_LRSP</li><li>RESTRICTED_LOCKED_IN_SAVINGS_PLAN_RLSP</li><li>LOCKED_IN_RETIREMENT_ACCOUNT_LIRA</li><li>REGISTERED_PENSION_PLAN_RPP</li><li>TAX_FREE_SAVINGS_ACCOUNT_TFSA</li><li>LIFE_INCOME_FUND_LIF</li><li>REGISTERED_RETIREMENT_INCOME_FUND_RIF</li><li>SPOUSAL_RETIREMENT_INCOME_FUND_SRIF</li><li>LOCKED_IN_REGISTERED_INVESTMENT_FUND_LRIF</li><li>PRESCRIBED_REGISTERED_RETIREMENT_INCOME_FUND_PRIF</li><li>GUARANTEED_INVESTMENT_CERTIFICATES_GIC</li><li>REGISTERED_DISABILITY_SAVINGS_PLAN_RDSP</li><li>DEFINED_CONTRIBUTION_PLAN</li><li>DEFINED_BENEFIT_PLAN</li><li>EMPLOYEE_STOCK_OPTION_PLAN</li><li>NONQUALIFIED_DEFERRED_COMPENSATION_PLAN_409A</li><li>KEOGH_PLAN</li><li>EMPLOYEE_RETIREMENT_ACCOUNT_ROTH_401K</li><li>DEFERRED_CONTINGENT_CAPITAL_PLAN_DCCP</li><li>EMPLOYEE_BENEFIT_PLAN</li><li>EMPLOYEE_SAVINGS_PLAN</li><li>HEALTH_SAVINGS_ACCOUNT_HSA</li><li>COVERDELL_EDUCATION_SAVINGS_ACCOUNT_ESA</li><li>TESTAMENTARY_TRUST</li><li>ESTATE</li><li>GRANTOR_RETAINED_ANNUITY_TRUST_GRAT</li><li>ADVISORY_ACCOUNT</li><li>NON_PROFIT_ORGANIZATION_501C</li><li>HEALTH_REIMBURSEMENT_ARRANGEMENT_HRA</li><li>INDIVIDUAL_SAVINGS_ACCOUNT_ISA</li><li>CASH_ISA</li><li>STOCKS_AND_SHARES_ISA</li><li>INNOVATIVE_FINANCE_ISA</li><li>JUNIOR_ISA</li><li>EMPLOYEES_PROVIDENT_FUND_ORGANIZATION_EPFO</li><li>PUBLIC_PROVIDENT_FUND_PPF</li><li>EMPLOYEES_PENSION_SCHEME_EPS</li><li>NATIONAL_PENSION_SYSTEM_NPS</li><li>INDEXED_ANNUITY</li><li>ANNUITIZED_ANNUITY</li><li>VARIABLE_ANNUITY</li><li>ROTH_403B</li><li>SPOUSAL_IRA</li><li>SPOUSAL_ROTH_IRA</li><li>SARSEP_IRA</li><li>SUBSTANTIALLY_EQUAL_PERIODIC_PAYMENTS_SEPP</li><li>OFFSHORE_TRUST</li><li>IRREVOCABLE_LIFE_INSURANCE_TRUST</li><li>INTERNATIONAL_TRUST</li><li>LIFE_INTEREST_TRUST</li><li>EMPLOYEE_BENEFIT_TRUST</li><li>PRECIOUS_METAL_ACCOUNT</li><li>INVESTMENT_LOAN_ACCOUNT</li><li>GRANTOR_RETAINED_INCOME_TRUST</li><li>PENSION_PLAN</li><li>DIGITAL_WALLET</li><li>OTHER</li></ul><b>loan</b><ul><li>MORTGAGE</li><li>INSTALLMENT_LOAN</li><li>PERSONAL_LOAN</li><li>HOME_EQUITY_LINE_OF_CREDIT</li><li>LINE_OF_CREDIT</li><li>AUTO_LOAN</li><li>STUDENT_LOAN</li><li>HOME_LOAN</li></ul><b>insurance</b><ul><li>AUTO_INSURANCE</li><li>HEALTH_INSURANCE</li><li>HOME_INSURANCE</li><li>LIFE_INSURANCE</li><li>ANNUITY</li><li>TRAVEL_INSURANCE</li><li>INSURANCE</li></ul><b>realEstate</b><ul> <li>REAL_ESTATE</li></ul><b>reward</b><ul><li>REWARD_POINTS</li></ul><b>Manual Account Type</b><br><b>bank</b><ul><li>CHECKING</li><li>SAVINGS</li><li>CD</li><li>PREPAID</li></ul><b>credit</b><ul>  <li>CREDIT</li></ul><b>loan</b><ul>  <li>PERSONAL_LOAN</li><li>HOME_LOAN</li></ul><b>insurance</b><ul><li>INSURANCE</li><li>ANNUITY</li></ul><b>investment</b><ul><li>BROKERAGE_CASH</li></ul><br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof Account
     */
    accountType?: string;
    /**
     * The date on which the loan is disbursed.<br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof Account
     */
    originationDate?: string;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    totalVestedBalance?: Money;
    /**
     * Information of different reward balances associated with the account.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: reward<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {Array<RewardBalance>}
     * @memberof Account
     */
    rewardBalance?: Array<RewardBalance>;
    /**
     * Indicates the status of the loan account. <br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul><b>Applicable Values:</b><br>
     * @type {string}
     * @memberof Account
     */
    sourceAccountStatus?: Account.SourceAccountStatusEnum;
    /**
     * List of Loan accountId(s) to which the real-estate account is linked<br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: realEstate<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {Array<number>}
     * @memberof Account
     */
    linkedAccountIds?: Array<number>;
    /**
     * Derived APR will be an estimated purchase APR based on consumers credit card transactions and credit card purchase.<br><b>Aggregated / Manual / Derived</b>: Derived<br><b>Applicable containers</b>: creditCard<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {number}
     * @memberof Account
     */
    derivedApr?: number;
    /**
     * The date on which the insurance policy coverage commences.<br><b>Applicable containers</b>: insurance<br><b>Aggregated / Manual</b>: Aggregated<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof Account
     */
    policyEffectiveDate?: string;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    totalUnvestedBalance?: Money;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    annuityBalance?: Money;
    /**
     * The account name as it appears at the site.<br>(The POST accounts service response return this field as name)<br><b>Applicable containers</b>: All Containers<br><b>Aggregated / Manual</b>: Both <br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof Account
     */
    accountName?: string;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    totalCreditLimit?: Money;
    /**
     * The status of the policy.<br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof Account
     */
    policyStatus?: Account.PolicyStatusEnum;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    shortBalance?: Money;
    /**
     * The financial institution that provides the loan.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof Account
     */
    lender?: string;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    lastEmployeeContributionAmount?: Money;
    /**
     * Identifier of the provider site. The primary key of provider resource. <br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof Account
     */
    providerId?: string;
    /**
     * The date on which the payment for the previous or current billing cycle is done.<br><b>Additional Details:</b> If the payment is already done for the current billing cycle, then the field indicates the payment date of the current billing cycle. If payment is yet to be done for the current billing cycle, then the field indicates the date on which the payment was made for any of the previous billing cycles. The last payment date at the account-level can differ from the last payment date at the statement-level, as the information in the aggregated card account data provides an up-to-date information to the consumer.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: creditCard, loan, insurance<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof Account
     */
    lastPaymentDate?: string;
    /**
     * Primary reward unit for this reward program. E.g. miles, points, etc.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: reward<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof Account
     */
    primaryRewardUnit?: string;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    lastPaymentAmount?: Money;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    remainingBalance?: Money;
    /**
     * <b>Applicable containers</b>: reward, bank, creditCard, investment, loan, insurance, realEstate, otherLiabilities<br><b>Endpoints</b>:<ul><li>GET accounts </li><li>GET accounts/{accountId}</li><li>POST accounts</ul><li>GET dataExtracts/userData</li><b>Applicable Values</b><br>
     * @type {string}
     * @memberof Account
     */
    userClassification?: Account.UserClassificationEnum;
    /**
     * Bank and branch identification information.<br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank, investment, loan<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {Array<BankTransferCode>}
     * @memberof Account
     */
    bankTransferCode?: Array<BankTransferCode>;
    /**
     * The date on which the insurance policy expires or matures.<br><b>Additional Details:</b> The due date at the account-level can differ from the due date field at the statement-level, as the information in the aggregated card account data provides an up-to-date information to the consumer.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof Account
     */
    expirationDate?: string;
    /**
     * The coverage-related details of the account.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance,investment<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {Array<Coverage>}
     * @memberof Account
     */
    coverage?: Array<Coverage>;
    /**
     * Annual percentage rate applied to cash withdrawals on the card.<br><br><b>Account Type</b>: Aggregated<br><b>Applicable containers</b>: creditCard<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {number}
     * @memberof Account
     */
    cashApr?: number;
    /**
     * 
     * @type {AutoRefresh}
     * @memberof Account
     */
    autoRefresh?: AutoRefresh;
    /**
     * Indicates the migration status of the account from screen-scraping provider to the Open Banking provider. <br><br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof Account
     */
    oauthMigrationStatus?: Account.OauthMigrationStatusEnum;
    /**
     * The name or identification of the account owner, as it appears at the FI site. <br><b>Note:</b> The account holder name can be full or partial based on how it is displayed in the account summary page of the FI site. In most cases, the FI site does not display the full account holder name in the account summary page.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank, creditCard, investment, insurance, loan, reward<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof Account
     */
    displayedName?: string;
    /**
     * 
     * @type {FullAccountNumberList}
     * @memberof Account
     */
    fullAccountNumberList?: FullAccountNumberList;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    amountDue?: Money;
    /**
     * Current level of the reward program the user is associated with. E.g. Silver, Jade etc.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: reward<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof Account
     */
    currentLevel?: string;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    originalLoanAmount?: Money;
    /**
     * The date to which the policy exists.<br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof Account
     */
    policyToDate?: string;
    /**
     * 
     * @type {LoanPayoffDetails}
     * @memberof Account
     */
    loanPayoffDetails?: LoanPayoffDetails;
    /**
     * 
     * @type {PaymentProfile}
     * @memberof Account
     */
    paymentProfile?: PaymentProfile;
    /**
     * The type of service. E.g., Bank, Credit Card, Investment, Insurance, etc.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof Account
     */
    CONTAINER?: Account.CONTAINEREnum;
    /**
     * The date on which the last employee contribution was made to the 401k account.<br><b>Note:</b> The last employee contribution date field is derived from the transaction data and not aggregated from the FI site. The field is only applicable to the 401k account type.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: investment<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof Account
     */
    lastEmployeeContributionDate?: string;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    lastPayment?: Money;
    /**
     * 
     * @type {Money}
     * @memberof Account
     */
    recurringPayment?: Money;
}

/**
 * @export
 * @namespace Account
 */
export namespace Account {
    /**
     * @export
     * @enum {string}
     */
    export enum HomeInsuranceTypeEnum {
        HOMEOWNER = <any> 'HOME_OWNER',
        RENTAL = <any> 'RENTAL',
        RENTER = <any> 'RENTER',
        UNKNOWN = <any> 'UNKNOWN',
        OTHER = <any> 'OTHER'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ValuationTypeEnum {
        SYSTEM = <any> 'SYSTEM',
        MANUAL = <any> 'MANUAL'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ClassificationEnum {
        OTHER = <any> 'OTHER',
        PERSONAL = <any> 'PERSONAL',
        CORPORATE = <any> 'CORPORATE',
        SMALLBUSINESS = <any> 'SMALL_BUSINESS',
        TRUST = <any> 'TRUST',
        ADDONCARD = <any> 'ADD_ON_CARD',
        VIRTUALCARD = <any> 'VIRTUAL_CARD'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum InterestRateTypeEnum {
        FIXED = <any> 'FIXED',
        VARIABLE = <any> 'VARIABLE',
        UNKNOWN = <any> 'UNKNOWN',
        OTHER = <any> 'OTHER'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RepaymentPlanTypeEnum {
        STANDARD = <any> 'STANDARD',
        GRADUATED = <any> 'GRADUATED',
        EXTENDED = <any> 'EXTENDED',
        INCOMEBASED = <any> 'INCOME_BASED',
        INCOMECONTINGENT = <any> 'INCOME_CONTINGENT',
        INCOMESENSITIVE = <any> 'INCOME_SENSITIVE',
        PAYASYOUEARN = <any> 'PAY_AS_YOU_EARN',
        REVISEDPAYASYOUEARN = <any> 'REVISED_PAY_AS_YOU_EARN'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum AccountStatusEnum {
        ACTIVE = <any> 'ACTIVE',
        INACTIVE = <any> 'INACTIVE',
        TOBECLOSED = <any> 'TO_BE_CLOSED',
        CLOSED = <any> 'CLOSED',
        DELETED = <any> 'DELETED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum LifeInsuranceTypeEnum {
        OTHER = <any> 'OTHER',
        TERMLIFEINSURANCE = <any> 'TERM_LIFE_INSURANCE',
        UNIVERSALLIFEINSURANCE = <any> 'UNIVERSAL_LIFE_INSURANCE',
        WHOLELIFEINSURANCE = <any> 'WHOLE_LIFE_INSURANCE',
        VARIABLELIFEINSURANCE = <any> 'VARIABLE_LIFE_INSURANCE',
        ULIP = <any> 'ULIP',
        ENDOWMENT = <any> 'ENDOWMENT'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum AggregationSourceEnum {
        SYSTEM = <any> 'SYSTEM',
        USER = <any> 'USER'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum FrequencyEnum {
        DAILY = <any> 'DAILY',
        ONETIME = <any> 'ONE_TIME',
        WEEKLY = <any> 'WEEKLY',
        EVERY2WEEKS = <any> 'EVERY_2_WEEKS',
        SEMIMONTHLY = <any> 'SEMI_MONTHLY',
        MONTHLY = <any> 'MONTHLY',
        QUARTERLY = <any> 'QUARTERLY',
        SEMIANNUALLY = <any> 'SEMI_ANNUALLY',
        ANNUALLY = <any> 'ANNUALLY',
        EVERY2MONTHS = <any> 'EVERY_2_MONTHS',
        EBILL = <any> 'EBILL',
        FIRSTDAYMONTHLY = <any> 'FIRST_DAY_MONTHLY',
        LASTDAYMONTHLY = <any> 'LAST_DAY_MONTHLY',
        EVERY4WEEKS = <any> 'EVERY_4_WEEKS',
        UNKNOWN = <any> 'UNKNOWN',
        OTHER = <any> 'OTHER'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SourceAccountStatusEnum {
        INREPAYMENT = <any> 'IN_REPAYMENT',
        DEFAULTED = <any> 'DEFAULTED',
        INSCHOOL = <any> 'IN_SCHOOL',
        INGRACEPERIOD = <any> 'IN_GRACE_PERIOD',
        DELINQUENCY = <any> 'DELINQUENCY',
        DEFERMENT = <any> 'DEFERMENT',
        FORBEARANCE = <any> 'FORBEARANCE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum PolicyStatusEnum {
        ACTIVE = <any> 'ACTIVE',
        INACTIVE = <any> 'IN_ACTIVE',
        OTHER = <any> 'OTHER'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum UserClassificationEnum {
        BUSINESS = <any> 'BUSINESS',
        PERSONAL = <any> 'PERSONAL'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum OauthMigrationStatusEnum {
        INPROGRESS = <any> 'IN_PROGRESS',
        TOBEMIGRATED = <any> 'TO_BE_MIGRATED',
        COMPLETED = <any> 'COMPLETED',
        MIGRATED = <any> 'MIGRATED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum CONTAINEREnum {
        Bank = <any> 'bank',
        CreditCard = <any> 'creditCard',
        Investment = <any> 'investment',
        Insurance = <any> 'insurance',
        Loan = <any> 'loan',
        Reward = <any> 'reward',
        Bill = <any> 'bill',
        RealEstate = <any> 'realEstate',
        OtherAssets = <any> 'otherAssets',
        OtherLiabilities = <any> 'otherLiabilities'
    }
}
/**
 * 
 * @export
 * @interface AccountAddress
 */
export interface AccountAddress {
    /**
     * Zip.
     * @type {string}
     * @memberof AccountAddress
     */
    zip?: string;
    /**
     * Country.
     * @type {string}
     * @memberof AccountAddress
     */
    country?: string;
    /**
     * Address Line 3.
     * @type {string}
     * @memberof AccountAddress
     */
    address3?: string;
    /**
     * Address Line 2.
     * @type {string}
     * @memberof AccountAddress
     */
    address2?: string;
    /**
     * City.
     * @type {string}
     * @memberof AccountAddress
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountAddress
     */
    sourceType?: string;
    /**
     * Address Line 1.
     * @type {string}
     * @memberof AccountAddress
     */
    address1?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountAddress
     */
    street?: string;
    /**
     * State.
     * @type {string}
     * @memberof AccountAddress
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountAddress
     */
    type?: AccountAddress.TypeEnum;
}

/**
 * @export
 * @namespace AccountAddress
 */
export namespace AccountAddress {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        HOME = <any> 'HOME',
        BUSINESS = <any> 'BUSINESS',
        POBOX = <any> 'POBOX',
        RETAIL = <any> 'RETAIL',
        OFFICE = <any> 'OFFICE',
        SMALLBUSINESS = <any> 'SMALL_BUSINESS',
        COMMUNICATION = <any> 'COMMUNICATION',
        PERMANENT = <any> 'PERMANENT',
        STATEMENTADDRESS = <any> 'STATEMENT_ADDRESS',
        PAYMENT = <any> 'PAYMENT',
        PAYOFF = <any> 'PAYOFF',
        UNKNOWN = <any> 'UNKNOWN'
    }
}
/**
 * 
 * @export
 * @interface AccountBalanceResponse
 */
export interface AccountBalanceResponse {
    /**
     * 
     * @type {Array<AccountLatestBalance>}
     * @memberof AccountBalanceResponse
     */
    accountBalance?: Array<AccountLatestBalance>;
}
/**
 * 
 * @export
 * @interface AccountDataset
 */
export interface AccountDataset {
    /**
     * Indicate when the dataset is last updated successfully for the given provider account.<br><br><b>Account Type</b>: Aggregated<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li></ul>
     * @type {string}
     * @memberof AccountDataset
     */
    lastUpdated?: string;
    /**
     * Indicate whether the dataset is eligible for update or not.<br><br><b>Account Type</b>: Aggregated<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof AccountDataset
     */
    updateEligibility?: AccountDataset.UpdateEligibilityEnum;
    /**
     * The status of last update attempted for the dataset. <br><br><b>Account Type</b>: Aggregated<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof AccountDataset
     */
    additionalStatus?: AccountDataset.AdditionalStatusEnum;
    /**
     * Indicates when the next attempt to update the dataset is scheduled.<br><br><b>Account Type</b>: Aggregated<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li></ul>
     * @type {string}
     * @memberof AccountDataset
     */
    nextUpdateScheduled?: string;
    /**
     * The name of the dataset requested from the provider site<br><br><b>Account Type</b>: Manual<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li><li>GET providers/{providerId}</li><li>GET providers</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof AccountDataset
     */
    name?: AccountDataset.NameEnum;
    /**
     * Indicate when the last attempt was performed to update the dataset for the given provider account<br><br><b>Account Type</b>: Aggregated<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li></ul>
     * @type {string}
     * @memberof AccountDataset
     */
    lastUpdateAttempt?: string;
}

/**
 * @export
 * @namespace AccountDataset
 */
export namespace AccountDataset {
    /**
     * @export
     * @enum {string}
     */
    export enum UpdateEligibilityEnum {
        ALLOWUPDATE = <any> 'ALLOW_UPDATE',
        ALLOWUPDATEWITHCREDENTIALS = <any> 'ALLOW_UPDATE_WITH_CREDENTIALS',
        DISALLOWUPDATE = <any> 'DISALLOW_UPDATE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum AdditionalStatusEnum {
        LOGININPROGRESS = <any> 'LOGIN_IN_PROGRESS',
        DATARETRIEVALINPROGRESS = <any> 'DATA_RETRIEVAL_IN_PROGRESS',
        ACCTSUMMARYRECEIVED = <any> 'ACCT_SUMMARY_RECEIVED',
        AVAILABLEDATARETRIEVED = <any> 'AVAILABLE_DATA_RETRIEVED',
        PARTIALDATARETRIEVED = <any> 'PARTIAL_DATA_RETRIEVED',
        DATARETRIEVALFAILED = <any> 'DATA_RETRIEVAL_FAILED',
        DATANOTAVAILABLE = <any> 'DATA_NOT_AVAILABLE',
        ACCOUNTLOCKED = <any> 'ACCOUNT_LOCKED',
        ADDLAUTHENTICATIONREQUIRED = <any> 'ADDL_AUTHENTICATION_REQUIRED',
        BETASITEDEVINPROGRESS = <any> 'BETA_SITE_DEV_IN_PROGRESS',
        CREDENTIALSUPDATENEEDED = <any> 'CREDENTIALS_UPDATE_NEEDED',
        INCORRECTCREDENTIALS = <any> 'INCORRECT_CREDENTIALS',
        PROPERTYVALUENOTAVAILABLE = <any> 'PROPERTY_VALUE_NOT_AVAILABLE',
        INVALIDADDLINFOPROVIDED = <any> 'INVALID_ADDL_INFO_PROVIDED',
        REQUESTTIMEOUT = <any> 'REQUEST_TIME_OUT',
        SITEBLOCKINGERROR = <any> 'SITE_BLOCKING_ERROR',
        UNEXPECTEDSITEERROR = <any> 'UNEXPECTED_SITE_ERROR',
        SITENOTSUPPORTED = <any> 'SITE_NOT_SUPPORTED',
        SITEUNAVAILABLE = <any> 'SITE_UNAVAILABLE',
        TECHERROR = <any> 'TECH_ERROR',
        USERACTIONNEEDEDATSITE = <any> 'USER_ACTION_NEEDED_AT_SITE',
        SITESESSIONINVALIDATED = <any> 'SITE_SESSION_INVALIDATED',
        NEWAUTHENTICATIONREQUIRED = <any> 'NEW_AUTHENTICATION_REQUIRED',
        DATASETNOTSUPPORTED = <any> 'DATASET_NOT_SUPPORTED',
        ENROLLMENTREQUIREDFORDATASET = <any> 'ENROLLMENT_REQUIRED_FOR_DATASET',
        CONSENTREQUIRED = <any> 'CONSENT_REQUIRED',
        CONSENTEXPIRED = <any> 'CONSENT_EXPIRED',
        CONSENTREVOKED = <any> 'CONSENT_REVOKED',
        INCORRECTOAUTHTOKEN = <any> 'INCORRECT_OAUTH_TOKEN',
        MIGRATIONINPROGRESS = <any> 'MIGRATION_IN_PROGRESS'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        BASICAGGDATA = <any> 'BASIC_AGG_DATA',
        ADVANCEAGGDATA = <any> 'ADVANCE_AGG_DATA',
        ACCTPROFILE = <any> 'ACCT_PROFILE',
        DOCUMENT = <any> 'DOCUMENT'
    }
}
/**
 * 
 * @export
 * @interface AccountHistoricalBalancesResponse
 */
export interface AccountHistoricalBalancesResponse {
    /**
     * 
     * @type {Array<AccountHistory>}
     * @memberof AccountHistoricalBalancesResponse
     */
    account?: Array<AccountHistory>;
}
/**
 * 
 * @export
 * @interface AccountHistory
 */
export interface AccountHistory {
    /**
     * 
     * @type {Array<HistoricalBalance>}
     * @memberof AccountHistory
     */
    historicalBalances?: Array<HistoricalBalance>;
    /**
     * 
     * @type {number}
     * @memberof AccountHistory
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface AccountHolder
 */
export interface AccountHolder {
    /**
     * Identifiers of the account holder.<br><br><b>Aggregated / Manual</b>: Aggregated <br><b>Applicable containers</b>: bank<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
     * @type {Array<Identifier>}
     * @memberof AccountHolder
     */
    identifier?: Array<Identifier>;
    /**
     * Identifiers of the account holder.<br><br><b>Aggregated / Manual</b>: Aggregated <br><b>Applicable containers</b>: bank<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
     * @type {string}
     * @memberof AccountHolder
     */
    gender?: string;
    /**
     * Indicates the ownership of the account.<br><br><b>Aggregated / Manual</b>: Aggregated <br><b>Applicable containers</b>: bank<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof AccountHolder
     */
    ownership?: AccountHolder.OwnershipEnum;
    /**
     * 
     * @type {Name}
     * @memberof AccountHolder
     */
    name?: Name;
}

/**
 * @export
 * @namespace AccountHolder
 */
export namespace AccountHolder {
    /**
     * @export
     * @enum {string}
     */
    export enum OwnershipEnum {
        PRIMARY = <any> 'PRIMARY',
        SECONDARY = <any> 'SECONDARY',
        CUSTODIAN = <any> 'CUSTODIAN',
        OTHERS = <any> 'OTHERS',
        POWEROFATTORNEY = <any> 'POWER_OF_ATTORNEY',
        TRUSTEE = <any> 'TRUSTEE',
        JOINTOWNER = <any> 'JOINT_OWNER',
        BENEFICIARY = <any> 'BENEFICIARY',
        AAS = <any> 'AAS',
        BUSINESS = <any> 'BUSINESS',
        DBA = <any> 'DBA',
        TRUST = <any> 'TRUST'
    }
}
/**
 * 
 * @export
 * @interface AccountLatestBalance
 */
export interface AccountLatestBalance {
    /**
     * The account name as it appears at the site.<br>(The POST accounts service response return this field as name)<br><b>Applicable containers</b>: bank, investment<br><b>Aggregated / Manual</b>: Aggregated<br><b>Endpoints</b>:<br><ul><li>GET accounts/latestBalances</li></ul>
     * @type {string}
     * @memberof AccountLatestBalance
     */
    accountName?: string;
    /**
     * 
     * @type {Money}
     * @memberof AccountLatestBalance
     */
    totalBalance?: Money;
    /**
     * The type of account that is aggregated, i.e., savings, checking, charge, HELOC, etc. The account type is derived based on the attributes of the account. <br><b>Valid Values:</b><br><b>Aggregated Account Type</b><br><b>bank</b><ul><li>CHECKING</li><li>SAVINGS</li><li>CD</li><li>PPF</li><li>RECURRING_DEPOSIT</li><li>FSA</li><li>MONEY_MARKET</li><li>IRA</li><li>PREPAID</li></ul><b>investment (SN 1.0)</b><ul><li>BROKERAGE_MARGIN</li><li>HSA</li><li>IRA</li><li>BROKERAGE_CASH</li><li>401K</li><li>403B</li><li>TRUST</li><li>ANNUITY</li><li>SIMPLE</li><li>CUSTODIAL</li><li>BROKERAGE_CASH_OPTION</li><li>BROKERAGE_MARGIN_OPTION</li><li>INDIVIDUAL</li><li>CORPORATE</li><li>JTTIC</li><li>JTWROS</li><li>COMMUNITY_PROPERTY</li><li>JOINT_BY_ENTIRETY</li><li>CONSERVATORSHIP</li><li>ROTH</li><li>ROTH_CONVERSION</li><li>ROLLOVER</li><li>EDUCATIONAL</li><li>529_PLAN</li><li>457_DEFERRED_COMPENSATION</li><li>401A</li><li>PSP</li><li>MPP</li><li>STOCK_BASKET</li><li>LIVING_TRUST</li><li>REVOCABLE_TRUST</li><li>IRREVOCABLE_TRUST</li><li>CHARITABLE_REMAINDER</li><li>CHARITABLE_LEAD</li><li>CHARITABLE_GIFT_ACCOUNT</li><li>SEP</li><li>UTMA</li><li>UGMA</li><li>ESOPP</li><li>ADMINISTRATOR</li><li>EXECUTOR</li><li>PARTNERSHIP</li><li>SOLE_PROPRIETORSHIP</li><li>CHURCH</li><li>INVESTMENT_CLUB</li><li>RESTRICTED_STOCK_AWARD</li><li>CMA</li><li>EMPLOYEE_STOCK_PURCHASE_PLAN</li><li>PERFORMANCE_PLAN</li><li>BROKERAGE_LINK_ACCOUNT</li><li>MONEY_MARKET</li><li>SUPER_ANNUATION</li><li>REGISTERED_RETIREMENT_SAVINGS_PLAN</li><li>SPOUSAL_RETIREMENT_SAVINGS_PLAN</li><li>DEFERRED_PROFIT_SHARING_PLAN</li><li>NON_REGISTERED_SAVINGS_PLAN</li><li>REGISTERED_EDUCATION_SAVINGS_PLAN</li><li>GROUP_RETIREMENT_SAVINGS_PLAN</li><li>LOCKED_IN_RETIREMENT_SAVINGS_PLAN</li><li>RESTRICTED_LOCKED_IN_SAVINGS_PLAN</li><li>LOCKED_IN_RETIREMENT_ACCOUNT</li><li>REGISTERED_PENSION_PLAN</li><li>TAX_FREE_SAVINGS_ACCOUNT</li><li>LIFE_INCOME_FUND</li><li>REGISTERED_RETIREMENT_INCOME_FUND</li><li>SPOUSAL_RETIREMENT_INCOME_FUND</li><li>LOCKED_IN_REGISTERED_INVESTMENT_FUND</li><li>PRESCRIBED_REGISTERED_RETIREMENT_INCOME_FUND</li><li>GUARANTEED_INVESTMENT_CERTIFICATES</li><li>REGISTERED_DISABILITY_SAVINGS_PLAN</li><li>DIGITAL_WALLET</li><li>OTHER</li></ul><b>investment (SN 2.0)</b><ul><li>BROKERAGE_CASH</li><li>BROKERAGE_MARGIN</li><li>INDIVIDUAL_RETIREMENT_ACCOUNT_IRA</li><li>EMPLOYEE_RETIREMENT_ACCOUNT_401K</li><li>EMPLOYEE_RETIREMENT_SAVINGS_PLAN_403B</li><li>TRUST</li><li>ANNUITY</li><li>SIMPLE_IRA</li><li>CUSTODIAL_ACCOUNT</li><li>BROKERAGE_CASH_OPTION</li><li>BROKERAGE_MARGIN_OPTION</li><li>INDIVIDUAL</li><li>CORPORATE_INVESTMENT_ACCOUNT</li><li>JOINT_TENANTS_TENANCY_IN_COMMON_JTIC</li><li>JOINT_TENANTS_WITH_RIGHTS_OF_SURVIVORSHIP_JTWROS</li><li>JOINT_TENANTS_COMMUNITY_PROPERTY</li><li>JOINT_TENANTS_TENANTS_BY_ENTIRETY</li><li>CONSERVATOR</li><li>ROTH_IRA</li><li>ROTH_CONVERSION</li><li>ROLLOVER_IRA</li><li>EDUCATIONAL</li><li>EDUCATIONAL_SAVINGS_PLAN_529</li><li>DEFERRED_COMPENSATION_PLAN_457</li><li>MONEY_PURCHASE_RETIREMENT_PLAN_401A</li><li>PROFIT_SHARING_PLAN</li><li>MONEY_PURCHASE_PLAN</li><li>STOCK_BASKET_ACCOUNT</li><li>LIVING_TRUST</li><li>REVOCABLE_TRUST</li><li>IRREVOCABLE_TRUST</li><li>CHARITABLE_REMAINDER_TRUST</li><li>CHARITABLE_LEAD_TRUST</li><li>CHARITABLE_GIFT_ACCOUNT</li><li>SEP_IRA</li><li>UNIFORM_TRANSFER_TO_MINORS_ACT_UTMA</li><li>UNIFORM_GIFT_TO_MINORS_ACT_UGMA</li><li>EMPLOYEE_STOCK_OWNERSHIP_PLAN_ESOP</li><li>ADMINISTRATOR</li><li>EXECUTOR</li><li>PARTNERSHIP</li><li>PROPRIETORSHIP</li><li>CHURCH_ACCOUNT</li><li>INVESTMENT_CLUB</li><li>RESTRICTED_STOCK_AWARD</li><li>CASH_MANAGEMENT_ACCOUNT</li><li>EMPLOYEE_STOCK_PURCHASE_PLAN_ESPP</li><li>PERFORMANCE_PLAN</li><li>BROKERAGE_LINK_ACCOUNT</li><li>MONEY_MARKET_ACCOUNT</li><li>SUPERANNUATION</li><li>REGISTERED_RETIREMENT_SAVINGS_PLAN_RRSP</li><li>SPOUSAL_RETIREMENT_SAVINGS_PLAN_SRSP</li><li>DEFERRED_PROFIT_SHARING_PLAN_DPSP</li><li>NON_REGISTERED_SAVINGS_PLAN_NRSP</li><li>REGISTERED_EDUCATION_SAVINGS_PLAN_RESP</li><li>GROUP_RETIREMENT_SAVINGS_PLAN_GRSP</li><li>LOCKED_IN_RETIREMENT_SAVINGS_PLAN_LRSP</li><li>RESTRICTED_LOCKED_IN_SAVINGS_PLAN_RLSP</li><li>LOCKED_IN_RETIREMENT_ACCOUNT_LIRA</li><li>REGISTERED_PENSION_PLAN_RPP</li><li>TAX_FREE_SAVINGS_ACCOUNT_TFSA</li><li>LIFE_INCOME_FUND_LIF</li><li>REGISTERED_RETIREMENT_INCOME_FUND_RIF</li><li>SPOUSAL_RETIREMENT_INCOME_FUND_SRIF</li><li>LOCKED_IN_REGISTERED_INVESTMENT_FUND_LRIF</li><li>PRESCRIBED_REGISTERED_RETIREMENT_INCOME_FUND_PRIF</li><li>GUARANTEED_INVESTMENT_CERTIFICATES_GIC</li><li>REGISTERED_DISABILITY_SAVINGS_PLAN_RDSP</li><li>DEFINED_CONTRIBUTION_PLAN</li><li>DEFINED_BENEFIT_PLAN</li><li>EMPLOYEE_STOCK_OPTION_PLAN</li><li>NONQUALIFIED_DEFERRED_COMPENSATION_PLAN_409A</li><li>KEOGH_PLAN</li><li>EMPLOYEE_RETIREMENT_ACCOUNT_ROTH_401K</li><li>DEFERRED_CONTINGENT_CAPITAL_PLAN_DCCP</li><li>EMPLOYEE_BENEFIT_PLAN</li><li>EMPLOYEE_SAVINGS_PLAN</li><li>HEALTH_SAVINGS_ACCOUNT_HSA</li><li>COVERDELL_EDUCATION_SAVINGS_ACCOUNT_ESA</li><li>TESTAMENTARY_TRUST</li><li>ESTATE</li><li>GRANTOR_RETAINED_ANNUITY_TRUST_GRAT</li><li>ADVISORY_ACCOUNT</li><li>NON_PROFIT_ORGANIZATION_501C</li><li>HEALTH_REIMBURSEMENT_ARRANGEMENT_HRA</li><li>INDIVIDUAL_SAVINGS_ACCOUNT_ISA</li><li>CASH_ISA</li><li>STOCKS_AND_SHARES_ISA</li><li>INNOVATIVE_FINANCE_ISA</li><li>JUNIOR_ISA</li><li>EMPLOYEES_PROVIDENT_FUND_ORGANIZATION_EPFO</li><li>PUBLIC_PROVIDENT_FUND_PPF</li><li>EMPLOYEES_PENSION_SCHEME_EPS</li><li>NATIONAL_PENSION_SYSTEM_NPS</li><li>INDEXED_ANNUITY</li><li>ANNUITIZED_ANNUITY</li><li>VARIABLE_ANNUITY</li><li>ROTH_403B</li><li>SPOUSAL_IRA</li><li>SPOUSAL_ROTH_IRA</li><li>SARSEP_IRA</li><li>SUBSTANTIALLY_EQUAL_PERIODIC_PAYMENTS_SEPP</li><li>OFFSHORE_TRUST</li><li>IRREVOCABLE_LIFE_INSURANCE_TRUST</li><li>INTERNATIONAL_TRUST</li><li>LIFE_INTEREST_TRUST</li><li>EMPLOYEE_BENEFIT_TRUST</li><li>PRECIOUS_METAL_ACCOUNT</li><li>INVESTMENT_LOAN_ACCOUNT</li><li>GRANTOR_RETAINED_INCOME_TRUST</li><li>PENSION_PLAN</li><li>DIGITAL_WALLET</li><li>OTHER</li></ul><ul><li>GET accounts/latestBalances</li></ul>
     * @type {string}
     * @memberof AccountLatestBalance
     */
    accountType?: string;
    /**
     * 
     * @type {Money}
     * @memberof AccountLatestBalance
     */
    currentBalance?: Money;
    /**
     * The status of the account balance refresh request.
     * @type {string}
     * @memberof AccountLatestBalance
     */
    refreshStatus?: AccountLatestBalance.RefreshStatusEnum;
    /**
     * The account number as it appears on the site. (The POST accounts service response return this field as number)<br><b>Additional Details</b>:<b> Bank / Investment</b>:<br> The account number for the bank account as it appears at the site.<br>In most cases, the site does not display the full account number in the account summary page and additional navigation is required to aggregate it.<br><b>Applicable containers</b>: bank, investment<br><b>Aggregated / Manual</b>: Aggregated<br><b>Endpoints</b>:<br><ul><li>GET accounts/latestBalances</li></ul>
     * @type {string}
     * @memberof AccountLatestBalance
     */
    accountNumber?: string;
    /**
     * 
     * @type {Money}
     * @memberof AccountLatestBalance
     */
    availableBalance?: Money;
    /**
     * The primary key of the provider account resource.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank, investment<br><b>Endpoints</b>:<ul><li>GET accounts/latestBalances</li></ul>
     * @type {number}
     * @memberof AccountLatestBalance
     */
    accountId?: number;
    /**
     * The date time the account information was last retrieved from the provider site and updated in the Yodlee system.<br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank, investment<br><b>Endpoints</b>:<ul><li>GET accounts/latestBalances</li></ul>
     * @type {string}
     * @memberof AccountLatestBalance
     */
    lastUpdated?: string;
    /**
     * 
     * @type {Money}
     * @memberof AccountLatestBalance
     */
    balance?: Money;
    /**
     * Identifier of the provider site. The primary key of provider resource. <br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank, investment<br><b>Endpoints</b>:<ul><li>GET accounts/latestBalances</li></ul>
     * @type {string}
     * @memberof AccountLatestBalance
     */
    providerId?: string;
    /**
     * The primary key of the provider account resource.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank, investment<br><b>Endpoints</b>:<ul><li>GET accounts/latestBalances</li></ul>
     * @type {number}
     * @memberof AccountLatestBalance
     */
    providerAccountId?: number;
    /**
     * The type of service. E.g., Bank, Investment <br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank, investment<br><b>Endpoints</b>:<ul><li>GET accounts/latestBalances</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof AccountLatestBalance
     */
    CONTAINER?: AccountLatestBalance.CONTAINEREnum;
    /**
     * 
     * @type {Money}
     * @memberof AccountLatestBalance
     */
    cash?: Money;
    /**
     * Service provider or institution name where the account originates. This belongs to the provider resource.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank, investment<br><b>Endpoints</b>:<ul><li>GET accounts/latestBalances</li></ul>
     * @type {string}
     * @memberof AccountLatestBalance
     */
    providerName?: string;
    /**
     * The reason the account balance refresh failed.
     * @type {string}
     * @memberof AccountLatestBalance
     */
    failedReason?: AccountLatestBalance.FailedReasonEnum;
}

/**
 * @export
 * @namespace AccountLatestBalance
 */
export namespace AccountLatestBalance {
    /**
     * @export
     * @enum {string}
     */
    export enum RefreshStatusEnum {
        SUCCESS = <any> 'SUCCESS',
        INPROGRESS = <any> 'IN_PROGRESS',
        FAILED = <any> 'FAILED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum CONTAINEREnum {
        Bank = <any> 'bank',
        Investment = <any> 'investment'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum FailedReasonEnum {
        REQUIREDDATANOTAVAILABLE = <any> 'REQUIRED_DATA_NOT_AVAILABLE',
        USERINPUTREQUIRED = <any> 'USER_INPUT_REQUIRED',
        CREDENTIALSUPDATENEEDED = <any> 'CREDENTIALS_UPDATE_NEEDED',
        INCORRECTCREDENTIALS = <any> 'INCORRECT_CREDENTIALS',
        USERACTIONNEEDEDATSITE = <any> 'USER_ACTION_NEEDED_AT_SITE',
        ADDLAUTHENTICATIONREQUIRED = <any> 'ADDL_AUTHENTICATION_REQUIRED',
        INVALIDADDLINFOPROVIDED = <any> 'INVALID_ADDL_INFO_PROVIDED',
        ACCOUNTLOCKED = <any> 'ACCOUNT_LOCKED',
        SITENOTSUPPORTED = <any> 'SITE_NOT_SUPPORTED',
        SITEBLOCKINGERROR = <any> 'SITE_BLOCKING_ERROR',
        TECHERROR = <any> 'TECH_ERROR',
        UNEXPECTEDSITEERROR = <any> 'UNEXPECTED_SITE_ERROR',
        SITEUNAVAILABLE = <any> 'SITE_UNAVAILABLE',
        SITESESSIONINVALIDATED = <any> 'SITE_SESSION_INVALIDATED',
        REQUESTTIMEOUT = <any> 'REQUEST_TIME_OUT',
        CONSENTEXPIRED = <any> 'CONSENT_EXPIRED',
        CONSENTREVOKED = <any> 'CONSENT_REVOKED',
        INCORRECTOAUTHTOKEN = <any> 'INCORRECT_OAUTH_TOKEN',
        CONSENTREQUIRED = <any> 'CONSENT_REQUIRED',
        NEWAUTHENTICATIONREQUIRED = <any> 'NEW_AUTHENTICATION_REQUIRED'
    }
}
/**
 * 
 * @export
 * @interface AccountProfile
 */
export interface AccountProfile {
    /**
     * Identifiers available in the profile page of the account.<br><br><b>Account Type</b>: Aggregated<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
     * @type {Array<Identifier>}
     * @memberof AccountProfile
     */
    identifier?: Array<Identifier>;
    /**
     * Address available in the profile page of the account.<br><br><b>Account Type</b>: Aggregated<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
     * @type {Array<AccountAddress>}
     * @memberof AccountProfile
     */
    address?: Array<AccountAddress>;
    /**
     * Phone number available in the profile page of the account.<br><br><b>Account Type</b>: Aggregated<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
     * @type {Array<PhoneNumber>}
     * @memberof AccountProfile
     */
    phoneNumber?: Array<PhoneNumber>;
    /**
     * Email Id available in the profile page of the account.<br><br><b>Account Type</b>: Aggregated<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
     * @type {Array<Email>}
     * @memberof AccountProfile
     */
    email?: Array<Email>;
}
/**
 * 
 * @export
 * @interface AccountResponse
 */
export interface AccountResponse {
    /**
     * 
     * @type {Array<Account>}
     * @memberof AccountResponse
     */
    account?: Array<Account>;
}
/**
 * 
 * @export
 * @interface ApiKeyOutput
 */
export interface ApiKeyOutput {
    /**
     * Time in seconds after which the JWT token created for users expires.<br><br><b>Endpoints</b>:<ul><li>GET /auth/apiKey</li><li>POST /auth/apiKey</li></ul>
     * @type {number}
     * @memberof ApiKeyOutput
     */
    expiresIn?: number;
    /**
     * The date on which the apiKey was created for the customer.<br><br><b>Endpoints</b>:<ul><li>GET /auth/apiKey</li><li>POST /auth/apiKey</li></ul>
     * @type {string}
     * @memberof ApiKeyOutput
     */
    createdDate?: string;
    /**
     * Public key uploaded by the customer while generating ApiKey.<br><br><b>Endpoints</b>:<ul><li>GET /auth/apiKey</li><li>POST /auth/apiKey</li></ul>
     * @type {string}
     * @memberof ApiKeyOutput
     */
    publicKey?: string;
    /**
     * ApiKey or the issuer key used to generate the JWT token for authentication.<br><br><b>Endpoints</b>:<ul><li>GET /auth/apiKey</li><li>POST /auth/apiKey</li></ul>
     * @type {string}
     * @memberof ApiKeyOutput
     */
    key?: string;
}
/**
 * 
 * @export
 * @interface ApiKeyRequest
 */
export interface ApiKeyRequest {
    /**
     * Public key uploaded by the customer while generating ApiKey.<br><br><b>Endpoints</b>:<ul><li>GET /auth/apiKey</li><li>POST /auth/apiKey</li></ul>
     * @type {string}
     * @memberof ApiKeyRequest
     */
    publicKey?: string;
}
/**
 * 
 * @export
 * @interface ApiKeyResponse
 */
export interface ApiKeyResponse {
    /**
     * ApiKey customer details.<br><br><b>Endpoints</b>:<ul><li>GET /auth/apiKey</li><li>POST /auth/apiKey</li></ul>
     * @type {Array<ApiKeyOutput>}
     * @memberof ApiKeyResponse
     */
    apiKey?: Array<ApiKeyOutput>;
}
/**
 * 
 * @export
 * @interface AssetClassification
 */
export interface AssetClassification {
    /**
     * The allocation percentage of the holding.<br><br><b>Required Feature Enablement</b>: Asset classification feature<br><br><b>Applicable containers</b>: investment<br>
     * @type {number}
     * @memberof AssetClassification
     */
    allocation?: number;
    /**
     * The type of classification to which the investment belongs (assetClass, country, sector, and style).<br><b>Required Feature Enablement</b>: Asset classification feature<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof AssetClassification
     */
    classificationType?: string;
    /**
     * The value for each classificationType.<br><b>Required Feature Enablement</b>: Asset classification feature<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof AssetClassification
     */
    classificationValue?: string;
}
/**
 * 
 * @export
 * @interface AssetClassificationList
 */
export interface AssetClassificationList {
    /**
     * The type of classification to which the investment belongs (assetClass, country, sector, and style).<br><b>Required Feature Enablement</b>: Asset classification feature<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof AssetClassificationList
     */
    classificationType?: string;
    /**
     * The value for each classificationType.<br><b>Required Feature Enablement</b>: Asset classification feature<br><br><b>Applicable containers</b>: investment<br>
     * @type {Array<string>}
     * @memberof AssetClassificationList
     */
    classificationValue?: Array<string>;
}
/**
 * 
 * @export
 * @interface Attribute
 */
export interface Attribute {
    /**
     * Containers for which the attributes are supported.<br><br><b>Endpoints</b>:<ul><li>GET providers</li><li>GET providers/{providerId}</li></ul>
     * @type {Array<string>}
     * @memberof Attribute
     */
    container?: Array<Attribute.ContainerEnum>;
    /**
     * Applicable only to EBILLS and STATEMENTS attributes of DOCUMENT dataset.<br><br><b>Endpoints</b>:<ul><li>POST providerAccounts</li><li>PUT providerAccounts</li></ul>
     * @type {string}
     * @memberof Attribute
     */
    fromDate?: string;
    /**
     * Applicable only to TAX attribute of DOCUMENT dataset.<br><br><b>Endpoints</b>:<ul><li>POST providerAccounts</li><li>PUT providerAccounts</li></ul>
     * @type {string}
     * @memberof Attribute
     */
    toFinYear?: string;
    /**
     * Applicable only to TAX attribute of DOCUMENT dataset.<br><br><b>Endpoints</b>:<ul><li>POST providerAccounts</li><li>PUT providerAccounts</li></ul>
     * @type {string}
     * @memberof Attribute
     */
    fromFinYear?: string;
    /**
     * 
     * @type {ContainerAttributes}
     * @memberof Attribute
     */
    containerAttributes?: ContainerAttributes;
    /**
     * Applicable only to EBILLS and STATEMENTS attributes of DOCUMENT dataset.<br><br><b>Endpoints</b>:<ul><li>POST providerAccounts</li><li>PUT providerAccounts</li></ul>
     * @type {string}
     * @memberof Attribute
     */
    toDate?: string;
    /**
     * Attributes that are supported for a dataset.<br><br><b>Endpoints</b>:<ul><li>GET providers</li><li>GET providers/{providerId}</li></ul>
     * @type {string}
     * @memberof Attribute
     */
    name?: Attribute.NameEnum;
}

/**
 * @export
 * @namespace Attribute
 */
export namespace Attribute {
    /**
     * @export
     * @enum {string}
     */
    export enum ContainerEnum {
        Bank = <any> 'bank',
        CreditCard = <any> 'creditCard',
        Investment = <any> 'investment',
        Insurance = <any> 'insurance',
        Loan = <any> 'loan',
        Reward = <any> 'reward',
        Bill = <any> 'bill',
        RealEstate = <any> 'realEstate',
        OtherAssets = <any> 'otherAssets',
        OtherLiabilities = <any> 'otherLiabilities'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        BASICACCOUNTINFO = <any> 'BASIC_ACCOUNT_INFO',
        TRANSACTIONS = <any> 'TRANSACTIONS',
        STATEMENTS = <any> 'STATEMENTS',
        HOLDINGS = <any> 'HOLDINGS',
        ACCOUNTDETAILS = <any> 'ACCOUNT_DETAILS',
        TAX = <any> 'TAX',
        EBILLS = <any> 'EBILLS',
        FULLACCTNUMBER = <any> 'FULL_ACCT_NUMBER',
        BANKTRANSFERCODE = <any> 'BANK_TRANSFER_CODE',
        HOLDERNAME = <any> 'HOLDER_NAME',
        HOLDERDETAILS = <any> 'HOLDER_DETAILS',
        PAYMENTPROFILE = <any> 'PAYMENT_PROFILE',
        PAYMENTDETAILS = <any> 'PAYMENT_DETAILS',
        INTERESTDETAILS = <any> 'INTEREST_DETAILS',
        COVERAGE = <any> 'COVERAGE'
    }
}
/**
 * 
 * @export
 * @interface AuthTokenBody
 */
export interface AuthTokenBody {
    /**
     * clientId issued by Yodlee is used to generate the OAuth token for authentication.
     * @type {string}
     * @memberof AuthTokenBody
     */
    clientId?: string;
    /**
     * secret issued by Yodlee is used to generate the OAuth token for authentication.
     * @type {string}
     * @memberof AuthTokenBody
     */
    secret?: string;
}
/**
 * 
 * @export
 * @interface AutoRefresh
 */
export interface AutoRefresh {
    /**
     * Indicates the reason for the status.<br><br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof AutoRefresh
     */
    additionalStatus?: AutoRefresh.AdditionalStatusEnum;
    /**
     * Date on which the auto refresh status is determined.<br><br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
     * @type {string}
     * @memberof AutoRefresh
     */
    asOfDate?: string;
    /**
     * Indicates whether auto refresh is enabled or disabled.<br><br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof AutoRefresh
     */
    status?: AutoRefresh.StatusEnum;
}

/**
 * @export
 * @namespace AutoRefresh
 */
export namespace AutoRefresh {
    /**
     * @export
     * @enum {string}
     */
    export enum AdditionalStatusEnum {
        SCHEDULED = <any> 'SCHEDULED',
        TEMPERROR = <any> 'TEMP_ERROR',
        SITEBLOCKING = <any> 'SITE_BLOCKING',
        SITENOTSUPPORTED = <any> 'SITE_NOT_SUPPORTED',
        REALTIMEMFAREQUIRED = <any> 'REAL_TIME_MFA_REQUIRED',
        USERACTIONREQUIRED = <any> 'USER_ACTION_REQUIRED',
        UNSUBSCRIBED = <any> 'UNSUBSCRIBED',
        MANUALACCOUNT = <any> 'MANUAL_ACCOUNT'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        ENABLED = <any> 'ENABLED',
        DISABLED = <any> 'DISABLED'
    }
}
/**
 * 
 * @export
 * @interface BankTransferCode
 */
export interface BankTransferCode {
    /**
     * The FI's branch identification number.Additional Details: The routing number of the bank account in the United States. For non-United States accounts, it is the IFSC code (India), BSB number (Australia), and sort code (United Kingdom). <br><b>Account Type</b>: Aggregated<br><b>Applicable containers</b>: bank, investment<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>POST verification</li></ul>
     * @type {string}
     * @memberof BankTransferCode
     */
    id?: string;
    /**
     * The bank transfer code type varies depending on the region of the account origination. <br><b>Account Type</b>: Aggregated<br><b>Applicable containers</b>: bank, investment<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>POST verification</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof BankTransferCode
     */
    type?: BankTransferCode.TypeEnum;
}

/**
 * @export
 * @namespace BankTransferCode
 */
export namespace BankTransferCode {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        BSB = <any> 'BSB',
        IFSC = <any> 'IFSC',
        ROUTINGNUMBER = <any> 'ROUTING_NUMBER',
        SORTCODE = <any> 'SORT_CODE'
    }
}
/**
 * 
 * @export
 * @interface Capability
 */
export interface Capability {
    /**
     * 
     * @type {Array<string>}
     * @memberof Capability
     */
    container?: Array<Capability.ContainerEnum>;
    /**
     * 
     * @type {string}
     * @memberof Capability
     */
    name?: string;
}

/**
 * @export
 * @namespace Capability
 */
export namespace Capability {
    /**
     * @export
     * @enum {string}
     */
    export enum ContainerEnum {
        Bank = <any> 'bank',
        CreditCard = <any> 'creditCard',
        Investment = <any> 'investment',
        Insurance = <any> 'insurance',
        Loan = <any> 'loan',
        Reward = <any> 'reward',
        Bill = <any> 'bill',
        RealEstate = <any> 'realEstate',
        OtherAssets = <any> 'otherAssets',
        OtherLiabilities = <any> 'otherLiabilities'
    }
}
/**
 * 
 * @export
 * @interface ClientCredentialToken
 */
export interface ClientCredentialToken {
    /**
     * Time in seconds after which the issued accessToken expires.<br><br><b>Endpoints</b>:<ul><li>POST /auth/token</li></ul>
     * @type {number}
     * @memberof ClientCredentialToken
     */
    expiresIn?: number;
    /**
     * The date and time on which accessToken was created for the customer.<br><br><b>Endpoints</b>:<ul><li>POST /auth/token</li></ul>
     * @type {string}
     * @memberof ClientCredentialToken
     */
    issuedAt?: string;
    /**
     * Access Token to access YSL 1.1 services.<br><br><b>Endpoints</b>:<ul><li>POST /auth/token</li></ul>
     * @type {string}
     * @memberof ClientCredentialToken
     */
    accessToken?: string;
}
/**
 * 
 * @export
 * @interface ClientCredentialTokenResponse
 */
export interface ClientCredentialTokenResponse {
    /**
     * 
     * @type {ClientCredentialToken}
     * @memberof ClientCredentialTokenResponse
     */
    token?: ClientCredentialToken;
}
/**
 * 
 * @export
 * @interface Cobrand
 */
export interface Cobrand {
    /**
     * 
     * @type {string}
     * @memberof Cobrand
     */
    cobrandLogin: string;
    /**
     * 
     * @type {string}
     * @memberof Cobrand
     */
    cobrandPassword: string;
    /**
     * The customer's locale that will be considered for the localization functionality.<br><br><b>Endpoints</b>:<ul><li>POST cobrand/login</li></ul>
     * @type {string}
     * @memberof Cobrand
     */
    locale?: string;
}
/**
 * 
 * @export
 * @interface CobrandLoginRequest
 */
export interface CobrandLoginRequest {
    /**
     * 
     * @type {Cobrand}
     * @memberof CobrandLoginRequest
     */
    cobrand: Cobrand;
}
/**
 * 
 * @export
 * @interface CobrandLoginResponse
 */
export interface CobrandLoginResponse {
    /**
     * 
     * @type {CobrandSession}
     * @memberof CobrandLoginResponse
     */
    session?: CobrandSession;
    /**
     * Unique identifier of the cobrand (customer) in the system.<br><br><b>Endpoints</b>:<ul><li>POST cobrand/login</li></ul>
     * @type {number}
     * @memberof CobrandLoginResponse
     */
    cobrandId?: number;
    /**
     * The application identifier.<br><br><b>Endpoints</b>:<ul><li>POST cobrand/login</li></ul>
     * @type {string}
     * @memberof CobrandLoginResponse
     */
    applicationId?: string;
    /**
     * The customer's locale that will be considered for the localization functionality.<br><br><b>Endpoints</b>:<ul><li>POST cobrand/login</li></ul>
     * @type {string}
     * @memberof CobrandLoginResponse
     */
    locale?: string;
}
/**
 * 
 * @export
 * @interface CobrandNotificationEvent
 */
export interface CobrandNotificationEvent {
    /**
     * Name of the event for which the customers must subscribe to receive notifications.<br><b>Valid Value:</b> Notification Events Name<br><br><b>Endpoints</b>:<ul><li>GET cobrand/config/notifications/events</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof CobrandNotificationEvent
     */
    name?: CobrandNotificationEvent.NameEnum;
    /**
     * URL to which the notification should be posted.<br><br><b>Endpoints</b>:<ul><li>GET cobrand/config/notifications/events</li></ul>
     * @type {string}
     * @memberof CobrandNotificationEvent
     */
    callbackUrl?: string;
}

/**
 * @export
 * @namespace CobrandNotificationEvent
 */
export namespace CobrandNotificationEvent {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        REFRESH = <any> 'REFRESH',
        DATAUPDATES = <any> 'DATA_UPDATES',
        AUTOREFRESHUPDATES = <any> 'AUTO_REFRESH_UPDATES'
    }
}
/**
 * 
 * @export
 * @interface CobrandNotificationResponse
 */
export interface CobrandNotificationResponse {
    /**
     * 
     * @type {Array<CobrandNotificationEvent>}
     * @memberof CobrandNotificationResponse
     */
    event?: Array<CobrandNotificationEvent>;
}
/**
 * 
 * @export
 * @interface CobrandPublicKeyResponse
 */
export interface CobrandPublicKeyResponse {
    /**
     * The key name used for encryption.<br><br><b>Endpoints</b>:<ul><li>GET cobrand/publicKey</li></ul>
     * @type {string}
     * @memberof CobrandPublicKeyResponse
     */
    keyAlias?: string;
    /**
     * Public key that the customer should be using to encrypt the credentials and answers before sending to the add & update providerAccounts APIs.<br><br><b>Endpoints</b>:<ul><li>GET cobrand/publicKey</li></ul>
     * @type {string}
     * @memberof CobrandPublicKeyResponse
     */
    keyAsPemString?: string;
}
/**
 * 
 * @export
 * @interface CobrandSession
 */
export interface CobrandSession {
    /**
     * 
     * @type {string}
     * @memberof CobrandSession
     */
    cobSession?: string;
}
/**
 * 
 * @export
 * @interface ConfigsNotificationEvent
 */
export interface ConfigsNotificationEvent {
    /**
     * Name of the event for which the customers must subscribe to receive notifications.<br><b>Valid Value:</b> Notification Events Name<br><br><b>Endpoints</b>:<ul><li>GET configs/notifications/events</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof ConfigsNotificationEvent
     */
    name?: ConfigsNotificationEvent.NameEnum;
    /**
     * URL to which the notification should be posted.<br><br><b>Endpoints</b>:<ul><li>GET configs/notifications/events</li></ul>
     * @type {string}
     * @memberof ConfigsNotificationEvent
     */
    callbackUrl?: string;
}

/**
 * @export
 * @namespace ConfigsNotificationEvent
 */
export namespace ConfigsNotificationEvent {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        REFRESH = <any> 'REFRESH',
        DATAUPDATES = <any> 'DATA_UPDATES',
        AUTOREFRESHUPDATES = <any> 'AUTO_REFRESH_UPDATES',
        LATESTBALANCEUPDATES = <any> 'LATEST_BALANCE_UPDATES'
    }
}
/**
 * 
 * @export
 * @interface ConfigsNotificationResponse
 */
export interface ConfigsNotificationResponse {
    /**
     * 
     * @type {Array<ConfigsNotificationEvent>}
     * @memberof ConfigsNotificationResponse
     */
    event?: Array<ConfigsNotificationEvent>;
}
/**
 * 
 * @export
 * @interface Contact
 */
export interface Contact {
    /**
     * Phone number of the merchant<br><br><b>Applicable containers</b>: bank,creditCard,investment,loan<br>
     * @type {string}
     * @memberof Contact
     */
    phone?: string;
    /**
     * Email Id of the merchant<br><br><b>Applicable containers</b>: bank,creditCard,investment,loan<br>
     * @type {string}
     * @memberof Contact
     */
    email?: string;
}
/**
 * 
 * @export
 * @interface ContainerAttributes
 */
export interface ContainerAttributes {
    /**
     * 
     * @type {TransactionDays}
     * @memberof ContainerAttributes
     */
    BANK?: TransactionDays;
    /**
     * 
     * @type {TransactionDays}
     * @memberof ContainerAttributes
     */
    LOAN?: TransactionDays;
    /**
     * 
     * @type {TransactionDays}
     * @memberof ContainerAttributes
     */
    CREDITCARD?: TransactionDays;
    /**
     * 
     * @type {TransactionDays}
     * @memberof ContainerAttributes
     */
    INVESTMENT?: TransactionDays;
    /**
     * 
     * @type {TransactionDays}
     * @memberof ContainerAttributes
     */
    INSURANCE?: TransactionDays;
}
/**
 * 
 * @export
 * @interface Coordinates
 */
export interface Coordinates {
    /**
     * Latitude of the merchant<br><br><b>Applicable containers</b>: bank,creditCard,loan<br>
     * @type {number}
     * @memberof Coordinates
     */
    latitude?: number;
    /**
     * Longitude of the merchant<br><br><b>Applicable containers</b>: bank,creditCard,loan<br>
     * @type {number}
     * @memberof Coordinates
     */
    longitude?: number;
}
/**
 * 
 * @export
 * @interface Coverage
 */
export interface Coverage {
    /**
     * The coverage amount-related details.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance,investment<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
     * @type {Array<CoverageAmount>}
     * @memberof Coverage
     */
    amount?: Array<CoverageAmount>;
    /**
     * The plan type for an insurance provided to an individual or an entity.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul><b>Applicable Values:</b><br>
     * @type {string}
     * @memberof Coverage
     */
    planType?: Coverage.PlanTypeEnum;
    /**
     * The date on which the coverage for the account ends or expires.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance,investment<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
     * @type {string}
     * @memberof Coverage
     */
    endDate?: string;
    /**
     * The type of coverage provided to an individual or an entity.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance,investment<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul><b>Applicable Values:</b><br>
     * @type {string}
     * @memberof Coverage
     */
    type?: Coverage.TypeEnum;
    /**
     * The date on which the coverage for the account starts.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance,investment<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
     * @type {string}
     * @memberof Coverage
     */
    startDate?: string;
}

/**
 * @export
 * @namespace Coverage
 */
export namespace Coverage {
    /**
     * @export
     * @enum {string}
     */
    export enum PlanTypeEnum {
        PPO = <any> 'PPO',
        HMO = <any> 'HMO',
        UNKNOWN = <any> 'UNKNOWN'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        VISION = <any> 'VISION',
        DENTAL = <any> 'DENTAL',
        MEDICAL = <any> 'MEDICAL',
        HEALTH = <any> 'HEALTH',
        DEATHCOVER = <any> 'DEATH_COVER',
        TOTALPERMANENTDISABILITY = <any> 'TOTAL_PERMANENT_DISABILITY',
        ACCIDENTALDEATHCOVER = <any> 'ACCIDENTAL_DEATH_COVER',
        INCOMEPROTECTION = <any> 'INCOME_PROTECTION',
        DEATHTOTALPERMANENTDISABILITY = <any> 'DEATH_TOTAL_PERMANENT_DISABILITY',
        OTHER = <any> 'OTHER'
    }
}
/**
 * 
 * @export
 * @interface CoverageAmount
 */
export interface CoverageAmount {
    /**
     * 
     * @type {Money}
     * @memberof CoverageAmount
     */
    cover?: Money;
    /**
     * The type of coverage unit indicates if the coverage is for an individual or a family.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance,investment<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul><b>Applicable Values:</b><br>
     * @type {string}
     * @memberof CoverageAmount
     */
    unitType?: CoverageAmount.UnitTypeEnum;
    /**
     * The type of coverage provided to an individual or an entity.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance,investment<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul><b>Applicable Values:</b><br>
     * @type {string}
     * @memberof CoverageAmount
     */
    type?: CoverageAmount.TypeEnum;
    /**
     * The type of coverage limit indicates if the coverage is in-network or out-of-network.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance,investment<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul><b>Applicable Values:</b><br>
     * @type {string}
     * @memberof CoverageAmount
     */
    limitType?: CoverageAmount.LimitTypeEnum;
    /**
     * 
     * @type {Money}
     * @memberof CoverageAmount
     */
    met?: Money;
}

/**
 * @export
 * @namespace CoverageAmount
 */
export namespace CoverageAmount {
    /**
     * @export
     * @enum {string}
     */
    export enum UnitTypeEnum {
        FAMILY = <any> 'PER_FAMILY',
        MEMBER = <any> 'PER_MEMBER'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        DEDUCTIBLE = <any> 'DEDUCTIBLE',
        OUTOFPOCKET = <any> 'OUT_OF_POCKET',
        ANNUALBENEFIT = <any> 'ANNUAL_BENEFIT',
        MAXBENEFIT = <any> 'MAX_BENEFIT',
        COVERAGEAMOUNT = <any> 'COVERAGE_AMOUNT',
        MONTHLYBENEFIT = <any> 'MONTHLY_BENEFIT',
        OTHER = <any> 'OTHER'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum LimitTypeEnum {
        INNETWORK = <any> 'IN_NETWORK',
        OUTNETWORK = <any> 'OUT_NETWORK'
    }
}
/**
 * 
 * @export
 * @interface CreateAccountInfo
 */
export interface CreateAccountInfo {
    /**
     * 
     * @type {string}
     * @memberof CreateAccountInfo
     */
    includeInNetWorth?: string;
    /**
     * 
     * @type {AccountAddress}
     * @memberof CreateAccountInfo
     */
    address?: AccountAddress;
    /**
     * 
     * @type {string}
     * @memberof CreateAccountInfo
     */
    accountName: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAccountInfo
     */
    accountType: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAccountInfo
     */
    dueDate?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAccountInfo
     */
    memo?: string;
    /**
     * 
     * @type {Money}
     * @memberof CreateAccountInfo
     */
    homeValue?: Money;
    /**
     * 
     * @type {string}
     * @memberof CreateAccountInfo
     */
    accountNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAccountInfo
     */
    frequency?: CreateAccountInfo.FrequencyEnum;
    /**
     * 
     * @type {Money}
     * @memberof CreateAccountInfo
     */
    amountDue?: Money;
    /**
     * 
     * @type {Money}
     * @memberof CreateAccountInfo
     */
    balance?: Money;
    /**
     * 
     * @type {string}
     * @memberof CreateAccountInfo
     */
    nickname?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAccountInfo
     */
    valuationType?: CreateAccountInfo.ValuationTypeEnum;
}

/**
 * @export
 * @namespace CreateAccountInfo
 */
export namespace CreateAccountInfo {
    /**
     * @export
     * @enum {string}
     */
    export enum FrequencyEnum {
        DAILY = <any> 'DAILY',
        ONETIME = <any> 'ONE_TIME',
        WEEKLY = <any> 'WEEKLY',
        EVERY2WEEKS = <any> 'EVERY_2_WEEKS',
        SEMIMONTHLY = <any> 'SEMI_MONTHLY',
        MONTHLY = <any> 'MONTHLY',
        QUARTERLY = <any> 'QUARTERLY',
        SEMIANNUALLY = <any> 'SEMI_ANNUALLY',
        ANNUALLY = <any> 'ANNUALLY',
        EVERY2MONTHS = <any> 'EVERY_2_MONTHS',
        EBILL = <any> 'EBILL',
        FIRSTDAYMONTHLY = <any> 'FIRST_DAY_MONTHLY',
        LASTDAYMONTHLY = <any> 'LAST_DAY_MONTHLY',
        EVERY4WEEKS = <any> 'EVERY_4_WEEKS',
        UNKNOWN = <any> 'UNKNOWN',
        OTHER = <any> 'OTHER'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ValuationTypeEnum {
        SYSTEM = <any> 'SYSTEM',
        MANUAL = <any> 'MANUAL'
    }
}
/**
 * 
 * @export
 * @interface CreateAccountRequest
 */
export interface CreateAccountRequest {
    /**
     * 
     * @type {CreateAccountInfo}
     * @memberof CreateAccountRequest
     */
    account: CreateAccountInfo;
}
/**
 * 
 * @export
 * @interface CreateCobrandNotificationEvent
 */
export interface CreateCobrandNotificationEvent {
    /**
     * URL to which the notification should be posted.<br><br><b>Endpoints</b>:<ul><li>GET cobrand/config/notifications/events</li></ul>
     * @type {string}
     * @memberof CreateCobrandNotificationEvent
     */
    callbackUrl?: string;
}
/**
 * 
 * @export
 * @interface CreateCobrandNotificationEventRequest
 */
export interface CreateCobrandNotificationEventRequest {
    /**
     * 
     * @type {CreateCobrandNotificationEvent}
     * @memberof CreateCobrandNotificationEventRequest
     */
    event: CreateCobrandNotificationEvent;
}
/**
 * 
 * @export
 * @interface CreateConfigsNotificationEvent
 */
export interface CreateConfigsNotificationEvent {
    /**
     * URL to which the notification should be posted.<br><br><b>Endpoints</b>:<ul><li>GET configs/notifications/events</li></ul>
     * @type {string}
     * @memberof CreateConfigsNotificationEvent
     */
    callbackUrl?: string;
}
/**
 * 
 * @export
 * @interface CreateConfigsNotificationEventRequest
 */
export interface CreateConfigsNotificationEventRequest {
    /**
     * 
     * @type {CreateConfigsNotificationEvent}
     * @memberof CreateConfigsNotificationEventRequest
     */
    event: CreateConfigsNotificationEvent;
}
/**
 * 
 * @export
 * @interface CreatedAccountInfo
 */
export interface CreatedAccountInfo {
    /**
     * 
     * @type {string}
     * @memberof CreatedAccountInfo
     */
    accountName?: string;
    /**
     * 
     * @type {number}
     * @memberof CreatedAccountInfo
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CreatedAccountInfo
     */
    accountNumber?: string;
}
/**
 * 
 * @export
 * @interface CreatedAccountResponse
 */
export interface CreatedAccountResponse {
    /**
     * 
     * @type {Array<CreatedAccountInfo>}
     * @memberof CreatedAccountResponse
     */
    account?: Array<CreatedAccountInfo>;
}
/**
 * 
 * @export
 * @interface DataExtractsAccount
 */
export interface DataExtractsAccount {
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    availableCash?: Money;
    /**
     * Used to determine  whether an account to be considered in the networth calculation.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank,creditCard,loan,investment,insurance,realEstate,otherAssets,otherLiabilities<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {boolean}
     * @memberof DataExtractsAccount
     */
    includeInNetWorth?: boolean;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    moneyMarketBalance?: Money;
    /**
     * Date on which the user is enrolled on the rewards program.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: reward<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    enrollmentDate?: string;
    /**
     * The date on which the home value was estimated.<br><br><b>Aggregated / Manual</b>: Manual<br><b>Applicable containers</b>: realEstate<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    estimatedDate?: string;
    /**
     * The additional description or notes given by the user.<br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    memo?: string;
    /**
     * A nonprofit or state organization that works with lender, servicer, school, and the Department of Education to help successfully repay Federal Family Education Loan Program (FFELP) loans. If FFELP student loans default, the guarantor takes ownership of them.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    guarantor?: string;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    interestPaidLastYear?: Money;
    /**
     * The date time the account information was last retrieved from the provider site and updated in the Yodlee system.<br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    lastUpdated?: string;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    balance?: Money;
    /**
     * Type of home insurance, like -<ul><li>HOME_OWNER</li><li>RENTAL</li><li>RENTER</li><li>etc..</li></ul><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    homeInsuranceType?: DataExtractsAccount.HomeInsuranceTypeEnum;
    /**
     * The primary key of the account resource and the unique identifier for the account.<br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts </li><li>GET accounts/{accountId}</li><li>GET investmentOptions</li><li>GET accounts/historicalBalances</li><li>POST accounts</li><li>GET dataExtracts/userData</li></ul>
     * @type {number}
     * @memberof DataExtractsAccount
     */
    id?: number;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    cash?: Money;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    totalCreditLine?: Money;
    /**
     * Service provider or institution name where the account originates. This belongs to the provider resource.<br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    providerName?: string;
    /**
     * The valuation type indicates whether the home value is calculated either manually or by Yodlee Partners.<br><br><b>Aggregated / Manual</b>: Manual<br><b>Applicable containers</b>: realEstate<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    valuationType?: DataExtractsAccount.ValuationTypeEnum;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    marginBalance?: Money;
    /**
     * The annual percentage rate (APR) is the yearly rate of interest on the credit card account.<br><b>Additional Details:</b> The yearly percentage rate charged when a balance is held on a credit card. This rate of interest is applied every month on the outstanding credit card balance.<br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: creditCard<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {number}
     * @memberof DataExtractsAccount
     */
    apr?: number;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    availableCredit?: Money;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    currentBalance?: Money;
    /**
     * Indicates if an account is aggregated from a site or it is a manual account i.e. account information manually provided by the user.<br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {boolean}
     * @memberof DataExtractsAccount
     */
    isManual?: boolean;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    escrowBalance?: Money;
    /**
     * The eligible next level of the rewards program.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: reward<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    nextLevel?: string;
    /**
     * The classification of the account such as personal, corporate, etc.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank, creditCard, investment, reward, loan, insurance<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    classification?: DataExtractsAccount.ClassificationEnum;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    loanPayoffAmount?: Money;
    /**
     * The type of the interest rate, for example, fixed or variable.<br><b>Applicable containers</b>: loan<br><b>Aggregated / Manual</b>: Aggregated<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    interestRateType?: DataExtractsAccount.InterestRateTypeEnum;
    /**
     * The date by which the payoff amount should be paid.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    loanPayByDate?: string;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    faceAmount?: Money;
    /**
     * The date the insurance policy began.<br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    policyFromDate?: string;
    /**
     * The number of years for which premium payments have to be made in a policy.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    premiumPaymentTerm?: string;
    /**
     * The duration for which the policy is valid or in effect. For example, one year, five years, etc.<br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    policyTerm?: string;
    /**
     * The type of repayment plan that the borrower prefers to repay the loan. <br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul><b>Applicable Values:</b><br>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    repaymentPlanType?: DataExtractsAccount.RepaymentPlanTypeEnum;
    /**
     * The type of account that is aggregated.
     * @type {string}
     * @memberof DataExtractsAccount
     */
    aggregatedAccountType?: string;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    availableBalance?: Money;
    /**
     * The status of the account that is updated by the consumer through an application or an API. Valid Values: AccountStatus<br><b>Additional Details:</b><br><b>ACTIVE:</b> All the added manual and aggregated accounts status will be made \"ACTIVE\" by default. <br><b>TO_BE_CLOSED:</b> If the aggregated accounts are not found or closed in the data provider site, Yodlee system marks the status as TO_BE_CLOSED<br><b>INACTIVE:</b> Users can update the status as INACTIVE to stop updating and to stop considering the account in other services<br><b>CLOSED:</b> Users can update the status as CLOSED, if the account is closed with the provider. <br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    accountStatus?: DataExtractsAccount.AccountStatusEnum;
    /**
     * Type of life insurance.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    lifeInsuranceType?: DataExtractsAccount.LifeInsuranceTypeEnum;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    premium?: Money;
    /**
     * The source through which the account(s) are added in the system.<br><b>Valid Values</b>: SYSTEM, USER<br><b>Applicable containers</b>: All Containers<br><b>Aggregated / Manual</b>: Both <br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    aggregationSource?: DataExtractsAccount.AggregationSourceEnum;
    /**
     * Indicates if the account is marked as deleted.<b>Applicable containers</b>: All Containers<br><b>Aggregated / Manual</b>: Both <br><b>Endpoints</b>:<br><ul><li>GET dataExtracts/userData</li></ul>
     * @type {boolean}
     * @memberof DataExtractsAccount
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    overDraftLimit?: Money;
    /**
     * The nickname of the account as provided by the consumer to identify an account. The account nickname can be used instead of the account name.<br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    nickname?: string;
    /**
     * The tenure for which the CD account is valid  or in case of loan, the number of years/months over which the loan amount  has to be repaid. <br><b>Additional Details:</b><br>  Bank: The Term field is only applicable for the account type CD.Loan: The period for which the loan agreement is in force. The period, before or at the end of which, the loan should either be repaid or renegotiated for another term.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank, loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    term?: string;
    /**
     * <br><b>Bank:</b> The interest rate offered by a FI to its depositors on a bank account.<br><b>Loan:</b> Interest rate applied on the loan.<br><b>Additional Details:</b><br><b>Note:</b> The Interest Rate field is only applicable for the following account types: savings, checking, money market, and certificate of deposit.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank, loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {number}
     * @memberof DataExtractsAccount
     */
    interestRate?: number;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    deathBenefit?: Money;
    /**
     * 
     * @type {AccountAddress}
     * @memberof DataExtractsAccount
     */
    address?: AccountAddress;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    cashValue?: Money;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    _401kLoan?: Money;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    homeValue?: Money;
    /**
     * The account number as it appears on the site. (The POST accounts service response return this field as number)<br><b>Additional Details</b>:<b> Bank/ Loan/ Insurance/ Investment</b>:<br> The account number for the bank account as it appears at the site.<br><b>Credit Card</b>: The account number of the card account as it appears at the site,<br>i.e., the card number.The account number can be full or partial based on how it is displayed in the account summary page of the site.In most cases, the site does not display the full account number in the account summary page and additional navigation is required to aggregate it.<br><b>Applicable containers</b>: All Containers<br><b>Aggregated / Manual</b>: Both <br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>POST accounts</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    accountNumber?: string;
    /**
     * The date on which the account is created in the Yodlee system.<br><b>Additional Details:</b> It is the date when the user links or aggregates the account(s) that are held with the provider to the Yodlee system.<br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    createdDate?: string;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    interestPaidYTD?: Money;
    /**
     * The primary key of the provider account resource.<br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {number}
     * @memberof DataExtractsAccount
     */
    providerAccountId?: number;
    /**
     * Indicates if the account is selected by user for aggregation.<br><b>Applicable containers</b>: All Containers<br><b>Aggregated / Manual</b>: Both <br><b>Endpoints</b>:<br><ul><li>GET dataExtracts/userData</li></ul>
     * @type {boolean}
     * @memberof DataExtractsAccount
     */
    isSelectedForAggregation?: boolean;
    /**
     * Property or possession offered to support a loan that can be seized on a default.<br><b>Applicable containers</b>: loan<br><b>Aggregated / Manual</b>: Aggregated<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    collateral?: string;
    /**
     * Logical grouping of dataset attributes into datasets such as Basic Aggregation Data, Account Profile and Documents.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {Array<AccountDataset>}
     * @memberof DataExtractsAccount
     */
    dataset?: Array<AccountDataset>;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    runningBalance?: Money;
    /**
     * A unique ID that the provider site has assigned to the account. The source ID is only available for the HELD accounts.<br><br><b>Applicable containers</b>: bank, creditCard, investment, insurance, loan, reward<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    sourceId?: string;
    /**
     * The date on which the due amount has to be paid. <br><b>Additional Details:</b><br><b>Credit Card:</b> The monthly date by when the minimum payment is due to be paid on the credit card account. <br><b>Loan:</b> The date on or before which the due amount should be paid.<br><b>Note:</b> The due date at the account-level can differ from the due date field at the statement-level, as the information in the aggregated card account data provides an up-to-date information to the consumer.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: creditCard, loan, insurance<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    dueDate?: string;
    /**
     * The frequency of the billing cycle of the account in case of card. The frequency in which premiums are paid in an insurance policy such as monthly, quarterly, and annually. The frequency in which due amounts are paid in a loan  account.<br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: creditCard, insurance, loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    frequency?: DataExtractsAccount.FrequencyEnum;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    maturityAmount?: Money;
    /**
     * The providerAccountIds that share the account with the primary providerAccountId that was created when the user had added the account for the first time.<br><b>Additional Details</b>: This attribute is returned in the response only if the account deduplication feature is enabled and the same account is mapped to more than one provider account IDs indicating the account is owned by more than one user, for example, joint accounts.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: All Containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {Array<number>}
     * @memberof DataExtractsAccount
     */
    associatedProviderAccountId?: Array<number>;
    /**
     * The account to be considered as an asset or liability.<br><b>Applicable containers</b>: All Containers<br><b>Aggregated / Manual</b>: Both <br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {boolean}
     * @memberof DataExtractsAccount
     */
    isAsset?: boolean;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    principalBalance?: Money;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    totalCashLimit?: Money;
    /**
     * The date when a certificate of deposit (CD/FD) matures or the final payment date of a loan at which point the principal amount (including pending interest) is due to be paid.<br><b>Additional Details:</b> The date when a certificate of deposit (CD) matures, i.e., the money in the CD can be withdrawn without paying an early withdrawal penalty.The final payment date of a loan, i.e., the principal amount (including pending interest) is due to be paid.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank, loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    maturityDate?: string;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    minimumAmountDue?: Money;
    /**
     * Annual percentage yield (APY) is a normalized representation of an interest rate, based on a compounding period of one year. APY generally refers to the rate paid to a depositor by a financial institution on an account.<br><b>Applicable containers</b>: bank<br><b>Aggregated / Manual</b>: Aggregated<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {number}
     * @memberof DataExtractsAccount
     */
    annualPercentageYield?: number;
    /**
     * The type of account that is aggregated, i.e., savings, checking, credit card, charge, HELOC, etc. The account type is derived based on the attributes of the account. <br><b>Valid Values:</b><br><b>Aggregated Account Type</b><br><b>bank</b><ul><li>CHECKING</li><li>SAVINGS</li><li>CD</li><li>PPF</li><li>RECURRING_DEPOSIT</li><li>FSA</li><li>MONEY_MARKET</li><li>IRA</li><li>PREPAID</li></ul><b>creditCard</b><ul><li>OTHER</li><li>CREDIT</li><li>STORE</li><li>CHARGE</li><li>OTHER</li></ul><b>investment (SN 1.0)</b><ul><li>BROKERAGE_MARGIN</li><li>HSA</li><li>IRA</li><li>BROKERAGE_CASH</li><li>401K</li><li>403B</li><li>TRUST</li><li>ANNUITY</li><li>SIMPLE</li><li>CUSTODIAL</li><li>BROKERAGE_CASH_OPTION</li><li>BROKERAGE_MARGIN_OPTION</li><li>INDIVIDUAL</li><li>CORPORATE</li><li>JTTIC</li><li>JTWROS</li><li>COMMUNITY_PROPERTY</li><li>JOINT_BY_ENTIRETY</li><li>CONSERVATORSHIP</li><li>ROTH</li><li>ROTH_CONVERSION</li><li>ROLLOVER</li><li>EDUCATIONAL</li><li>529_PLAN</li><li>457_DEFERRED_COMPENSATION</li><li>401A</li><li>PSP</li><li>MPP</li><li>STOCK_BASKET</li><li>LIVING_TRUST</li><li>REVOCABLE_TRUST</li><li>IRREVOCABLE_TRUST</li><li>CHARITABLE_REMAINDER</li><li>CHARITABLE_LEAD</li><li>CHARITABLE_GIFT_ACCOUNT</li><li>SEP</li><li>UTMA</li><li>UGMA</li><li>ESOPP</li><li>ADMINISTRATOR</li><li>EXECUTOR</li><li>PARTNERSHIP</li><li>SOLE_PROPRIETORSHIP</li><li>CHURCH</li><li>INVESTMENT_CLUB</li><li>RESTRICTED_STOCK_AWARD</li><li>CMA</li><li>EMPLOYEE_STOCK_PURCHASE_PLAN</li><li>PERFORMANCE_PLAN</li><li>BROKERAGE_LINK_ACCOUNT</li><li>MONEY_MARKET</li><li>SUPER_ANNUATION</li><li>REGISTERED_RETIREMENT_SAVINGS_PLAN</li><li>SPOUSAL_RETIREMENT_SAVINGS_PLAN</li><li>DEFERRED_PROFIT_SHARING_PLAN</li><li>NON_REGISTERED_SAVINGS_PLAN</li><li>REGISTERED_EDUCATION_SAVINGS_PLAN</li><li>GROUP_RETIREMENT_SAVINGS_PLAN</li><li>LOCKED_IN_RETIREMENT_SAVINGS_PLAN</li><li>RESTRICTED_LOCKED_IN_SAVINGS_PLAN</li><li>LOCKED_IN_RETIREMENT_ACCOUNT</li><li>REGISTERED_PENSION_PLAN</li><li>TAX_FREE_SAVINGS_ACCOUNT</li><li>LIFE_INCOME_FUND</li><li>REGISTERED_RETIREMENT_INCOME_FUND</li><li>SPOUSAL_RETIREMENT_INCOME_FUND</li><li>LOCKED_IN_REGISTERED_INVESTMENT_FUND</li><li>PRESCRIBED_REGISTERED_RETIREMENT_INCOME_FUND</li><li>GUARANTEED_INVESTMENT_CERTIFICATES</li><li>REGISTERED_DISABILITY_SAVINGS_PLAN</li><li>DIGITAL_WALLET</li><li>OTHER</li></ul><b>investment (SN 2.0)</b><ul><li>BROKERAGE_CASH</li><li>BROKERAGE_MARGIN</li><li>INDIVIDUAL_RETIREMENT_ACCOUNT_IRA</li><li>EMPLOYEE_RETIREMENT_ACCOUNT_401K</li><li>EMPLOYEE_RETIREMENT_SAVINGS_PLAN_403B</li><li>TRUST</li><li>ANNUITY</li><li>SIMPLE_IRA</li><li>CUSTODIAL_ACCOUNT</li><li>BROKERAGE_CASH_OPTION</li><li>BROKERAGE_MARGIN_OPTION</li><li>INDIVIDUAL</li><li>CORPORATE_INVESTMENT_ACCOUNT</li><li>JOINT_TENANTS_TENANCY_IN_COMMON_JTIC</li><li>JOINT_TENANTS_WITH_RIGHTS_OF_SURVIVORSHIP_JTWROS</li><li>JOINT_TENANTS_COMMUNITY_PROPERTY</li><li>JOINT_TENANTS_TENANTS_BY_ENTIRETY</li><li>CONSERVATOR</li><li>ROTH_IRA</li><li>ROTH_CONVERSION</li><li>ROLLOVER_IRA</li><li>EDUCATIONAL</li><li>EDUCATIONAL_SAVINGS_PLAN_529</li><li>DEFERRED_COMPENSATION_PLAN_457</li><li>MONEY_PURCHASE_RETIREMENT_PLAN_401A</li><li>PROFIT_SHARING_PLAN</li><li>MONEY_PURCHASE_PLAN</li><li>STOCK_BASKET_ACCOUNT</li><li>LIVING_TRUST</li><li>REVOCABLE_TRUST</li><li>IRREVOCABLE_TRUST</li><li>CHARITABLE_REMAINDER_TRUST</li><li>CHARITABLE_LEAD_TRUST</li><li>CHARITABLE_GIFT_ACCOUNT</li><li>SEP_IRA</li><li>UNIFORM_TRANSFER_TO_MINORS_ACT_UTMA</li><li>UNIFORM_GIFT_TO_MINORS_ACT_UGMA</li><li>EMPLOYEE_STOCK_OWNERSHIP_PLAN_ESOP</li><li>ADMINISTRATOR</li><li>EXECUTOR</li><li>PARTNERSHIP</li><li>PROPRIETORSHIP</li><li>CHURCH_ACCOUNT</li><li>INVESTMENT_CLUB</li><li>RESTRICTED_STOCK_AWARD</li><li>CASH_MANAGEMENT_ACCOUNT</li><li>EMPLOYEE_STOCK_PURCHASE_PLAN_ESPP</li><li>PERFORMANCE_PLAN</li><li>BROKERAGE_LINK_ACCOUNT</li><li>MONEY_MARKET_ACCOUNT</li><li>SUPERANNUATION</li><li>REGISTERED_RETIREMENT_SAVINGS_PLAN_RRSP</li><li>SPOUSAL_RETIREMENT_SAVINGS_PLAN_SRSP</li><li>DEFERRED_PROFIT_SHARING_PLAN_DPSP</li><li>NON_REGISTERED_SAVINGS_PLAN_NRSP</li><li>REGISTERED_EDUCATION_SAVINGS_PLAN_RESP</li><li>GROUP_RETIREMENT_SAVINGS_PLAN_GRSP</li><li>LOCKED_IN_RETIREMENT_SAVINGS_PLAN_LRSP</li><li>RESTRICTED_LOCKED_IN_SAVINGS_PLAN_RLSP</li><li>LOCKED_IN_RETIREMENT_ACCOUNT_LIRA</li><li>REGISTERED_PENSION_PLAN_RPP</li><li>TAX_FREE_SAVINGS_ACCOUNT_TFSA</li><li>LIFE_INCOME_FUND_LIF</li><li>REGISTERED_RETIREMENT_INCOME_FUND_RIF</li><li>SPOUSAL_RETIREMENT_INCOME_FUND_SRIF</li><li>LOCKED_IN_REGISTERED_INVESTMENT_FUND_LRIF</li><li>PRESCRIBED_REGISTERED_RETIREMENT_INCOME_FUND_PRIF</li><li>GUARANTEED_INVESTMENT_CERTIFICATES_GIC</li><li>REGISTERED_DISABILITY_SAVINGS_PLAN_RDSP</li><li>DEFINED_CONTRIBUTION_PLAN</li><li>DEFINED_BENEFIT_PLAN</li><li>EMPLOYEE_STOCK_OPTION_PLAN</li><li>NONQUALIFIED_DEFERRED_COMPENSATION_PLAN_409A</li><li>KEOGH_PLAN</li><li>EMPLOYEE_RETIREMENT_ACCOUNT_ROTH_401K</li><li>DEFERRED_CONTINGENT_CAPITAL_PLAN_DCCP</li><li>EMPLOYEE_BENEFIT_PLAN</li><li>EMPLOYEE_SAVINGS_PLAN</li><li>HEALTH_SAVINGS_ACCOUNT_HSA</li><li>COVERDELL_EDUCATION_SAVINGS_ACCOUNT_ESA</li><li>TESTAMENTARY_TRUST</li><li>ESTATE</li><li>GRANTOR_RETAINED_ANNUITY_TRUST_GRAT</li><li>ADVISORY_ACCOUNT</li><li>NON_PROFIT_ORGANIZATION_501C</li><li>HEALTH_REIMBURSEMENT_ARRANGEMENT_HRA</li><li>INDIVIDUAL_SAVINGS_ACCOUNT_ISA</li><li>CASH_ISA</li><li>STOCKS_AND_SHARES_ISA</li><li>INNOVATIVE_FINANCE_ISA</li><li>JUNIOR_ISA</li><li>EMPLOYEES_PROVIDENT_FUND_ORGANIZATION_EPFO</li><li>PUBLIC_PROVIDENT_FUND_PPF</li><li>EMPLOYEES_PENSION_SCHEME_EPS</li><li>NATIONAL_PENSION_SYSTEM_NPS</li><li>INDEXED_ANNUITY</li><li>ANNUITIZED_ANNUITY</li><li>VARIABLE_ANNUITY</li><li>ROTH_403B</li><li>SPOUSAL_IRA</li><li>SPOUSAL_ROTH_IRA</li><li>SARSEP_IRA</li><li>SUBSTANTIALLY_EQUAL_PERIODIC_PAYMENTS_SEPP</li><li>OFFSHORE_TRUST</li><li>IRREVOCABLE_LIFE_INSURANCE_TRUST</li><li>INTERNATIONAL_TRUST</li><li>LIFE_INTEREST_TRUST</li><li>EMPLOYEE_BENEFIT_TRUST</li><li>PRECIOUS_METAL_ACCOUNT</li><li>INVESTMENT_LOAN_ACCOUNT</li><li>GRANTOR_RETAINED_INCOME_TRUST</li><li>PENSION_PLAN</li><li>DIGITAL_WALLET</li><li>OTHER</li></ul><b>loan</b><ul><li>MORTGAGE</li><li>INSTALLMENT_LOAN</li><li>PERSONAL_LOAN</li><li>HOME_EQUITY_LINE_OF_CREDIT</li><li>LINE_OF_CREDIT</li><li>AUTO_LOAN</li><li>STUDENT_LOAN</li><li>HOME_LOAN</li></ul><b>insurance</b><ul><li>AUTO_INSURANCE</li><li>HEALTH_INSURANCE</li><li>HOME_INSURANCE</li><li>LIFE_INSURANCE</li><li>ANNUITY</li><li>TRAVEL_INSURANCE</li><li>INSURANCE</li></ul><b>realEstate</b><ul> <li>REAL_ESTATE</li></ul><b>reward</b><ul><li>REWARD_POINTS</li></ul><b>Manual Account Type</b><br><b>bank</b><ul><li>CHECKING</li><li>SAVINGS</li><li>CD</li><li>PREPAID</li></ul><b>credit</b><ul>  <li>CREDIT</li></ul><b>loan</b><ul>  <li>PERSONAL_LOAN</li><li>HOME_LOAN</li></ul><b>insurance</b><ul><li>INSURANCE</li><li>ANNUITY</li></ul><b>investment</b><ul><li>BROKERAGE_CASH</li></ul><br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    accountType?: string;
    /**
     * The date on which the loan is disbursed.<br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    originationDate?: string;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    totalVestedBalance?: Money;
    /**
     * Information of different reward balances associated with the account.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: reward<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {Array<RewardBalance>}
     * @memberof DataExtractsAccount
     */
    rewardBalance?: Array<RewardBalance>;
    /**
     * Indicates the status of the loan account. <br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul><b>Applicable Values:</b><br>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    sourceAccountStatus?: DataExtractsAccount.SourceAccountStatusEnum;
    /**
     * List of Loan accountId(s) to which the real-estate account is linked<br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: realEstate<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {Array<number>}
     * @memberof DataExtractsAccount
     */
    linkedAccountIds?: Array<number>;
    /**
     * Derived APR will be an estimated purchase APR based on consumers credit card transactions and credit card purchase.<br><b>Aggregated / Manual / Derived</b>: Derived<br><b>Applicable containers</b>: creditCard<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {number}
     * @memberof DataExtractsAccount
     */
    derivedApr?: number;
    /**
     * The date on which the insurance policy coverage commences.<br><b>Applicable containers</b>: insurance<br><b>Aggregated / Manual</b>: Aggregated<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    policyEffectiveDate?: string;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    totalUnvestedBalance?: Money;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    annuityBalance?: Money;
    /**
     * The account name as it appears at the site.<br>(The POST accounts service response return this field as name)<br><b>Applicable containers</b>: All Containers<br><b>Aggregated / Manual</b>: Both <br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    accountName?: string;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    totalCreditLimit?: Money;
    /**
     * The status of the policy.<br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    policyStatus?: DataExtractsAccount.PolicyStatusEnum;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    shortBalance?: Money;
    /**
     * The financial institution that provides the loan.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    lender?: string;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    lastEmployeeContributionAmount?: Money;
    /**
     * Identifier of the provider site. The primary key of provider resource. <br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    providerId?: string;
    /**
     * The date on which the payment for the previous or current billing cycle is done.<br><b>Additional Details:</b> If the payment is already done for the current billing cycle, then the field indicates the payment date of the current billing cycle. If payment is yet to be done for the current billing cycle, then the field indicates the date on which the payment was made for any of the previous billing cycles. The last payment date at the account-level can differ from the last payment date at the statement-level, as the information in the aggregated card account data provides an up-to-date information to the consumer.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: creditCard, loan, insurance<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    lastPaymentDate?: string;
    /**
     * Primary reward unit for this reward program. E.g. miles, points, etc.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: reward<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    primaryRewardUnit?: string;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    lastPaymentAmount?: Money;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    remainingBalance?: Money;
    /**
     * <b>Applicable containers</b>: reward, bank, creditCard, investment, loan, insurance, realEstate, otherLiabilities<br><b>Endpoints</b>:<ul><li>GET accounts </li><li>GET accounts/{accountId}</li><li>POST accounts</ul><li>GET dataExtracts/userData</li><b>Applicable Values</b><br>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    userClassification?: DataExtractsAccount.UserClassificationEnum;
    /**
     * Bank and branch identification information.<br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank, investment, loan<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {Array<BankTransferCode>}
     * @memberof DataExtractsAccount
     */
    bankTransferCode?: Array<BankTransferCode>;
    /**
     * The date on which the insurance policy expires or matures.<br><b>Additional Details:</b> The due date at the account-level can differ from the due date field at the statement-level, as the information in the aggregated card account data provides an up-to-date information to the consumer.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    expirationDate?: string;
    /**
     * The coverage-related details of the account.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance,investment<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {Array<Coverage>}
     * @memberof DataExtractsAccount
     */
    coverage?: Array<Coverage>;
    /**
     * Annual percentage rate applied to cash withdrawals on the card.<br><br><b>Account Type</b>: Aggregated<br><b>Applicable containers</b>: creditCard<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {number}
     * @memberof DataExtractsAccount
     */
    cashApr?: number;
    /**
     * Indicates the migration status of the account from screen-scraping provider to the Open Banking provider. <br><br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    oauthMigrationStatus?: DataExtractsAccount.OauthMigrationStatusEnum;
    /**
     * The name or identification of the account owner, as it appears at the FI site. <br><b>Note:</b> The account holder name can be full or partial based on how it is displayed in the account summary page of the FI site. In most cases, the FI site does not display the full account holder name in the account summary page.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank, creditCard, investment, insurance, loan, reward<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    displayedName?: string;
    /**
     * The providerAccountId that is deleted and merged into the destinationProviderAccountId as part of the many-to-one OAuth migration process.<br><b>Endpoints</b>:<ul><li>GET dataExtracts/userData</li></ul>
     * @type {number}
     * @memberof DataExtractsAccount
     */
    sourceProviderAccountId?: number;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    amountDue?: Money;
    /**
     * Current level of the reward program the user is associated with. E.g. Silver, Jade etc.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: reward<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    currentLevel?: string;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    originalLoanAmount?: Money;
    /**
     * The date to which the policy exists.<br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    policyToDate?: string;
    /**
     * 
     * @type {LoanPayoffDetails}
     * @memberof DataExtractsAccount
     */
    loanPayoffDetails?: LoanPayoffDetails;
    /**
     * The type of service. E.g., Bank, Credit Card, Investment, Insurance, etc.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    CONTAINER?: DataExtractsAccount.CONTAINEREnum;
    /**
     * The date on which the last employee contribution was made to the 401k account.<br><b>Note:</b> The last employee contribution date field is derived from the transaction data and not aggregated from the FI site. The field is only applicable to the 401k account type.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: investment<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsAccount
     */
    lastEmployeeContributionDate?: string;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    lastPayment?: Money;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsAccount
     */
    recurringPayment?: Money;
}

/**
 * @export
 * @namespace DataExtractsAccount
 */
export namespace DataExtractsAccount {
    /**
     * @export
     * @enum {string}
     */
    export enum HomeInsuranceTypeEnum {
        HOMEOWNER = <any> 'HOME_OWNER',
        RENTAL = <any> 'RENTAL',
        RENTER = <any> 'RENTER',
        UNKNOWN = <any> 'UNKNOWN',
        OTHER = <any> 'OTHER'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ValuationTypeEnum {
        SYSTEM = <any> 'SYSTEM',
        MANUAL = <any> 'MANUAL'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ClassificationEnum {
        OTHER = <any> 'OTHER',
        PERSONAL = <any> 'PERSONAL',
        CORPORATE = <any> 'CORPORATE',
        SMALLBUSINESS = <any> 'SMALL_BUSINESS',
        TRUST = <any> 'TRUST',
        ADDONCARD = <any> 'ADD_ON_CARD',
        VIRTUALCARD = <any> 'VIRTUAL_CARD'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum InterestRateTypeEnum {
        FIXED = <any> 'FIXED',
        VARIABLE = <any> 'VARIABLE',
        UNKNOWN = <any> 'UNKNOWN',
        OTHER = <any> 'OTHER'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RepaymentPlanTypeEnum {
        STANDARD = <any> 'STANDARD',
        GRADUATED = <any> 'GRADUATED',
        EXTENDED = <any> 'EXTENDED',
        INCOMEBASED = <any> 'INCOME_BASED',
        INCOMECONTINGENT = <any> 'INCOME_CONTINGENT',
        INCOMESENSITIVE = <any> 'INCOME_SENSITIVE',
        PAYASYOUEARN = <any> 'PAY_AS_YOU_EARN',
        REVISEDPAYASYOUEARN = <any> 'REVISED_PAY_AS_YOU_EARN'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum AccountStatusEnum {
        ACTIVE = <any> 'ACTIVE',
        INACTIVE = <any> 'INACTIVE',
        TOBECLOSED = <any> 'TO_BE_CLOSED',
        CLOSED = <any> 'CLOSED',
        DELETED = <any> 'DELETED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum LifeInsuranceTypeEnum {
        OTHER = <any> 'OTHER',
        TERMLIFEINSURANCE = <any> 'TERM_LIFE_INSURANCE',
        UNIVERSALLIFEINSURANCE = <any> 'UNIVERSAL_LIFE_INSURANCE',
        WHOLELIFEINSURANCE = <any> 'WHOLE_LIFE_INSURANCE',
        VARIABLELIFEINSURANCE = <any> 'VARIABLE_LIFE_INSURANCE',
        ULIP = <any> 'ULIP',
        ENDOWMENT = <any> 'ENDOWMENT'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum AggregationSourceEnum {
        SYSTEM = <any> 'SYSTEM',
        USER = <any> 'USER'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum FrequencyEnum {
        DAILY = <any> 'DAILY',
        ONETIME = <any> 'ONE_TIME',
        WEEKLY = <any> 'WEEKLY',
        EVERY2WEEKS = <any> 'EVERY_2_WEEKS',
        SEMIMONTHLY = <any> 'SEMI_MONTHLY',
        MONTHLY = <any> 'MONTHLY',
        QUARTERLY = <any> 'QUARTERLY',
        SEMIANNUALLY = <any> 'SEMI_ANNUALLY',
        ANNUALLY = <any> 'ANNUALLY',
        EVERY2MONTHS = <any> 'EVERY_2_MONTHS',
        EBILL = <any> 'EBILL',
        FIRSTDAYMONTHLY = <any> 'FIRST_DAY_MONTHLY',
        LASTDAYMONTHLY = <any> 'LAST_DAY_MONTHLY',
        EVERY4WEEKS = <any> 'EVERY_4_WEEKS',
        UNKNOWN = <any> 'UNKNOWN',
        OTHER = <any> 'OTHER'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SourceAccountStatusEnum {
        INREPAYMENT = <any> 'IN_REPAYMENT',
        DEFAULTED = <any> 'DEFAULTED',
        INSCHOOL = <any> 'IN_SCHOOL',
        INGRACEPERIOD = <any> 'IN_GRACE_PERIOD',
        DELINQUENCY = <any> 'DELINQUENCY',
        DEFERMENT = <any> 'DEFERMENT',
        FORBEARANCE = <any> 'FORBEARANCE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum PolicyStatusEnum {
        ACTIVE = <any> 'ACTIVE',
        INACTIVE = <any> 'IN_ACTIVE',
        OTHER = <any> 'OTHER'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum UserClassificationEnum {
        BUSINESS = <any> 'BUSINESS',
        PERSONAL = <any> 'PERSONAL'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum OauthMigrationStatusEnum {
        INPROGRESS = <any> 'IN_PROGRESS',
        TOBEMIGRATED = <any> 'TO_BE_MIGRATED',
        COMPLETED = <any> 'COMPLETED',
        MIGRATED = <any> 'MIGRATED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum CONTAINEREnum {
        Bank = <any> 'bank',
        CreditCard = <any> 'creditCard',
        Investment = <any> 'investment',
        Insurance = <any> 'insurance',
        Loan = <any> 'loan',
        Reward = <any> 'reward',
        Bill = <any> 'bill',
        RealEstate = <any> 'realEstate',
        OtherAssets = <any> 'otherAssets',
        OtherLiabilities = <any> 'otherLiabilities'
    }
}
/**
 * 
 * @export
 * @interface DataExtractsEvent
 */
export interface DataExtractsEvent {
    /**
     * 
     * @type {DataExtractsEventData}
     * @memberof DataExtractsEvent
     */
    data?: DataExtractsEventData;
    /**
     * 
     * @type {string}
     * @memberof DataExtractsEvent
     */
    info?: string;
}
/**
 * 
 * @export
 * @interface DataExtractsEventData
 */
export interface DataExtractsEventData {
    /**
     * 
     * @type {string}
     * @memberof DataExtractsEventData
     */
    fromDate?: string;
    /**
     * 
     * @type {Array<DataExtractsEventUserData>}
     * @memberof DataExtractsEventData
     */
    userData?: Array<DataExtractsEventUserData>;
    /**
     * 
     * @type {number}
     * @memberof DataExtractsEventData
     */
    userCount?: number;
    /**
     * 
     * @type {string}
     * @memberof DataExtractsEventData
     */
    toDate?: string;
}
/**
 * 
 * @export
 * @interface DataExtractsEventLinks
 */
export interface DataExtractsEventLinks {
    /**
     * 
     * @type {string}
     * @memberof DataExtractsEventLinks
     */
    methodType?: string;
    /**
     * 
     * @type {string}
     * @memberof DataExtractsEventLinks
     */
    rel?: string;
    /**
     * 
     * @type {string}
     * @memberof DataExtractsEventLinks
     */
    href?: string;
}
/**
 * 
 * @export
 * @interface DataExtractsEventResponse
 */
export interface DataExtractsEventResponse {
    /**
     * 
     * @type {DataExtractsEvent}
     * @memberof DataExtractsEventResponse
     */
    event?: DataExtractsEvent;
}
/**
 * 
 * @export
 * @interface DataExtractsEventUserData
 */
export interface DataExtractsEventUserData {
    /**
     * 
     * @type {Array<DataExtractsEventLinks>}
     * @memberof DataExtractsEventUserData
     */
    links?: Array<DataExtractsEventLinks>;
    /**
     * 
     * @type {DataExtractsUser}
     * @memberof DataExtractsEventUserData
     */
    user?: DataExtractsUser;
}
/**
 * 
 * @export
 * @interface DataExtractsHolding
 */
export interface DataExtractsHolding {
    /**
     * The symbol of the security.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof DataExtractsHolding
     */
    symbol?: string;
    /**
     * The quantity of the employee stock options that are already exercised or bought by the employee.<br><b>Note</b>: Once the employee stock options is exercised, they are either converted to cash value or equity positions depending on the FI. The exercised quantity field is only applicable to employee stock options.<br><br><b>Applicable containers</b>: investment<br>
     * @type {number}
     * @memberof DataExtractsHolding
     */
    exercisedQuantity?: number;
    /**
     * The CUSIP (Committee on Uniform Securities Identification Procedures) identifies most the financial instruments in the United States and Canada.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof DataExtractsHolding
     */
    cusipNumber?: string;
    /**
     * The quantity of units or shares that are already vested on a vest date.<br><b>Note</b>: The vested quantity field is only applicable to employee stock options, restricted stock units/awards, performance units, etc.<br><br><b>Applicable containers</b>: investment<br>
     * @type {number}
     * @memberof DataExtractsHolding
     */
    vestedQuantity?: number;
    /**
     * The description (name) for the holding (E.g., Cisco Systems)<br>For insurance container, the field is only applicable for insurance annuity and variable life insurance types. <br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof DataExtractsHolding
     */
    description?: string;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsHolding
     */
    unvestedValue?: Money;
    /**
     * Indicates the security style of holding identified through the security service.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof DataExtractsHolding
     */
    securityStyle?: string;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsHolding
     */
    vestedValue?: Money;
    /**
     * The type of the option position (i.e., put or call).<br><b>Note</b>: The option type field is only applicable to options.<br><br><b>Applicable containers</b>: investment<br><b>Applicable Values</b><br>
     * @type {string}
     * @memberof DataExtractsHolding
     */
    optionType?: DataExtractsHolding.OptionTypeEnum;
    /**
     * The date when the information was last updated in the system.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof DataExtractsHolding
     */
    lastUpdated?: string;
    /**
     * The providerAccountIds that share the account with the primary providerAccountId that was created when the user had added the account for the first time.<br><b>Additional Details</b>: This attribute is returned in the response only if the account deduplication feature is enabled and the same account is mapped to more than one provider account IDs indicating the account is owned by more than one user, for example, joint accounts.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: All Containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {Array<number>}
     * @memberof DataExtractsHolding
     */
    associatedProviderAccountId?: Array<number>;
    /**
     * Indicates the security match status id of the investment option identified during security normalization.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof DataExtractsHolding
     */
    matchStatus?: string;
    /**
     * Type of holding<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof DataExtractsHolding
     */
    holdingType?: DataExtractsHolding.HoldingTypeEnum;
    /**
     * The stated maturity date of a bond or CD.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof DataExtractsHolding
     */
    maturityDate?: string;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsHolding
     */
    price?: Money;
    /**
     * The fixed duration for which the bond or CD is issued.<br><b>Note</b>: The term field is only applicable to CD.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof DataExtractsHolding
     */
    term?: string;
    /**
     * The quantity of tradeable units in a contract.<br><b>Note</b>: The contract quantity field is only applicable to commodity and currency.<br><br><b>Applicable containers</b>: investment<br>
     * @type {number}
     * @memberof DataExtractsHolding
     */
    contractQuantity?: number;
    /**
     * Unique identifier for the security added in the system. This is the primary key of the holding resource.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {number}
     * @memberof DataExtractsHolding
     */
    id?: number;
    /**
     * Indicates that the holding is a short trading.<br><br><b>Applicable containers</b>: investment<br>
     * @type {boolean}
     * @memberof DataExtractsHolding
     */
    isShort?: boolean;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsHolding
     */
    value?: Money;
    /**
     * The date on which an option, right or warrant expires.<br><b>Note</b>: The expiration date field is only applicable to options and employee stock options.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof DataExtractsHolding
     */
    expirationDate?: string;
    /**
     * The interest rate on a CD.<br><b>Note</b>: The interest rate field is only applicable to CD.<br><br><b>Applicable containers</b>: investment<br>
     * @type {number}
     * @memberof DataExtractsHolding
     */
    interestRate?: number;
    /**
     * The quantity held for the holding.<br><b>Note</b>: Only for bonds the quantity field indicates the normalized quantity and not the quantity aggregated from the site. The quantity field is only applicable to restricted stock units/awards, performance units, currency, and commodity.<br>For insurance container, the field is only applicable for insurance annuity and variable life insurance types.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {number}
     * @memberof DataExtractsHolding
     */
    quantity?: number;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsHolding
     */
    accruedInterest?: Money;
    /**
     * The date on which equity awards like ESOP, RSU, etc., are issued or granted.<br><b>Note</b>: The grant date field is only applicable to employee stock options, restricted stock units/awards, performance units, etc.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof DataExtractsHolding
     */
    grantDate?: string;
    /**
     * The SEDOL (Stock Exchange Daily Official List) is a set of security identifiers used in the United Kingdom and Ireland for clearing purposes.<br><b>Note</b>: The SEDOL field is only applicable to the trade related transactions<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof DataExtractsHolding
     */
    sedol?: string;
    /**
     * The number of vested shares that can be exercised by the employee. It is usually equal to the vested quantity.<br><b>Note</b>: The vested shares exercisable field is only applicable to employee stock options, restricted stock units/awards, performance units, etc.<br><br><b>Applicable containers</b>: investment<br>
     * @type {number}
     * @memberof DataExtractsHolding
     */
    vestedSharesExercisable?: number;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsHolding
     */
    spread?: Money;
    /**
     * Unique identifier of the account to which the security is linked.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {number}
     * @memberof DataExtractsHolding
     */
    accountId?: number;
    /**
     * The enrichedDescription is the security description of the normalized holding<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof DataExtractsHolding
     */
    enrichedDescription?: string;
    /**
     * The stated interest rate for a bond.<br><br><b>Applicable containers</b>: investment<br>
     * @type {number}
     * @memberof DataExtractsHolding
     */
    couponRate?: number;
    /**
     * The date on which the holding is created in the Yodlee system.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof DataExtractsHolding
     */
    createdDate?: string;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsHolding
     */
    accruedIncome?: Money;
    /**
     * Indicates the security type of holding identified through the security service.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof DataExtractsHolding
     */
    securityType?: string;
    /**
     * Unique identifier for the user's association with the provider.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {number}
     * @memberof DataExtractsHolding
     */
    providerAccountId?: number;
    /**
     * Indicates the number of unvested quantity or units.<br><b>Note</b>: The unvested quantity field is only applicable to employee stock options, restricted stock units/awards, performance units, etc.<br><br><b>Applicable containers</b>: investment<br>
     * @type {number}
     * @memberof DataExtractsHolding
     */
    unvestedQuantity?: number;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsHolding
     */
    costBasis?: Money;
    /**
     * The date on which a RSU, RSA, or an employee stock options become vested.<br><b>Note</b>: The vesting date field is only applicable to employee stock options, restricted stock units/awards, performance units, etc.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof DataExtractsHolding
     */
    vestingDate?: string;
    /**
     * The ISIN (International Securities Identification Number) is used worldwide to identify specific securities. It is equivalent to CUSIP for international markets.<br><br><b>Note</b>: The ISIN field is only applicable to the trade related transactions<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof DataExtractsHolding
     */
    isin?: string;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsHolding
     */
    strikePrice?: Money;
}

/**
 * @export
 * @namespace DataExtractsHolding
 */
export namespace DataExtractsHolding {
    /**
     * @export
     * @enum {string}
     */
    export enum OptionTypeEnum {
        Put = <any> 'put',
        Call = <any> 'call',
        Unknown = <any> 'unknown',
        Other = <any> 'other'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum HoldingTypeEnum {
        Stock = <any> 'stock',
        MutualFund = <any> 'mutualFund',
        Bond = <any> 'bond',
        CD = <any> 'CD',
        Option = <any> 'option',
        MoneyMarketFund = <any> 'moneyMarketFund',
        Other = <any> 'other',
        Remic = <any> 'remic',
        Future = <any> 'future',
        Commodity = <any> 'commodity',
        Currency = <any> 'currency',
        UnitInvestmentTrust = <any> 'unitInvestmentTrust',
        EmployeeStockOption = <any> 'employeeStockOption',
        InsuranceAnnuity = <any> 'insuranceAnnuity',
        Unknown = <any> 'unknown',
        PreferredStock = <any> 'preferredStock',
        ETF = <any> 'ETF',
        Warrants = <any> 'warrants',
        DigitalAsset = <any> 'digitalAsset'
    }
}
/**
 * 
 * @export
 * @interface DataExtractsProviderAccount
 */
export interface DataExtractsProviderAccount {
    /**
     * The providerAccountId that is retained as part of the many-to-one OAuth migration process.<br><b>Endpoints</b>:<ul><li>GET dataExtracts/userData</li></ul>
     * @type {number}
     * @memberof DataExtractsProviderAccount
     */
    destinationProviderAccountId?: number;
    /**
     * Indicates the migration status of the provider account from screen-scraping provider to the Open Banking provider. <br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>GET providerAccounts/{providerAccountId}</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsProviderAccount
     */
    oauthMigrationStatus?: DataExtractsProviderAccount.OauthMigrationStatusEnum;
    /**
     * Indicates whether account is a manual or aggregated provider account.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {boolean}
     * @memberof DataExtractsProviderAccount
     */
    isManual?: boolean;
    /**
     * Attribute to specify whether the user has to input(credentials/MFA) for refreshing an account.<br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>GET GET providerAccounts/{providerAccountId}</li></ul>
     * @type {boolean}
     * @memberof DataExtractsProviderAccount
     */
    isRealTimeMFA?: boolean;
    /**
     * Indicate when the providerAccount is last updated successfully.<br><br><b>Account Type</b>: Aggregated<br><b>Endpoints</b>:<ul><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof DataExtractsProviderAccount
     */
    lastUpdated?: string;
    /**
     * Consent Id generated through POST Consent.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li></ul>
     * @type {number}
     * @memberof DataExtractsProviderAccount
     */
    consentId?: number;
    /**
     * The date on when the provider account is created in the system.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li></ul>
     * @type {string}
     * @memberof DataExtractsProviderAccount
     */
    createdDate?: string;
    /**
     * The source through which the providerAccount is added in the system.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li><li>GET dataExtracts/userData</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof DataExtractsProviderAccount
     */
    aggregationSource?: DataExtractsProviderAccount.AggregationSourceEnum;
    /**
     * Indicates if the provider account is deleted from the system.<b>Applicable containers</b>: All Containers<br><b>Aggregated / Manual</b>: Both <br><b>Endpoints</b>:<br><ul><li>GET dataExtracts/userData</li></ul>
     * @type {boolean}
     * @memberof DataExtractsProviderAccount
     */
    isDeleted?: boolean;
    /**
     * Unique identifier for the provider resource. This denotes the provider for which the provider account id is generated by the user.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {number}
     * @memberof DataExtractsProviderAccount
     */
    providerId?: number;
    /**
     * Unique id generated to indicate the request.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li></ul>
     * @type {string}
     * @memberof DataExtractsProviderAccount
     */
    requestId?: string;
    /**
     * The providerAccountIds that are deleted and merged into the destinationProviderAccountId as part of the many-to-one OAuth migration process.<br><b>Endpoints</b>:<ul><li>GET dataExtracts/userData</li></ul>
     * @type {Array<number>}
     * @memberof DataExtractsProviderAccount
     */
    sourceProviderAccountIds?: Array<number>;
    /**
     * Unique identifier for the provider account resource. This is created during account addition.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {number}
     * @memberof DataExtractsProviderAccount
     */
    id?: number;
    /**
     * Logical grouping of dataset attributes into datasets such as Basic Aggregation Data, Account Profile and Documents.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {Array<AccountDataset>}
     * @memberof DataExtractsProviderAccount
     */
    dataset?: Array<AccountDataset>;
    /**
     * The status of last update attempted for the account. <br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li><li>GET dataExtracts/userData</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof DataExtractsProviderAccount
     */
    status?: DataExtractsProviderAccount.StatusEnum;
}

/**
 * @export
 * @namespace DataExtractsProviderAccount
 */
export namespace DataExtractsProviderAccount {
    /**
     * @export
     * @enum {string}
     */
    export enum OauthMigrationStatusEnum {
        INPROGRESS = <any> 'IN_PROGRESS',
        TOBEMIGRATED = <any> 'TO_BE_MIGRATED',
        COMPLETED = <any> 'COMPLETED',
        MIGRATED = <any> 'MIGRATED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum AggregationSourceEnum {
        SYSTEM = <any> 'SYSTEM',
        USER = <any> 'USER'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        LOGININPROGRESS = <any> 'LOGIN_IN_PROGRESS',
        USERINPUTREQUIRED = <any> 'USER_INPUT_REQUIRED',
        INPROGRESS = <any> 'IN_PROGRESS',
        PARTIALSUCCESS = <any> 'PARTIAL_SUCCESS',
        SUCCESS = <any> 'SUCCESS',
        FAILED = <any> 'FAILED',
        MIGRATIONINPROGRESS = <any> 'MIGRATION_IN_PROGRESS'
    }
}
/**
 * 
 * @export
 * @interface DataExtractsTransaction
 */
export interface DataExtractsTransaction {
    /**
     * The value provided will be either postDate or transactionDate. postDate takes higher priority than transactionDate, except for the investment container as only transactionDate is available. The availability of postDate or transactionDate depends on the provider site.<br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br>
     * @type {string}
     * @memberof DataExtractsTransaction
     */
    date?: string;
    /**
     * A unique ID that the provider site has assigned to the transaction. The source ID is only available for the pre-populated accounts.<br>Pre-populated accounts are the accounts that the FI customers shares with Yodlee, so that the user does not have to add or aggregate those accounts.
     * @type {string}
     * @memberof DataExtractsTransaction
     */
    sourceId?: string;
    /**
     * The symbol of the security being traded.<br><b>Note</b>: The settle date field applies only to trade-related transactions. <br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof DataExtractsTransaction
     */
    symbol?: string;
    /**
     * The CUSIP (Committee on Uniform Securities Identification Procedures) identifies the financial instruments in the United States and Canada.<br><b><br><b>Note</b></b>: The CUSIP number field applies only to trade related transactions.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof DataExtractsTransaction
     */
    cusipNumber?: string;
    /**
     * The high level category assigned to the transaction. The supported values are provided by the GET transactions/categories. <br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br>
     * @type {number}
     * @memberof DataExtractsTransaction
     */
    highLevelCategoryId?: number;
    /**
     * The id of the detail category that is assigned to the transaction. The supported values are provided by GET transactions/categories.<br><br><b>Applicable containers</b>: bank,creditCard<br>
     * @type {number}
     * @memberof DataExtractsTransaction
     */
    detailCategoryId?: number;
    /**
     * 
     * @type {Description}
     * @memberof DataExtractsTransaction
     */
    description?: Description;
    /**
     * Additional notes provided by the user for a particular  transaction through application or API services. <br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br>
     * @type {string}
     * @memberof DataExtractsTransaction
     */
    memo?: string;
    /**
     * It is the date on which the transaction is finalized, that is, the date the ownership of the security is transferred to the buyer. The settlement date is usually few days after the transaction date.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof DataExtractsTransaction
     */
    settleDate?: string;
    /**
     * The nature of the transaction, i.e., deposit, refund, payment, etc.<br><b>Note</b>: The transaction type field is available only for the United States, Canada, United Kingdom, and India based provider sites. <br><br><b>Applicable containers</b>: bank,creditCard,investment<br>
     * @type {string}
     * @memberof DataExtractsTransaction
     */
    type?: string;
    /**
     * The intermediary of the transaction.<br><br><b>Applicable containers</b>:  bank,creditCard,investment,loan<br>
     * @type {Array<string>}
     * @memberof DataExtractsTransaction
     */
    intermediary?: Array<string>;
    /**
     * Indicates if the transaction appears as a debit or a credit transaction in the account. <br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br><b>Applicable Values</b><br>
     * @type {string}
     * @memberof DataExtractsTransaction
     */
    baseType?: DataExtractsTransaction.BaseTypeEnum;
    /**
     * Indicates the source of the category, i.e., categories derived by the system or assigned/provided by the consumer. This is the source field of the transaction category resource. The supported values are provided by the GET transactions/categories.<br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br><b>Applicable Values</b><br>
     * @type {string}
     * @memberof DataExtractsTransaction
     */
    categorySource?: DataExtractsTransaction.CategorySourceEnum;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsTransaction
     */
    principal?: Money;
    /**
     * 
     * @type {string}
     * @memberof DataExtractsTransaction
     */
    lastUpdated?: string;
    /**
     * Indicates if the transaction is marked as deleted.<b>Applicable containers</b>: All Containers<br><b>Aggregated / Manual</b>: Both <br><b>Endpoints</b>:<br><ul><li>GET dataExtracts/userData</li></ul>
     * @type {boolean}
     * @memberof DataExtractsTransaction
     */
    isDeleted?: boolean;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsTransaction
     */
    interest?: Money;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsTransaction
     */
    price?: Money;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsTransaction
     */
    commission?: Money;
    /**
     * An unique identifier for the transaction. The combination of the id and account container are unique in the system. <br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br>
     * @type {number}
     * @memberof DataExtractsTransaction
     */
    id?: number;
    /**
     * Indicates the merchantType of the transaction.e.g:-BILLERS,SUBSCRIPTION,OTHERS <br><br><b>Applicable containers</b>: bank,creditCard,investment,loan<br>
     * @type {string}
     * @memberof DataExtractsTransaction
     */
    merchantType?: string;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsTransaction
     */
    amount?: Money;
    /**
     * The checkNumber of the transaction.<br><br><b>Applicable containers</b>: bank<br>
     * @type {string}
     * @memberof DataExtractsTransaction
     */
    checkNumber?: string;
    /**
     * Indicates if the transaction is happened online or in-store. <br><br><b>Applicable containers</b>: bank,creditCard,investment,loan<br>
     * @type {boolean}
     * @memberof DataExtractsTransaction
     */
    isPhysical?: boolean;
    /**
     * The quantity associated with the transaction.<br><b>Note</b>: The quantity field applies only to trade-related transactions.<br><br><b>Applicable containers</b>: investment<br>
     * @type {number}
     * @memberof DataExtractsTransaction
     */
    quantity?: number;
    /**
     * It is an identification number that is assigned to financial instruments such as stocks and bonds trading in Switzerland.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof DataExtractsTransaction
     */
    valoren?: string;
    /**
     * Indicates if the transaction is aggregated from the FI site or the consumer has manually created the transaction using the application or an API. <br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br>
     * @type {boolean}
     * @memberof DataExtractsTransaction
     */
    isManual?: boolean;
    /**
     * 
     * @type {Merchant}
     * @memberof DataExtractsTransaction
     */
    merchant?: Merchant;
    /**
     * SEDOL stands for Stock Exchange Daily Official List, a list of security identifiers used in the United Kingdom and Ireland for clearing purposes.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof DataExtractsTransaction
     */
    sedol?: string;
    /**
     * The date the transaction happens in the account. <br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br>
     * @type {string}
     * @memberof DataExtractsTransaction
     */
    transactionDate?: string;
    /**
     * The categoryType of the category assigned to the transaction. This is the type field of the transaction category resource. The supported values are provided by the GET transactions/categories.<br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br>
     * @type {string}
     * @memberof DataExtractsTransaction
     */
    categoryType?: DataExtractsTransaction.CategoryTypeEnum;
    /**
     * The account from which the transaction was made. This is basically the primary key of the account resource. <br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br>
     * @type {number}
     * @memberof DataExtractsTransaction
     */
    accountId?: number;
    /**
     * 
     * @type {string}
     * @memberof DataExtractsTransaction
     */
    createdDate?: string;
    /**
     * The source through which the transaction is added to the Yodlee system.<br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loann<br><b>Applicable Values:</b><br>
     * @type {string}
     * @memberof DataExtractsTransaction
     */
    sourceType?: DataExtractsTransaction.SourceTypeEnum;
    /**
     * The account's container.<br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br><b>Applicable Values</b><br>
     * @type {string}
     * @memberof DataExtractsTransaction
     */
    CONTAINER?: DataExtractsTransaction.CONTAINEREnum;
    /**
     * The date on which the transaction is posted to the account.<br><br><b>Applicable containers</b>: bank,creditCard,insurance,loan<br>
     * @type {string}
     * @memberof DataExtractsTransaction
     */
    postDate?: string;
    /**
     * The parentCategoryId of the category assigned to the transaction.<br><b>Note</b>: This field will be provided in the response if the transaction is assigned to a user-created category. <br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br>
     * @type {number}
     * @memberof DataExtractsTransaction
     */
    parentCategoryId?: number;
    /**
     * The transaction subtype field provides a detailed transaction type. For example, purchase is a transaction type and the transaction subtype field indicates if the purchase was made using a debit or credit card.<br><b>Note</b>: The transaction subtype field is available only in the United States, Canada, United Kingdom, and India.<br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br>
     * @type {string}
     * @memberof DataExtractsTransaction
     */
    subType?: DataExtractsTransaction.SubTypeEnum;
    /**
     * The name of the category assigned to the transaction. This is the category field of the transaction category resource. The supported values are provided by the GET transactions/categories.<br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br>
     * @type {string}
     * @memberof DataExtractsTransaction
     */
    category?: string;
    /**
     * 
     * @type {Money}
     * @memberof DataExtractsTransaction
     */
    runningBalance?: Money;
    /**
     * The id of the category assigned to the transaction. This is the id field of the transaction category resource. The supported values are provided by the GET transactions/categories.<br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br>
     * @type {number}
     * @memberof DataExtractsTransaction
     */
    categoryId?: number;
    /**
     * For transactions involving securities, this captures the securities description.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof DataExtractsTransaction
     */
    holdingDescription?: string;
    /**
     * International Securities Identification Number (ISIN) standard is used worldwide to identify specific securities.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof DataExtractsTransaction
     */
    isin?: string;
    /**
     * The status of the transaction: pending or posted.<br><b>Note</b>: Most FI sites only display posted transactions. If the FI site displays transaction status, same will be aggregated.  <br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br><b>Applicable Values</b><br>
     * @type {string}
     * @memberof DataExtractsTransaction
     */
    status?: DataExtractsTransaction.StatusEnum;
}

/**
 * @export
 * @namespace DataExtractsTransaction
 */
export namespace DataExtractsTransaction {
    /**
     * @export
     * @enum {string}
     */
    export enum BaseTypeEnum {
        CREDIT = <any> 'CREDIT',
        DEBIT = <any> 'DEBIT'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum CategorySourceEnum {
        SYSTEM = <any> 'SYSTEM',
        USER = <any> 'USER'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum CategoryTypeEnum {
        TRANSFER = <any> 'TRANSFER',
        DEFERREDCOMPENSATION = <any> 'DEFERRED_COMPENSATION',
        UNCATEGORIZE = <any> 'UNCATEGORIZE',
        INCOME = <any> 'INCOME',
        EXPENSE = <any> 'EXPENSE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SourceTypeEnum {
        AGGREGATED = <any> 'AGGREGATED',
        MANUAL = <any> 'MANUAL'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum CONTAINEREnum {
        Bank = <any> 'bank',
        CreditCard = <any> 'creditCard',
        Investment = <any> 'investment',
        Insurance = <any> 'insurance',
        Loan = <any> 'loan',
        Reward = <any> 'reward',
        Bill = <any> 'bill',
        RealEstate = <any> 'realEstate',
        OtherAssets = <any> 'otherAssets',
        OtherLiabilities = <any> 'otherLiabilities'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SubTypeEnum {
        OVERDRAFTCHARGE = <any> 'OVERDRAFT_CHARGE',
        ONLINEPURCHASE = <any> 'ONLINE_PURCHASE',
        TAXPAYMENT = <any> 'TAX_PAYMENT',
        PAYMENTBYCHECK = <any> 'PAYMENT_BY_CHECK',
        ATMCASHWITHDRAWAL = <any> 'ATM_CASH_WITHDRAWAL',
        SERVICECHARGE = <any> 'SERVICE_CHARGE',
        RETURNEDCHECKCHARGE = <any> 'RETURNED_CHECK_CHARGE',
        STOPPAYMENTCHARGE = <any> 'STOP_PAYMENT_CHARGE',
        CONVENIENCEFEE = <any> 'CONVENIENCE_FEE',
        AUTOLOAN = <any> 'AUTO_LOAN',
        HOMELOANMORTGAGE = <any> 'HOME_LOAN_MORTGAGE',
        RECURRINGSUBSCRIPTIONPAYMENT = <any> 'RECURRING_SUBSCRIPTION_PAYMENT',
        INTEREST = <any> 'INTEREST',
        PAYMENT = <any> 'PAYMENT',
        PURCHASE = <any> 'PURCHASE',
        REFUND = <any> 'REFUND',
        TRANSFER = <any> 'TRANSFER',
        FINANCECHARGE = <any> 'FINANCE_CHARGE',
        OTHERCHARGESFEES = <any> 'OTHER_CHARGES_FEES',
        ANNUALFEE = <any> 'ANNUAL_FEE',
        DEPOSIT = <any> 'DEPOSIT',
        DIRECTDEPOSITSALARY = <any> 'DIRECT_DEPOSIT_SALARY',
        INVESTMENTINCOMECASH = <any> 'INVESTMENT_INCOME_CASH',
        SSA = <any> 'SSA',
        REWARDS = <any> 'REWARDS',
        TAXREFUND = <any> 'TAX_REFUND',
        CREDITCARDPAYMENT = <any> 'CREDIT_CARD_PAYMENT',
        INSURANCEPAYMENT = <any> 'INSURANCE_PAYMENT',
        UTILITIESPAYMENT = <any> 'UTILITIES_PAYMENT',
        CHILDSUPPORT = <any> 'CHILD_SUPPORT',
        LOAN = <any> 'LOAN',
        PERSONALLOAN = <any> 'PERSONAL_LOAN',
        STUDENTLOAN = <any> 'STUDENT_LOAN',
        REIMBURSEMENT = <any> 'REIMBURSEMENT',
        BALANCETRANSFER = <any> 'BALANCE_TRANSFER',
        OVERDRAFTPROTECTION = <any> 'OVERDRAFT_PROTECTION',
        CREDIT = <any> 'CREDIT',
        NSFFEES = <any> 'NSF_FEES'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        POSTED = <any> 'POSTED',
        PENDING = <any> 'PENDING',
        SCHEDULED = <any> 'SCHEDULED',
        FAILED = <any> 'FAILED',
        CLEARED = <any> 'CLEARED'
    }
}
/**
 * 
 * @export
 * @interface DataExtractsUser
 */
export interface DataExtractsUser {
    /**
     * 
     * @type {string}
     * @memberof DataExtractsUser
     */
    loginName?: string;
}
/**
 * 
 * @export
 * @interface DataExtractsUserData
 */
export interface DataExtractsUserData {
    /**
     * 
     * @type {Array<DataExtractsHolding>}
     * @memberof DataExtractsUserData
     */
    holding?: Array<DataExtractsHolding>;
    /**
     * 
     * @type {number}
     * @memberof DataExtractsUserData
     */
    totalTransactionsCount?: number;
    /**
     * 
     * @type {DataExtractsUser}
     * @memberof DataExtractsUserData
     */
    user?: DataExtractsUser;
    /**
     * 
     * @type {Array<DataExtractsAccount>}
     * @memberof DataExtractsUserData
     */
    account?: Array<DataExtractsAccount>;
    /**
     * 
     * @type {Array<DataExtractsTransaction>}
     * @memberof DataExtractsUserData
     */
    transaction?: Array<DataExtractsTransaction>;
    /**
     * 
     * @type {Array<DataExtractsProviderAccount>}
     * @memberof DataExtractsUserData
     */
    providerAccount?: Array<DataExtractsProviderAccount>;
}
/**
 * 
 * @export
 * @interface DataExtractsUserDataResponse
 */
export interface DataExtractsUserDataResponse {
    /**
     * 
     * @type {Array<DataExtractsUserData>}
     * @memberof DataExtractsUserDataResponse
     */
    userData?: Array<DataExtractsUserData>;
}
/**
 * 
 * @export
 * @interface DerivedCategorySummary
 */
export interface DerivedCategorySummary {
    /**
     * 
     * @type {Money}
     * @memberof DerivedCategorySummary
     */
    creditTotal?: Money;
    /**
     * Credit and debit summary per date.<br><br><b>Applicable containers</b>: creditCard, bank, investment<br>
     * @type {Array<DerivedCategorySummaryDetails>}
     * @memberof DerivedCategorySummary
     */
    details?: Array<DerivedCategorySummaryDetails>;
    /**
     * 
     * @type {DerivedTransactionsLinks}
     * @memberof DerivedCategorySummary
     */
    links?: DerivedTransactionsLinks;
    /**
     * The name of the category.<br><br><b>Applicable containers</b>: creditCard, bank, investment<br>
     * @type {string}
     * @memberof DerivedCategorySummary
     */
    categoryName?: string;
    /**
     * Id of the category. This information is provided by transactions/categories service.<br><br><b>Applicable containers</b>: creditCard, bank, investment<br>
     * @type {number}
     * @memberof DerivedCategorySummary
     */
    categoryId?: number;
    /**
     * 
     * @type {Money}
     * @memberof DerivedCategorySummary
     */
    debitTotal?: Money;
}
/**
 * 
 * @export
 * @interface DerivedCategorySummaryDetails
 */
export interface DerivedCategorySummaryDetails {
    /**
     * Date on which the credit and debit transactions had occured.<br><br><b>Applicable containers</b>: creditCard, bank, investment<br>
     * @type {string}
     * @memberof DerivedCategorySummaryDetails
     */
    date?: string;
    /**
     * 
     * @type {Money}
     * @memberof DerivedCategorySummaryDetails
     */
    creditTotal?: Money;
    /**
     * 
     * @type {Money}
     * @memberof DerivedCategorySummaryDetails
     */
    debitTotal?: Money;
}
/**
 * 
 * @export
 * @interface DerivedHolding
 */
export interface DerivedHolding {
    /**
     * The symbol of the security.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof DerivedHolding
     */
    symbol?: string;
    /**
     * The quantity of the employee stock options that are already exercised or bought by the employee.<br><b>Note</b>: Once the employee stock options is exercised, they are either converted to cash value or equity positions depending on the FI. The exercised quantity field is only applicable to employee stock options.<br><br><b>Applicable containers</b>: investment<br>
     * @type {number}
     * @memberof DerivedHolding
     */
    exercisedQuantity?: number;
    /**
     * The CUSIP (Committee on Uniform Securities Identification Procedures) identifies most the financial instruments in the United States and Canada.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof DerivedHolding
     */
    cusipNumber?: string;
    /**
     * 
     * @type {AssetClassification}
     * @memberof DerivedHolding
     */
    assetClassification?: AssetClassification;
    /**
     * The quantity of units or shares that are already vested on a vest date.<br><b>Note</b>: The vested quantity field is only applicable to employee stock options, restricted stock units/awards, performance units, etc.<br><br><b>Applicable containers</b>: investment<br>
     * @type {number}
     * @memberof DerivedHolding
     */
    vestedQuantity?: number;
    /**
     * The description (name) for the holding (E.g., Cisco Systems)<br>For insurance container, the field is only applicable for insurance annuity and variable life insurance types. <br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof DerivedHolding
     */
    description?: string;
    /**
     * 
     * @type {Money}
     * @memberof DerivedHolding
     */
    unvestedValue?: Money;
    /**
     * Indicates the security style of holding identified through the security service.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof DerivedHolding
     */
    securityStyle?: string;
    /**
     * 
     * @type {Money}
     * @memberof DerivedHolding
     */
    vestedValue?: Money;
    /**
     * The type of the option position (i.e., put or call).<br><b>Note</b>: The option type field is only applicable to options.<br><br><b>Applicable containers</b>: investment<br><b>Applicable Values</b><br>
     * @type {string}
     * @memberof DerivedHolding
     */
    optionType?: DerivedHolding.OptionTypeEnum;
    /**
     * The date when the information was last updated in the system.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof DerivedHolding
     */
    lastUpdated?: string;
    /**
     * The providerAccountIds that share the account with the primary providerAccountId that was created when the user had added the account for the first time.<br><b>Additional Details</b>: This attribute is returned in the response only if the account deduplication feature is enabled and the same account is mapped to more than one provider account IDs indicating the account is owned by more than one user, for example, joint accounts.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: All Containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {Array<number>}
     * @memberof DerivedHolding
     */
    associatedProviderAccountId?: Array<number>;
    /**
     * Indicates the security match status id of the investment option identified during security normalization.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof DerivedHolding
     */
    matchStatus?: string;
    /**
     * Type of holding<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof DerivedHolding
     */
    holdingType?: DerivedHolding.HoldingTypeEnum;
    /**
     * The stated maturity date of a bond or CD.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof DerivedHolding
     */
    maturityDate?: string;
    /**
     * 
     * @type {Money}
     * @memberof DerivedHolding
     */
    price?: Money;
    /**
     * The fixed duration for which the bond or CD is issued.<br><b>Note</b>: The term field is only applicable to CD.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof DerivedHolding
     */
    term?: string;
    /**
     * The quantity of tradeable units in a contract.<br><b>Note</b>: The contract quantity field is only applicable to commodity and currency.<br><br><b>Applicable containers</b>: investment<br>
     * @type {number}
     * @memberof DerivedHolding
     */
    contractQuantity?: number;
    /**
     * Unique identifier for the security added in the system. This is the primary key of the holding resource.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {number}
     * @memberof DerivedHolding
     */
    id?: number;
    /**
     * Indicates that the holding is a short trading.<br><br><b>Applicable containers</b>: investment<br>
     * @type {boolean}
     * @memberof DerivedHolding
     */
    isShort?: boolean;
    /**
     * 
     * @type {Money}
     * @memberof DerivedHolding
     */
    value?: Money;
    /**
     * The date on which an option, right or warrant expires.<br><b>Note</b>: The expiration date field is only applicable to options and employee stock options.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof DerivedHolding
     */
    expirationDate?: string;
    /**
     * The interest rate on a CD.<br><b>Note</b>: The interest rate field is only applicable to CD.<br><br><b>Applicable containers</b>: investment<br>
     * @type {number}
     * @memberof DerivedHolding
     */
    interestRate?: number;
    /**
     * The quantity held for the holding.<br><b>Note</b>: Only for bonds the quantity field indicates the normalized quantity and not the quantity aggregated from the site. The quantity field is only applicable to restricted stock units/awards, performance units, currency, and commodity.<br>For insurance container, the field is only applicable for insurance annuity and variable life insurance types.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {number}
     * @memberof DerivedHolding
     */
    quantity?: number;
    /**
     * 
     * @type {Money}
     * @memberof DerivedHolding
     */
    accruedInterest?: Money;
    /**
     * The date on which equity awards like ESOP, RSU, etc., are issued or granted.<br><b>Note</b>: The grant date field is only applicable to employee stock options, restricted stock units/awards, performance units, etc.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof DerivedHolding
     */
    grantDate?: string;
    /**
     * The SEDOL (Stock Exchange Daily Official List) is a set of security identifiers used in the United Kingdom and Ireland for clearing purposes.<br><b>Note</b>: The SEDOL field is only applicable to the trade related transactions<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof DerivedHolding
     */
    sedol?: string;
    /**
     * The number of vested shares that can be exercised by the employee. It is usually equal to the vested quantity.<br><b>Note</b>: The vested shares exercisable field is only applicable to employee stock options, restricted stock units/awards, performance units, etc.<br><br><b>Applicable containers</b>: investment<br>
     * @type {number}
     * @memberof DerivedHolding
     */
    vestedSharesExercisable?: number;
    /**
     * 
     * @type {Money}
     * @memberof DerivedHolding
     */
    spread?: Money;
    /**
     * Unique identifier of the account to which the security is linked.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {number}
     * @memberof DerivedHolding
     */
    accountId?: number;
    /**
     * The enrichedDescription is the security description of the normalized holding<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof DerivedHolding
     */
    enrichedDescription?: string;
    /**
     * The stated interest rate for a bond.<br><br><b>Applicable containers</b>: investment<br>
     * @type {number}
     * @memberof DerivedHolding
     */
    couponRate?: number;
    /**
     * The date on which the holding is created in the Yodlee system.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof DerivedHolding
     */
    createdDate?: string;
    /**
     * 
     * @type {Money}
     * @memberof DerivedHolding
     */
    accruedIncome?: Money;
    /**
     * Indicates the security type of holding identified through the security service.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof DerivedHolding
     */
    securityType?: string;
    /**
     * Unique identifier for the user's association with the provider.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {number}
     * @memberof DerivedHolding
     */
    providerAccountId?: number;
    /**
     * Indicates the number of unvested quantity or units.<br><b>Note</b>: The unvested quantity field is only applicable to employee stock options, restricted stock units/awards, performance units, etc.<br><br><b>Applicable containers</b>: investment<br>
     * @type {number}
     * @memberof DerivedHolding
     */
    unvestedQuantity?: number;
    /**
     * 
     * @type {Money}
     * @memberof DerivedHolding
     */
    costBasis?: Money;
    /**
     * The date on which a RSU, RSA, or an employee stock options become vested.<br><b>Note</b>: The vesting date field is only applicable to employee stock options, restricted stock units/awards, performance units, etc.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof DerivedHolding
     */
    vestingDate?: string;
    /**
     * The ISIN (International Securities Identification Number) is used worldwide to identify specific securities. It is equivalent to CUSIP for international markets.<br><br><b>Note</b>: The ISIN field is only applicable to the trade related transactions<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof DerivedHolding
     */
    isin?: string;
    /**
     * 
     * @type {Money}
     * @memberof DerivedHolding
     */
    strikePrice?: Money;
}

/**
 * @export
 * @namespace DerivedHolding
 */
export namespace DerivedHolding {
    /**
     * @export
     * @enum {string}
     */
    export enum OptionTypeEnum {
        Put = <any> 'put',
        Call = <any> 'call',
        Unknown = <any> 'unknown',
        Other = <any> 'other'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum HoldingTypeEnum {
        Stock = <any> 'stock',
        MutualFund = <any> 'mutualFund',
        Bond = <any> 'bond',
        CD = <any> 'CD',
        Option = <any> 'option',
        MoneyMarketFund = <any> 'moneyMarketFund',
        Other = <any> 'other',
        Remic = <any> 'remic',
        Future = <any> 'future',
        Commodity = <any> 'commodity',
        Currency = <any> 'currency',
        UnitInvestmentTrust = <any> 'unitInvestmentTrust',
        EmployeeStockOption = <any> 'employeeStockOption',
        InsuranceAnnuity = <any> 'insuranceAnnuity',
        Unknown = <any> 'unknown',
        PreferredStock = <any> 'preferredStock',
        ETF = <any> 'ETF',
        Warrants = <any> 'warrants',
        DigitalAsset = <any> 'digitalAsset'
    }
}
/**
 * 
 * @export
 * @interface DerivedHoldingSummaryResponse
 */
export interface DerivedHoldingSummaryResponse {
    /**
     * 
     * @type {Array<DerivedHoldingsSummary>}
     * @memberof DerivedHoldingSummaryResponse
     */
    holdingSummary?: Array<DerivedHoldingsSummary>;
    /**
     * 
     * @type {DerivedHoldingsLinks}
     * @memberof DerivedHoldingSummaryResponse
     */
    link?: DerivedHoldingsLinks;
}
/**
 * 
 * @export
 * @interface DerivedHoldingsAccount
 */
export interface DerivedHoldingsAccount {
    /**
     * The primary key of the account resource and the unique identifier for the account.<br>Required Feature Enablement: Asset classification feature.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {number}
     * @memberof DerivedHoldingsAccount
     */
    id?: number;
    /**
     * 
     * @type {Money}
     * @memberof DerivedHoldingsAccount
     */
    value?: Money;
}
/**
 * 
 * @export
 * @interface DerivedHoldingsLinks
 */
export interface DerivedHoldingsLinks {
    /**
     * 
     * @type {string}
     * @memberof DerivedHoldingsLinks
     */
    holdings?: string;
}
/**
 * 
 * @export
 * @interface DerivedHoldingsSummary
 */
export interface DerivedHoldingsSummary {
    /**
     * Securities that belong to the asset classification type and contributed to the summary value.<br><b>Required Feature Enablement</b>: Asset classification feature.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {Array<DerivedHolding>}
     * @memberof DerivedHoldingsSummary
     */
    holding?: Array<DerivedHolding>;
    /**
     * The classification type of the security. The supported asset classification type and the values are provided in the /holdings/assetClassificationList.<br><b>Required Feature Enablement</b>: Asset classification feature.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof DerivedHoldingsSummary
     */
    classificationType?: string;
    /**
     * The classification value that corresponds to the classification type of the holding. The supported asset classification type and the values are provided in the /holdings/assetClassificationList.<br><b>Required Feature Enablement</b>: Asset classification feature.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof DerivedHoldingsSummary
     */
    classificationValue?: string;
    /**
     * 
     * @type {Money}
     * @memberof DerivedHoldingsSummary
     */
    value?: Money;
    /**
     * Accounts that contribute to the classification. <br><b>Required Feature Enablement</b>: Asset classification feature.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {Array<DerivedHoldingsAccount>}
     * @memberof DerivedHoldingsSummary
     */
    account?: Array<DerivedHoldingsAccount>;
}
/**
 * 
 * @export
 * @interface DerivedNetworth
 */
export interface DerivedNetworth {
    /**
     * The date as of when the networth information is provided.<br><br><b>Applicable containers</b>: bank, creditcard, investment, insurance, realEstate, loan<br>
     * @type {string}
     * @memberof DerivedNetworth
     */
    date?: string;
    /**
     * 
     * @type {Money}
     * @memberof DerivedNetworth
     */
    liability?: Money;
    /**
     * Balances of the accounts over the period of time.<br><br><b>Applicable containers</b>: bank, creditcard, investment, insurance, realEstate, loan<br>
     * @type {Array<DerivedNetworthHistoricalBalance>}
     * @memberof DerivedNetworth
     */
    historicalBalances?: Array<DerivedNetworthHistoricalBalance>;
    /**
     * 
     * @type {Money}
     * @memberof DerivedNetworth
     */
    networth?: Money;
    /**
     * 
     * @type {Money}
     * @memberof DerivedNetworth
     */
    asset?: Money;
}
/**
 * 
 * @export
 * @interface DerivedNetworthHistoricalBalance
 */
export interface DerivedNetworthHistoricalBalance {
    /**
     * Date for which the account balance was provided.  This balance could be a carryforward, calculated or a scraped balance. AdditIonal Details: scraped: Balance shown in the provider site. This balance gets stored in Yodlee system during system/user account updates. carryForward : Balance carried forward from the scraped balance to the days for which the balance was not available in the system. Balance may not be available for all the days in the system due to MFA information required, error in the site, credential changes, etc. calculated: Balances that gets calculated for the days that are prior to the account added date.<br><br><b>Account Type</b>: Aggregated and Manual<br><b>Applicable containers</b>: bank, creditCard, investment, insurance, realEstate, loan<br><b>Endpoints</b>:<ul><li>GET accounts/historicalBalances</li><li>GET derived/networth</li></ul>
     * @type {string}
     * @memberof DerivedNetworthHistoricalBalance
     */
    date?: string;
    /**
     * 
     * @type {number}
     * @memberof DerivedNetworthHistoricalBalance
     */
    accountId?: number;
    /**
     * Indicates whether the balance is an asset or liability.<br><br><b>Account Type</b>: Aggregated and Manual<br><b>Applicable containers</b>: bank, creditCard, investment, insurance, realEstate, loan<br><b>Endpoints</b>:<ul><li>GET accounts/historicalBalances</li></ul>
     * @type {boolean}
     * @memberof DerivedNetworthHistoricalBalance
     */
    isAsset?: boolean;
    /**
     * 
     * @type {Money}
     * @memberof DerivedNetworthHistoricalBalance
     */
    balance?: Money;
    /**
     * Date as of when the balance is last  updated due to the auto account updates or user triggered updates. This balance will be carry forward for the days where there is no balance available in the system. <br><br><b>Account Type</b>: Aggregated and Manual<br><b>Applicable containers</b>: bank, creditCard, investment, insurance, realEstate, loan<br><b>Endpoints</b>:<ul><li>GET accounts/historicalBalances</li></ul>
     * @type {string}
     * @memberof DerivedNetworthHistoricalBalance
     */
    asOfDate?: string;
    /**
     * The source of balance information.<br><br><b>Account Type</b>: Aggregated and Manual<br><b>Applicable containers</b>: bank, creditCard, investment, insurance, realEstate, loan<br><b>Endpoints</b>:<ul><li>GET accounts/historicalBalances</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof DerivedNetworthHistoricalBalance
     */
    dataSourceType?: DerivedNetworthHistoricalBalance.DataSourceTypeEnum;
}

/**
 * @export
 * @namespace DerivedNetworthHistoricalBalance
 */
export namespace DerivedNetworthHistoricalBalance {
    /**
     * @export
     * @enum {string}
     */
    export enum DataSourceTypeEnum {
        S = <any> 'S',
        C = <any> 'C',
        CF = <any> 'CF'
    }
}
/**
 * 
 * @export
 * @interface DerivedNetworthResponse
 */
export interface DerivedNetworthResponse {
    /**
     * 
     * @type {Array<DerivedNetworth>}
     * @memberof DerivedNetworthResponse
     */
    networth?: Array<DerivedNetworth>;
}
/**
 * 
 * @export
 * @interface DerivedTransactionSummaryResponse
 */
export interface DerivedTransactionSummaryResponse {
    /**
     * 
     * @type {DerivedTransactionsLinks}
     * @memberof DerivedTransactionSummaryResponse
     */
    links?: DerivedTransactionsLinks;
    /**
     * 
     * @type {Array<DerivedTransactionsSummary>}
     * @memberof DerivedTransactionSummaryResponse
     */
    transactionSummary?: Array<DerivedTransactionsSummary>;
}
/**
 * 
 * @export
 * @interface DerivedTransactionsLinks
 */
export interface DerivedTransactionsLinks {
    /**
     * Link of the transaction API service that corresponds to the value derivation.<br><br><b>Applicable containers</b>: creditCard, bank, investment<br>
     * @type {string}
     * @memberof DerivedTransactionsLinks
     */
    transactions?: string;
}
/**
 * 
 * @export
 * @interface DerivedTransactionsSummary
 */
export interface DerivedTransactionsSummary {
    /**
     * Type of categories provided by transactions/categories service.<br><br><b>Applicable containers</b>: creditCard, bank, investment<br><b>Applicable Values</b><br>
     * @type {string}
     * @memberof DerivedTransactionsSummary
     */
    categoryType?: DerivedTransactionsSummary.CategoryTypeEnum;
    /**
     * Summary of transaction amouts at category level.<br><br><b>Applicable containers</b>: creditCard, bank, investment<br>
     * @type {Array<DerivedCategorySummary>}
     * @memberof DerivedTransactionsSummary
     */
    categorySummary?: Array<DerivedCategorySummary>;
    /**
     * 
     * @type {Money}
     * @memberof DerivedTransactionsSummary
     */
    creditTotal?: Money;
    /**
     * 
     * @type {DerivedTransactionsLinks}
     * @memberof DerivedTransactionsSummary
     */
    links?: DerivedTransactionsLinks;
    /**
     * 
     * @type {Money}
     * @memberof DerivedTransactionsSummary
     */
    debitTotal?: Money;
}

/**
 * @export
 * @namespace DerivedTransactionsSummary
 */
export namespace DerivedTransactionsSummary {
    /**
     * @export
     * @enum {string}
     */
    export enum CategoryTypeEnum {
        TRANSFER = <any> 'TRANSFER',
        DEFERREDCOMPENSATION = <any> 'DEFERRED_COMPENSATION',
        UNCATEGORIZE = <any> 'UNCATEGORIZE',
        INCOME = <any> 'INCOME',
        EXPENSE = <any> 'EXPENSE'
    }
}
/**
 * 
 * @export
 * @interface Description
 */
export interface Description {
    /**
     * The description will provide the actual name of the security.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof Description
     */
    security?: string;
    /**
     * Original transaction description as it appears at the FI site.<br><br><b>Applicable containers</b>: creditCard, insurance, loan<br>
     * @type {string}
     * @memberof Description
     */
    original?: string;
    /**
     * The transaction description that appears at the FI site may not be self-explanatory, i.e., the source, purpose of the transaction may not be evident. Yodlee attempts to simplify and make the transaction meaningful to the consumer, and this simplified transaction description is provided in the simple description field.Note: The simple description field is available only in the United States, Canada, United Kingdom, and India.<br><br><b>Applicable containers</b>: creditCard, insurance, loan<br>
     * @type {string}
     * @memberof Description
     */
    simple?: string;
    /**
     * The description of the transaction as defined by the consumer. The consumer can define or provide more details of the transaction in this field.<br><br><b>Applicable containers</b>: creditCard, insurance, loan<br>
     * @type {string}
     * @memberof Description
     */
    consumer?: string;
}
/**
 * 
 * @export
 * @interface DetailCategory
 */
export interface DetailCategory {
    /**
     * The name of the detail category<br><br><b>Applicable containers</b>: creditCard, investment, insurance, loan<br>
     * @type {string}
     * @memberof DetailCategory
     */
    name?: string;
    /**
     * The unique identifier of the detail category.<br><br><b>Applicable containers</b>: creditCard, investment, insurance, loan<br>
     * @type {number}
     * @memberof DetailCategory
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface Document
 */
export interface Document {
    /**
     * The unique identifier for the account. The account ID to which the document is linked.<br><br><b>Applicable containers</b>: bank, investment, creditCard, loan, insurance<br>
     * @type {number}
     * @memberof Document
     */
    accountID?: number;
    /**
     * Indicates the date and time the document was last updated.<br><br><b>Applicable containers</b>: bank, investment, creditCard, loan, insurance<br>
     * @type {string}
     * @memberof Document
     */
    lastUpdated?: string;
    /**
     * Indicates the type of the tax form.<br><br><b>Applicable containers</b>: bank, investment, creditCard, loan, insurance<br>
     * @type {string}
     * @memberof Document
     */
    formType?: string;
    /**
     * Indicates the type of the document.<br><br><b>Applicable containers</b>: bank, investment, creditCard, loan, insurance<br>
     * @type {string}
     * @memberof Document
     */
    docType?: Document.DocTypeEnum;
    /**
     * Indicates the name of the document.<br><br><b>Applicable containers</b>: bank, investment, creditCard, loan, insurance<br>
     * @type {string}
     * @memberof Document
     */
    name?: string;
    /**
     * The document's primary key and unique identifier.<br><br><b>Applicable containers</b>: bank, investment, creditCard, loan, insurance<br>
     * @type {string}
     * @memberof Document
     */
    id?: string;
    /**
     * Indicates the source of the document download.<br><br><b>Applicable containers</b>: bank, investment, creditCard, loan, insurance<br>
     * @type {string}
     * @memberof Document
     */
    source?: string;
    /**
     * Indicates the status of the document download.<br><br><b>Applicable containers</b>: bank, investment, creditCard, loan, insurance<br>
     * @type {string}
     * @memberof Document
     */
    status?: string;
}

/**
 * @export
 * @namespace Document
 */
export namespace Document {
    /**
     * @export
     * @enum {string}
     */
    export enum DocTypeEnum {
        STMT = <any> 'STMT',
        TAX = <any> 'TAX',
        EBILL = <any> 'EBILL'
    }
}
/**
 * 
 * @export
 * @interface DocumentDownload
 */
export interface DocumentDownload {
    /**
     * Contents of the document in Base64 format.<br><br><b>Applicable containers</b>: bank, investment, creditCard, loan, insurance<br>
     * @type {string}
     * @memberof DocumentDownload
     */
    docContent?: string;
    /**
     * The document's primary key and unique identifier.<br><br><b>Applicable containers</b>: bank, investment, creditCard, loan, insurance<br>
     * @type {string}
     * @memberof DocumentDownload
     */
    id?: string;
}
/**
 * 
 * @export
 * @interface DocumentDownloadResponse
 */
export interface DocumentDownloadResponse {
    /**
     * 
     * @type {Array<DocumentDownload>}
     * @memberof DocumentDownloadResponse
     */
    document?: Array<DocumentDownload>;
}
/**
 * 
 * @export
 * @interface DocumentResponse
 */
export interface DocumentResponse {
    /**
     * 
     * @type {Array<Document>}
     * @memberof DocumentResponse
     */
    document?: Array<Document>;
}
/**
 * 
 * @export
 * @interface Email
 */
export interface Email {
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    type?: Email.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    value?: string;
}

/**
 * @export
 * @namespace Email
 */
export namespace Email {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        PRIMARY = <any> 'PRIMARY',
        SECONDARY = <any> 'SECONDARY',
        PERSONAL = <any> 'PERSONAL',
        WORK = <any> 'WORK',
        OTHERS = <any> 'OTHERS'
    }
}
/**
 * 
 * @export
 * @interface EvaluateAccountAddress
 */
export interface EvaluateAccountAddress {
    /**
     * Zip.
     * @type {string}
     * @memberof EvaluateAccountAddress
     */
    zip?: string;
    /**
     * Country.
     * @type {string}
     * @memberof EvaluateAccountAddress
     */
    country?: string;
    /**
     * Address Line 3.
     * @type {string}
     * @memberof EvaluateAccountAddress
     */
    address3?: string;
    /**
     * Address Line 2.
     * @type {string}
     * @memberof EvaluateAccountAddress
     */
    address2?: string;
    /**
     * City.
     * @type {string}
     * @memberof EvaluateAccountAddress
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof EvaluateAccountAddress
     */
    sourceType?: string;
    /**
     * Address Line 1.
     * @type {string}
     * @memberof EvaluateAccountAddress
     */
    address1?: string;
    /**
     * 
     * @type {string}
     * @memberof EvaluateAccountAddress
     */
    street: string;
    /**
     * State.
     * @type {string}
     * @memberof EvaluateAccountAddress
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof EvaluateAccountAddress
     */
    type?: EvaluateAccountAddress.TypeEnum;
}

/**
 * @export
 * @namespace EvaluateAccountAddress
 */
export namespace EvaluateAccountAddress {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        HOME = <any> 'HOME',
        BUSINESS = <any> 'BUSINESS',
        POBOX = <any> 'POBOX',
        RETAIL = <any> 'RETAIL',
        OFFICE = <any> 'OFFICE',
        SMALLBUSINESS = <any> 'SMALL_BUSINESS',
        COMMUNICATION = <any> 'COMMUNICATION',
        PERMANENT = <any> 'PERMANENT',
        STATEMENTADDRESS = <any> 'STATEMENT_ADDRESS',
        PAYMENT = <any> 'PAYMENT',
        PAYOFF = <any> 'PAYOFF',
        UNKNOWN = <any> 'UNKNOWN'
    }
}
/**
 * 
 * @export
 * @interface EvaluateAddressRequest
 */
export interface EvaluateAddressRequest {
    /**
     * 
     * @type {EvaluateAccountAddress}
     * @memberof EvaluateAddressRequest
     */
    address: EvaluateAccountAddress;
}
/**
 * 
 * @export
 * @interface EvaluateAddressResponse
 */
export interface EvaluateAddressResponse {
    /**
     * 
     * @type {Array<AccountAddress>}
     * @memberof EvaluateAddressResponse
     */
    address?: Array<AccountAddress>;
    /**
     * 
     * @type {boolean}
     * @memberof EvaluateAddressResponse
     */
    isValidAddress?: boolean;
}
/**
 * 
 * @export
 * @interface Field
 */
export interface Field {
    /**
     * Image displayed at the endsite.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts/{providerAccountId}</li></ul>
     * @type {string}
     * @memberof Field
     */
    image?: string;
    /**
     * The prefix string that has to be displayed before the field value.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts/{providerAccountId}</li><li>GET providers/{providerId}</li></ul>
     * @type {string}
     * @memberof Field
     */
    prefix?: string;
    /**
     * The minimum length of the login form field.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts/{providerAccountId}</li><li>GET providers/{providerId}</li></ul>
     * @type {number}
     * @memberof Field
     */
    minLength?: number;
    /**
     * Indicates whether the field is editable or not.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts/{providerAccountId}</li><li>GET providers/{providerId}</li></ul>
     * @type {string}
     * @memberof Field
     */
    valueEditable?: string;
    /**
     * Indicates if a field is an optional field or a mandatory field.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts/{providerAccountId}</li><li>GET providers/{providerId}</li></ul>
     * @type {boolean}
     * @memberof Field
     */
    isOptional?: boolean;
    /**
     * The suffix string that has to be displayed next to the field value.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts/{providerAccountId}</li><li>GET providers/{providerId}</li></ul>
     * @type {string}
     * @memberof Field
     */
    suffix?: string;
    /**
     * This indicates the display type of the field. For example, text box, image, etc. <br><br><b>Endpoints</b>:<ul><li>GET providerAccounts/{providerAccountId}</li><li>GET providers/{providerId}</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof Field
     */
    type?: Field.TypeEnum;
    /**
     * Indicates that the answer to the security question already exists in the Yodlee system.Persuading the user to provide the answer to the security question again during the edit-credential flow can be avoided.<br><br><br><b>Endpoints</b>:<ul><li>GET providerAccounts?include=questions</li><li>GET providerAccounts/{providerAccountId}? include=questions</li></ul>
     * @type {boolean}
     * @memberof Field
     */
    isValueProvided?: boolean;
    /**
     * Name of the field.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts/{providerAccountId}</li><li>GET providers/{providerId}</li></ul>
     * @type {string}
     * @memberof Field
     */
    name?: string;
    /**
     * Identifier for the field.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts/{providerAccountId}</li><li>GET providers/{providerId}</li></ul>
     * @type {string}
     * @memberof Field
     */
    id?: string;
    /**
     * Value expected from the user for the field. This will be blank and is expected to be filled and sent back when submitting the login or MFA information.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts/{providerAccountId}</li><li>GET providers/{providerId}</li></ul>
     * @type {string}
     * @memberof Field
     */
    value?: string;
    /**
     * The maximum length of the login form field.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts/{providerAccountId}</li><li>GET providers/{providerId}</li></ul>
     * @type {number}
     * @memberof Field
     */
    maxLength?: number;
    /**
     * Provides the different values that are available for the user to choose. This field is applicable for drop-down or radio field types.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts/{providerAccountId}</li><li>GET providers/{providerId}</li></ul>
     * @type {Array<Option>}
     * @memberof Field
     */
    option?: Array<Option>;
}

/**
 * @export
 * @namespace Field
 */
export namespace Field {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Text = <any> 'text',
        Password = <any> 'password',
        Options = <any> 'options',
        Checkbox = <any> 'checkbox',
        Radio = <any> 'radio',
        Image = <any> 'image',
        Option = <any> 'option'
    }
}
/**
 * 
 * @export
 * @interface FieldOperation
 */
export interface FieldOperation {
    /**
     * Field for which the clause is created.<br><br><b>Applicable containers</b>: bank, creditCard, investment, insurance, loan<br><b>Applicable Values</b>:<ul><li>amount</li><li>description</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof FieldOperation
     */
    field?: FieldOperation.FieldEnum;
    /**
     * Operation for which the clause is created.<br><br><b>Applicable containers</b>: bank, creditCard, investment, insurance, loan<br><b>Applicable values (depends on the value of field)</b>:<ul><li>field is <b>description</b> -> operation can be<ol><li>stringEquals</li><li>stringContains</li></ol></li><li>field is <b>amount</b> -> operation can be<ol><li>numberEquals</li><li>numberLessThan</li><li>numberLessThanEquals</li><li>numberGreaterThan</li><li>numberGreaterThanEquals</li></ol></li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof FieldOperation
     */
    operation?: FieldOperation.OperationEnum;
    /**
     * The value would be the amount value in case of amount based rule clause or the string value in case of description based rule clause.<br><br><b>Applicable containers</b>: bank, creditCard, investment, insurance, loan<br><b>Applicable Values</b>:<ul><li>field is <b>description</b> -> value should be <b>min of 3 and max of 50 characters</b></li><li>field is <b>amount</b> -> value should be <b> min value of 0 and a max value of 99999999999.99</b></li></ul>
     * @type {any}
     * @memberof FieldOperation
     */
    value?: any;
}

/**
 * @export
 * @namespace FieldOperation
 */
export namespace FieldOperation {
    /**
     * @export
     * @enum {string}
     */
    export enum FieldEnum {
        Amount = <any> 'amount',
        Description = <any> 'description'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum OperationEnum {
        NumberEquals = <any> 'numberEquals',
        NumberLessThan = <any> 'numberLessThan',
        NumberLessThanEquals = <any> 'numberLessThanEquals',
        NumberGreaterThan = <any> 'numberGreaterThan',
        NumberGreaterThanEquals = <any> 'numberGreaterThanEquals',
        StringEquals = <any> 'stringEquals',
        StringContains = <any> 'stringContains'
    }
}
/**
 * 
 * @export
 * @interface FullAccountNumberList
 */
export interface FullAccountNumberList {
    /**
     * Payment Account Number of given account.<br><br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
     * @type {string}
     * @memberof FullAccountNumberList
     */
    paymentAccountNumber?: string;
    /**
     * Unmasked account number of given account.<br><br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
     * @type {string}
     * @memberof FullAccountNumberList
     */
    unmaskedAccountNumber?: string;
}
/**
 * 
 * @export
 * @interface HistoricalBalance
 */
export interface HistoricalBalance {
    /**
     * Date for which the account balance was provided.  This balance could be a carryforward, calculated or a scraped balance.<br><b>Additional Details</b>:<br><b>Scraped</b>: Balance shown in the provider site. This balance gets stored in Yodlee system during system/user account updates.<br><b>CarryForward</b>: Balance carried forward from the scraped balance to the days for which the balance was not available in the system. Balance may not be available for all the days in the system due to MFA information required, error in the site, credential changes, etc.<br><b>calculated</b>: Balances that gets calculated for the days that are prior to the account added date.  <br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: bank, creditCard, investment, insurance, realEstate, loan<br><b>Endpoints</b>:<ul><li>GET accounts/historicalBalances</li><li>GET derived/networth</li></ul>
     * @type {string}
     * @memberof HistoricalBalance
     */
    date?: string;
    /**
     * Indicates whether the balance is an asset or liability.<br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: bank, creditCard, investment, insurance, realEstate, loan<br><b>Endpoints</b>:<ul><li>GET accounts/historicalBalances</li></ul>
     * @type {boolean}
     * @memberof HistoricalBalance
     */
    isAsset?: boolean;
    /**
     * 
     * @type {Money}
     * @memberof HistoricalBalance
     */
    balance?: Money;
    /**
     * Date as of when the balance is last updated due to the auto account updates or user triggered updates. This balance will be carry forward for the days where there is no balance available in the system. <br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: bank, creditCard, investment, insurance, realEstate, loan<br><b>Endpoints</b>:<ul><li>GET accounts/historicalBalances</li></ul>
     * @type {string}
     * @memberof HistoricalBalance
     */
    asOfDate?: string;
    /**
     * The source of balance information.<br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: bank, creditCard, investment, insurance, realEstate, loan<br><b>Endpoints</b>:<ul><li>GET accounts/historicalBalances</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof HistoricalBalance
     */
    dataSourceType?: HistoricalBalance.DataSourceTypeEnum;
}

/**
 * @export
 * @namespace HistoricalBalance
 */
export namespace HistoricalBalance {
    /**
     * @export
     * @enum {string}
     */
    export enum DataSourceTypeEnum {
        S = <any> 'S',
        C = <any> 'C',
        CF = <any> 'CF'
    }
}
/**
 * 
 * @export
 * @interface HolderProfileResponse
 */
export interface HolderProfileResponse {
    /**
     * The holder profile entity encapsulates all the user's details, such as the corresponding accounts and the users profile data under it
     * @type {Array<VerificationHolderProfile>}
     * @memberof HolderProfileResponse
     */
    holderProfile?: Array<VerificationHolderProfile>;
}
/**
 * 
 * @export
 * @interface Holding
 */
export interface Holding {
    /**
     * The symbol of the security.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof Holding
     */
    symbol?: string;
    /**
     * The quantity of the employee stock options that are already exercised or bought by the employee.<br><b>Note</b>: Once the employee stock options is exercised, they are either converted to cash value or equity positions depending on the FI. The exercised quantity field is only applicable to employee stock options.<br><br><b>Applicable containers</b>: investment<br>
     * @type {number}
     * @memberof Holding
     */
    exercisedQuantity?: number;
    /**
     * The CUSIP (Committee on Uniform Securities Identification Procedures) identifies most the financial instruments in the United States and Canada.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof Holding
     */
    cusipNumber?: string;
    /**
     * Asset classification applied to the holding. <br><br><b>Applicable containers</b>: investment<br>
     * @type {Array<AssetClassification>}
     * @memberof Holding
     */
    assetClassification?: Array<AssetClassification>;
    /**
     * The quantity of units or shares that are already vested on a vest date.<br><b>Note</b>: The vested quantity field is only applicable to employee stock options, restricted stock units/awards, performance units, etc.<br><br><b>Applicable containers</b>: investment<br>
     * @type {number}
     * @memberof Holding
     */
    vestedQuantity?: number;
    /**
     * The description (name) for the holding (E.g., Cisco Systems)<br>For insurance container, the field is only applicable for insurance annuity and variable life insurance types. <br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof Holding
     */
    description?: string;
    /**
     * 
     * @type {Money}
     * @memberof Holding
     */
    unvestedValue?: Money;
    /**
     * Indicates the security style of holding identified through the security service.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof Holding
     */
    securityStyle?: string;
    /**
     * 
     * @type {Money}
     * @memberof Holding
     */
    vestedValue?: Money;
    /**
     * The type of the option position (i.e., put or call).<br><b>Note</b>: The option type field is only applicable to options.<br><br><b>Applicable containers</b>: investment<br><b>Applicable Values</b><br>
     * @type {string}
     * @memberof Holding
     */
    optionType?: Holding.OptionTypeEnum;
    /**
     * The date when the information was last updated in the system.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof Holding
     */
    lastUpdated?: string;
    /**
     * The providerAccountIds that share the account with the primary providerAccountId that was created when the user had added the account for the first time.<br><b>Additional Details</b>: This attribute is returned in the response only if the account deduplication feature is enabled and the same account is mapped to more than one provider account IDs indicating the account is owned by more than one user, for example, joint accounts.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: All Containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {Array<number>}
     * @memberof Holding
     */
    associatedProviderAccountId?: Array<number>;
    /**
     * Indicates the security match status id of the investment option identified during security normalization.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof Holding
     */
    matchStatus?: string;
    /**
     * Type of holding<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof Holding
     */
    holdingType?: Holding.HoldingTypeEnum;
    /**
     * The stated maturity date of a bond or CD.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof Holding
     */
    maturityDate?: string;
    /**
     * 
     * @type {Money}
     * @memberof Holding
     */
    price?: Money;
    /**
     * The fixed duration for which the bond or CD is issued.<br><b>Note</b>: The term field is only applicable to CD.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof Holding
     */
    term?: string;
    /**
     * The quantity of tradeable units in a contract.<br><b>Note</b>: The contract quantity field is only applicable to commodity and currency.<br><br><b>Applicable containers</b>: investment<br>
     * @type {number}
     * @memberof Holding
     */
    contractQuantity?: number;
    /**
     * Unique identifier for the security added in the system. This is the primary key of the holding resource.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {number}
     * @memberof Holding
     */
    id?: number;
    /**
     * Indicates that the holding is a short trading.<br><br><b>Applicable containers</b>: investment<br>
     * @type {boolean}
     * @memberof Holding
     */
    isShort?: boolean;
    /**
     * 
     * @type {Money}
     * @memberof Holding
     */
    value?: Money;
    /**
     * The date on which an option, right or warrant expires.<br><b>Note</b>: The expiration date field is only applicable to options and employee stock options.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof Holding
     */
    expirationDate?: string;
    /**
     * The interest rate on a CD.<br><b>Note</b>: The interest rate field is only applicable to CD.<br><br><b>Applicable containers</b>: investment<br>
     * @type {number}
     * @memberof Holding
     */
    interestRate?: number;
    /**
     * The quantity held for the holding.<br><b>Note</b>: Only for bonds the quantity field indicates the normalized quantity and not the quantity aggregated from the site. The quantity field is only applicable to restricted stock units/awards, performance units, currency, and commodity.<br>For insurance container, the field is only applicable for insurance annuity and variable life insurance types.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {number}
     * @memberof Holding
     */
    quantity?: number;
    /**
     * 
     * @type {Money}
     * @memberof Holding
     */
    accruedInterest?: Money;
    /**
     * The date on which equity awards like ESOP, RSU, etc., are issued or granted.<br><b>Note</b>: The grant date field is only applicable to employee stock options, restricted stock units/awards, performance units, etc.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof Holding
     */
    grantDate?: string;
    /**
     * The SEDOL (Stock Exchange Daily Official List) is a set of security identifiers used in the United Kingdom and Ireland for clearing purposes.<br><b>Note</b>: The SEDOL field is only applicable to the trade related transactions<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof Holding
     */
    sedol?: string;
    /**
     * The number of vested shares that can be exercised by the employee. It is usually equal to the vested quantity.<br><b>Note</b>: The vested shares exercisable field is only applicable to employee stock options, restricted stock units/awards, performance units, etc.<br><br><b>Applicable containers</b>: investment<br>
     * @type {number}
     * @memberof Holding
     */
    vestedSharesExercisable?: number;
    /**
     * 
     * @type {Money}
     * @memberof Holding
     */
    spread?: Money;
    /**
     * Unique identifier of the account to which the security is linked.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {number}
     * @memberof Holding
     */
    accountId?: number;
    /**
     * The enrichedDescription is the security description of the normalized holding<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof Holding
     */
    enrichedDescription?: string;
    /**
     * The stated interest rate for a bond.<br><br><b>Applicable containers</b>: investment<br>
     * @type {number}
     * @memberof Holding
     */
    couponRate?: number;
    /**
     * The date on which the holding is created in the Yodlee system.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof Holding
     */
    createdDate?: string;
    /**
     * 
     * @type {Money}
     * @memberof Holding
     */
    accruedIncome?: Money;
    /**
     * Indicates the security type of holding identified through the security service.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof Holding
     */
    securityType?: string;
    /**
     * Unique identifier for the user's association with the provider.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {number}
     * @memberof Holding
     */
    providerAccountId?: number;
    /**
     * Indicates the number of unvested quantity or units.<br><b>Note</b>: The unvested quantity field is only applicable to employee stock options, restricted stock units/awards, performance units, etc.<br><br><b>Applicable containers</b>: investment<br>
     * @type {number}
     * @memberof Holding
     */
    unvestedQuantity?: number;
    /**
     * 
     * @type {Money}
     * @memberof Holding
     */
    costBasis?: Money;
    /**
     * The date on which a RSU, RSA, or an employee stock options become vested.<br><b>Note</b>: The vesting date field is only applicable to employee stock options, restricted stock units/awards, performance units, etc.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof Holding
     */
    vestingDate?: string;
    /**
     * The ISIN (International Securities Identification Number) is used worldwide to identify specific securities. It is equivalent to CUSIP for international markets.<br><br><b>Note</b>: The ISIN field is only applicable to the trade related transactions<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof Holding
     */
    isin?: string;
    /**
     * 
     * @type {Money}
     * @memberof Holding
     */
    strikePrice?: Money;
}

/**
 * @export
 * @namespace Holding
 */
export namespace Holding {
    /**
     * @export
     * @enum {string}
     */
    export enum OptionTypeEnum {
        Put = <any> 'put',
        Call = <any> 'call',
        Unknown = <any> 'unknown',
        Other = <any> 'other'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum HoldingTypeEnum {
        Stock = <any> 'stock',
        MutualFund = <any> 'mutualFund',
        Bond = <any> 'bond',
        CD = <any> 'CD',
        Option = <any> 'option',
        MoneyMarketFund = <any> 'moneyMarketFund',
        Other = <any> 'other',
        Remic = <any> 'remic',
        Future = <any> 'future',
        Commodity = <any> 'commodity',
        Currency = <any> 'currency',
        UnitInvestmentTrust = <any> 'unitInvestmentTrust',
        EmployeeStockOption = <any> 'employeeStockOption',
        InsuranceAnnuity = <any> 'insuranceAnnuity',
        Unknown = <any> 'unknown',
        PreferredStock = <any> 'preferredStock',
        ETF = <any> 'ETF',
        Warrants = <any> 'warrants',
        DigitalAsset = <any> 'digitalAsset'
    }
}
/**
 * 
 * @export
 * @interface HoldingAssetClassificationListResponse
 */
export interface HoldingAssetClassificationListResponse {
    /**
     * 
     * @type {Array<AssetClassificationList>}
     * @memberof HoldingAssetClassificationListResponse
     */
    assetClassificationList?: Array<AssetClassificationList>;
}
/**
 * 
 * @export
 * @interface HoldingResponse
 */
export interface HoldingResponse {
    /**
     * 
     * @type {Array<Holding>}
     * @memberof HoldingResponse
     */
    holding?: Array<Holding>;
}
/**
 * 
 * @export
 * @interface HoldingSecuritiesResponse
 */
export interface HoldingSecuritiesResponse {
    /**
     * 
     * @type {Array<SecurityHolding>}
     * @memberof HoldingSecuritiesResponse
     */
    holding?: Array<SecurityHolding>;
}
/**
 * 
 * @export
 * @interface HoldingTypeListResponse
 */
export interface HoldingTypeListResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof HoldingTypeListResponse
     */
    holdingType?: Array<HoldingTypeListResponse.HoldingTypeEnum>;
}

/**
 * @export
 * @namespace HoldingTypeListResponse
 */
export namespace HoldingTypeListResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum HoldingTypeEnum {
        Stock = <any> 'stock',
        MutualFund = <any> 'mutualFund',
        Bond = <any> 'bond',
        CD = <any> 'CD',
        Option = <any> 'option',
        MoneyMarketFund = <any> 'moneyMarketFund',
        Other = <any> 'other',
        Remic = <any> 'remic',
        Future = <any> 'future',
        Commodity = <any> 'commodity',
        Currency = <any> 'currency',
        UnitInvestmentTrust = <any> 'unitInvestmentTrust',
        EmployeeStockOption = <any> 'employeeStockOption',
        InsuranceAnnuity = <any> 'insuranceAnnuity',
        Unknown = <any> 'unknown',
        PreferredStock = <any> 'preferredStock',
        ETF = <any> 'ETF',
        Warrants = <any> 'warrants',
        DigitalAsset = <any> 'digitalAsset'
    }
}
/**
 * 
 * @export
 * @interface Identifier
 */
export interface Identifier {
    /**
     * Type of Identifier
     * @type {string}
     * @memberof Identifier
     */
    type?: Identifier.TypeEnum;
    /**
     * Value of the identifier
     * @type {string}
     * @memberof Identifier
     */
    value?: string;
}

/**
 * @export
 * @namespace Identifier
 */
export namespace Identifier {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        NIE = <any> 'NIE',
        DNI = <any> 'DNI',
        EIN = <any> 'EIN',
        BN = <any> 'BN',
        AADHAR = <any> 'AADHAR',
        NIN = <any> 'NIN',
        NRIC = <any> 'NRIC'
    }
}
/**
 * 
 * @export
 * @interface LoanPayoffDetails
 */
export interface LoanPayoffDetails {
    /**
     * The date by which the payoff amount should be paid.<br><br><b>Account Type</b>: Aggregated<br><b>Applicable containers</b>: loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
     * @type {string}
     * @memberof LoanPayoffDetails
     */
    payByDate?: string;
    /**
     * 
     * @type {Money}
     * @memberof LoanPayoffDetails
     */
    payoffAmount?: Money;
    /**
     * 
     * @type {Money}
     * @memberof LoanPayoffDetails
     */
    outstandingBalance?: Money;
}
/**
 * 
 * @export
 * @interface LoginForm
 */
export interface LoginForm {
    /**
     * The title for the MFA information demanded from the user.This is the title displayed in the provider site.This field is applicable for MFA form types only. <br><br><b>Endpoints</b>:<ul><li>GET providerAccounts/{providerAccountId}</li></ul>
     * @type {string}
     * @memberof LoginForm
     */
    mfaInfoTitle?: string;
    /**
     * The help that can be displayed to the customer in the login form.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts/{providerAccountId}</li><li>GET providers/{providerId}</li></ul>
     * @type {string}
     * @memberof LoginForm
     */
    help?: string;
    /**
     * The forget password URL of the provider site.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts/{providerAccountId}</li><li>GET providers/{providerId}</li></ul>
     * @type {string}
     * @memberof LoginForm
     */
    forgetPasswordURL?: string;
    /**
     * The type of the forms for which the user information is required.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts/{providerAccountId}</li><li>GET providers/{providerId}</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof LoginForm
     */
    formType?: LoginForm.FormTypeEnum;
    /**
     * The text displayed in the provider site while requesting the user's MFA information. This field is applicable for MFA form types only. <br><br><b>Endpoints</b>:<ul><li>GET providerAccounts/{providerAccountId}</li></ul>
     * @type {string}
     * @memberof LoginForm
     */
    mfaInfoText?: string;
    /**
     * The help that can be displayed to the customer in the login form.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts/{providerAccountId}</li><li>GET providers/{providerId}</li></ul>
     * @type {string}
     * @memberof LoginForm
     */
    loginHelp?: string;
    /**
     * The amount of time before which the user is expected to provide MFA information. This field is applicable for MFA form types only. This would be an useful information that could be displayed to the users. <br><br><b>Endpoints</b>:<ul><li>GET providerAccounts/{providerAccountId}</li><li>GET providers/{providerId}</li></ul>
     * @type {number}
     * @memberof LoginForm
     */
    mfaTimeout?: number;
    /**
     * The identifier of the login form.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts/{providerAccountId}</li><li>GET providers/{providerId}</li></ul>
     * @type {number}
     * @memberof LoginForm
     */
    id?: number;
    /**
     * This indicates one row in the form. The row will have one label. But it may have single or multiple fields.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts/{providerAccountId}</li><li>GET providers/{providerId}</li></ul>
     * @type {Array<Row>}
     * @memberof LoginForm
     */
    row?: Array<Row>;
}

/**
 * @export
 * @namespace LoginForm
 */
export namespace LoginForm {
    /**
     * @export
     * @enum {string}
     */
    export enum FormTypeEnum {
        Login = <any> 'login',
        QuestionAndAnswer = <any> 'questionAndAnswer',
        Token = <any> 'token',
        Image = <any> 'image'
    }
}
/**
 * 
 * @export
 * @interface Merchant
 */
export interface Merchant {
    /**
     * The website of the merchant.<br><br><b>Applicable containers</b>: bank,creditCard,investment,loan<br>
     * @type {string}
     * @memberof Merchant
     */
    website?: string;
    /**
     * 
     * @type {AccountAddress}
     * @memberof Merchant
     */
    address?: AccountAddress;
    /**
     * 
     * @type {Contact}
     * @memberof Merchant
     */
    contact?: Contact;
    /**
     * The business categories of the merchant.<br><br><b>Applicable containers</b>: bank,creditCard<br><b>Applicable Values</b><br>
     * @type {Array<string>}
     * @memberof Merchant
     */
    categoryLabel?: Array<string>;
    /**
     * 
     * @type {Coordinates}
     * @memberof Merchant
     */
    coordinates?: Coordinates;
    /**
     * The name of the merchant.<br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br>
     * @type {string}
     * @memberof Merchant
     */
    name?: string;
    /**
     * Identifier of the merchant.<br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br>
     * @type {string}
     * @memberof Merchant
     */
    id?: string;
    /**
     * The source through which merchant information is retrieved.<br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br><b>Applicable Values</b><br>
     * @type {string}
     * @memberof Merchant
     */
    source?: Merchant.SourceEnum;
    /**
     * The logoURL of the merchant.<br><br><b>Applicable containers</b>: bank,creditCard,investment,loan<br>
     * @type {string}
     * @memberof Merchant
     */
    logoURL?: string;
}

/**
 * @export
 * @namespace Merchant
 */
export namespace Merchant {
    /**
     * @export
     * @enum {string}
     */
    export enum SourceEnum {
        YODLEE = <any> 'YODLEE',
        FACTUAL = <any> 'FACTUAL'
    }
}
/**
 * 
 * @export
 * @interface Money
 */
export interface Money {
    /**
     * Value of amount.
     * @type {number}
     * @memberof Money
     */
    amount?: number;
    /**
     * Value of the converted amount.
     * @type {number}
     * @memberof Money
     */
    convertedAmount?: number;
    /**
     * Currency should be a valid three-letter ISO Code.
     * @type {string}
     * @memberof Money
     */
    currency?: Money.CurrencyEnum;
    /**
     * Currency should be a valid three-letter ISO Code.
     * @type {string}
     * @memberof Money
     */
    convertedCurrency?: Money.ConvertedCurrencyEnum;
}

/**
 * @export
 * @namespace Money
 */
export namespace Money {
    /**
     * @export
     * @enum {string}
     */
    export enum CurrencyEnum {
        USD = <any> 'USD',
        AUD = <any> 'AUD',
        BRL = <any> 'BRL',
        CAD = <any> 'CAD',
        EUR = <any> 'EUR',
        GBP = <any> 'GBP',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        INR = <any> 'INR',
        JPY = <any> 'JPY',
        NZD = <any> 'NZD',
        SGD = <any> 'SGD',
        ZAR = <any> 'ZAR',
        CNY = <any> 'CNY',
        VND = <any> 'VND',
        MYR = <any> 'MYR',
        CHF = <any> 'CHF',
        AED = <any> 'AED',
        AFA = <any> 'AFA',
        ALL = <any> 'ALL',
        AMD = <any> 'AMD',
        ANG = <any> 'ANG',
        AOA = <any> 'AOA',
        ARS = <any> 'ARS',
        AWG = <any> 'AWG',
        AZM = <any> 'AZM',
        BAM = <any> 'BAM',
        BBD = <any> 'BBD',
        BDT = <any> 'BDT',
        BGL = <any> 'BGL',
        BHD = <any> 'BHD',
        BIF = <any> 'BIF',
        BMD = <any> 'BMD',
        BND = <any> 'BND',
        BOB = <any> 'BOB',
        BSD = <any> 'BSD',
        BTN = <any> 'BTN',
        BWP = <any> 'BWP',
        BYR = <any> 'BYR',
        BZD = <any> 'BZD',
        CDF = <any> 'CDF',
        CLP = <any> 'CLP',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        CVE = <any> 'CVE',
        CYP = <any> 'CYP',
        CZK = <any> 'CZK',
        DJF = <any> 'DJF',
        DKK = <any> 'DKK',
        DOP = <any> 'DOP',
        DZD = <any> 'DZD',
        EEK = <any> 'EEK',
        EGP = <any> 'EGP',
        ERN = <any> 'ERN',
        ETB = <any> 'ETB',
        FJD = <any> 'FJD',
        FKP = <any> 'FKP',
        GEL = <any> 'GEL',
        GGP = <any> 'GGP',
        GHC = <any> 'GHC',
        GIP = <any> 'GIP',
        GMD = <any> 'GMD',
        GNF = <any> 'GNF',
        GTQ = <any> 'GTQ',
        GYD = <any> 'GYD',
        HNL = <any> 'HNL',
        HRK = <any> 'HRK',
        HTG = <any> 'HTG',
        HUF = <any> 'HUF',
        ILS = <any> 'ILS',
        IMP = <any> 'IMP',
        IQD = <any> 'IQD',
        IRR = <any> 'IRR',
        ISK = <any> 'ISK',
        JEP = <any> 'JEP',
        JMD = <any> 'JMD',
        JOD = <any> 'JOD',
        KES = <any> 'KES',
        KGS = <any> 'KGS',
        KHR = <any> 'KHR',
        KMF = <any> 'KMF',
        KPW = <any> 'KPW',
        KRW = <any> 'KRW',
        KWD = <any> 'KWD',
        KYD = <any> 'KYD',
        KZT = <any> 'KZT',
        LAK = <any> 'LAK',
        LBP = <any> 'LBP',
        LKR = <any> 'LKR',
        LRD = <any> 'LRD',
        LSL = <any> 'LSL',
        LTL = <any> 'LTL',
        LVL = <any> 'LVL',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        MDL = <any> 'MDL',
        MGF = <any> 'MGF',
        MKD = <any> 'MKD',
        MMK = <any> 'MMK',
        MNT = <any> 'MNT',
        MOP = <any> 'MOP',
        MRO = <any> 'MRO',
        MTL = <any> 'MTL',
        MUR = <any> 'MUR',
        MVR = <any> 'MVR',
        MWK = <any> 'MWK',
        MXN = <any> 'MXN',
        MZM = <any> 'MZM',
        NAD = <any> 'NAD',
        NGN = <any> 'NGN',
        NIO = <any> 'NIO',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        OMR = <any> 'OMR',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PGK = <any> 'PGK',
        PHP = <any> 'PHP',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        PYG = <any> 'PYG',
        QAR = <any> 'QAR',
        ROL = <any> 'ROL',
        RUR = <any> 'RUR',
        RWF = <any> 'RWF',
        SAR = <any> 'SAR',
        SBD = <any> 'SBD',
        SCR = <any> 'SCR',
        SDD = <any> 'SDD',
        SEK = <any> 'SEK',
        SHP = <any> 'SHP',
        SIT = <any> 'SIT',
        SKK = <any> 'SKK',
        SLL = <any> 'SLL',
        SOS = <any> 'SOS',
        SPL = <any> 'SPL',
        SRG = <any> 'SRG',
        STD = <any> 'STD',
        SVC = <any> 'SVC',
        SYP = <any> 'SYP',
        SZL = <any> 'SZL',
        THB = <any> 'THB',
        TJR = <any> 'TJR',
        TMM = <any> 'TMM',
        TND = <any> 'TND',
        TOP = <any> 'TOP',
        TRL = <any> 'TRL',
        TTD = <any> 'TTD',
        TVD = <any> 'TVD',
        TWD = <any> 'TWD',
        TZS = <any> 'TZS',
        UAH = <any> 'UAH',
        UGX = <any> 'UGX',
        UYU = <any> 'UYU',
        UZS = <any> 'UZS',
        VEB = <any> 'VEB',
        VUV = <any> 'VUV',
        WST = <any> 'WST',
        XAF = <any> 'XAF',
        XAG = <any> 'XAG',
        XAU = <any> 'XAU',
        XCD = <any> 'XCD',
        XDR = <any> 'XDR',
        XOF = <any> 'XOF',
        XPD = <any> 'XPD',
        XPF = <any> 'XPF',
        XPT = <any> 'XPT',
        YER = <any> 'YER',
        YUM = <any> 'YUM',
        ZMK = <any> 'ZMK',
        ZWD = <any> 'ZWD',
        ADP = <any> 'ADP',
        ATS = <any> 'ATS',
        BEF = <any> 'BEF',
        BUK = <any> 'BUK',
        CSD = <any> 'CSD',
        CSK = <any> 'CSK',
        DDM = <any> 'DDM',
        DEM = <any> 'DEM',
        ECS = <any> 'ECS',
        ESP = <any> 'ESP',
        FIM = <any> 'FIM',
        GRD = <any> 'GRD',
        GWP = <any> 'GWP',
        IEP = <any> 'IEP',
        ITL = <any> 'ITL',
        LUF = <any> 'LUF',
        MLF = <any> 'MLF',
        NLG = <any> 'NLG',
        PTE = <any> 'PTE',
        SUR = <any> 'SUR',
        TPE = <any> 'TPE',
        UAK = <any> 'UAK',
        XBA = <any> 'XBA',
        XBB = <any> 'XBB',
        XBC = <any> 'XBC',
        XBD = <any> 'XBD',
        XEU = <any> 'XEU',
        XFO = <any> 'XFO',
        XFU = <any> 'XFU',
        XGF = <any> 'XGF',
        XMK = <any> 'XMK',
        XRM = <any> 'XRM',
        XTS = <any> 'XTS',
        YDD = <any> 'YDD',
        YUD = <any> 'YUD',
        ZRN = <any> 'ZRN',
        TJS = <any> 'TJS',
        RON = <any> 'RON',
        BGN = <any> 'BGN',
        BTC = <any> 'BTC',
        XBT = <any> 'XBT',
        CNH = <any> 'CNH',
        RUB = <any> 'RUB',
        TRY = <any> 'TRY',
        GHS = <any> 'GHS',
        TMT = <any> 'TMT',
        ZMW = <any> 'ZMW',
        VEF = <any> 'VEF',
        SSP = <any> 'SSP',
        ALK = <any> 'ALK'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ConvertedCurrencyEnum {
        USD = <any> 'USD',
        AUD = <any> 'AUD',
        BRL = <any> 'BRL',
        CAD = <any> 'CAD',
        EUR = <any> 'EUR',
        GBP = <any> 'GBP',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        INR = <any> 'INR',
        JPY = <any> 'JPY',
        NZD = <any> 'NZD',
        SGD = <any> 'SGD',
        ZAR = <any> 'ZAR',
        CNY = <any> 'CNY',
        VND = <any> 'VND',
        MYR = <any> 'MYR',
        CHF = <any> 'CHF',
        AED = <any> 'AED',
        AFA = <any> 'AFA',
        ALL = <any> 'ALL',
        AMD = <any> 'AMD',
        ANG = <any> 'ANG',
        AOA = <any> 'AOA',
        ARS = <any> 'ARS',
        AWG = <any> 'AWG',
        AZM = <any> 'AZM',
        BAM = <any> 'BAM',
        BBD = <any> 'BBD',
        BDT = <any> 'BDT',
        BGL = <any> 'BGL',
        BHD = <any> 'BHD',
        BIF = <any> 'BIF',
        BMD = <any> 'BMD',
        BND = <any> 'BND',
        BOB = <any> 'BOB',
        BSD = <any> 'BSD',
        BTN = <any> 'BTN',
        BWP = <any> 'BWP',
        BYR = <any> 'BYR',
        BZD = <any> 'BZD',
        CDF = <any> 'CDF',
        CLP = <any> 'CLP',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        CVE = <any> 'CVE',
        CYP = <any> 'CYP',
        CZK = <any> 'CZK',
        DJF = <any> 'DJF',
        DKK = <any> 'DKK',
        DOP = <any> 'DOP',
        DZD = <any> 'DZD',
        EEK = <any> 'EEK',
        EGP = <any> 'EGP',
        ERN = <any> 'ERN',
        ETB = <any> 'ETB',
        FJD = <any> 'FJD',
        FKP = <any> 'FKP',
        GEL = <any> 'GEL',
        GGP = <any> 'GGP',
        GHC = <any> 'GHC',
        GIP = <any> 'GIP',
        GMD = <any> 'GMD',
        GNF = <any> 'GNF',
        GTQ = <any> 'GTQ',
        GYD = <any> 'GYD',
        HNL = <any> 'HNL',
        HRK = <any> 'HRK',
        HTG = <any> 'HTG',
        HUF = <any> 'HUF',
        ILS = <any> 'ILS',
        IMP = <any> 'IMP',
        IQD = <any> 'IQD',
        IRR = <any> 'IRR',
        ISK = <any> 'ISK',
        JEP = <any> 'JEP',
        JMD = <any> 'JMD',
        JOD = <any> 'JOD',
        KES = <any> 'KES',
        KGS = <any> 'KGS',
        KHR = <any> 'KHR',
        KMF = <any> 'KMF',
        KPW = <any> 'KPW',
        KRW = <any> 'KRW',
        KWD = <any> 'KWD',
        KYD = <any> 'KYD',
        KZT = <any> 'KZT',
        LAK = <any> 'LAK',
        LBP = <any> 'LBP',
        LKR = <any> 'LKR',
        LRD = <any> 'LRD',
        LSL = <any> 'LSL',
        LTL = <any> 'LTL',
        LVL = <any> 'LVL',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        MDL = <any> 'MDL',
        MGF = <any> 'MGF',
        MKD = <any> 'MKD',
        MMK = <any> 'MMK',
        MNT = <any> 'MNT',
        MOP = <any> 'MOP',
        MRO = <any> 'MRO',
        MTL = <any> 'MTL',
        MUR = <any> 'MUR',
        MVR = <any> 'MVR',
        MWK = <any> 'MWK',
        MXN = <any> 'MXN',
        MZM = <any> 'MZM',
        NAD = <any> 'NAD',
        NGN = <any> 'NGN',
        NIO = <any> 'NIO',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        OMR = <any> 'OMR',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PGK = <any> 'PGK',
        PHP = <any> 'PHP',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        PYG = <any> 'PYG',
        QAR = <any> 'QAR',
        ROL = <any> 'ROL',
        RUR = <any> 'RUR',
        RWF = <any> 'RWF',
        SAR = <any> 'SAR',
        SBD = <any> 'SBD',
        SCR = <any> 'SCR',
        SDD = <any> 'SDD',
        SEK = <any> 'SEK',
        SHP = <any> 'SHP',
        SIT = <any> 'SIT',
        SKK = <any> 'SKK',
        SLL = <any> 'SLL',
        SOS = <any> 'SOS',
        SPL = <any> 'SPL',
        SRG = <any> 'SRG',
        STD = <any> 'STD',
        SVC = <any> 'SVC',
        SYP = <any> 'SYP',
        SZL = <any> 'SZL',
        THB = <any> 'THB',
        TJR = <any> 'TJR',
        TMM = <any> 'TMM',
        TND = <any> 'TND',
        TOP = <any> 'TOP',
        TRL = <any> 'TRL',
        TTD = <any> 'TTD',
        TVD = <any> 'TVD',
        TWD = <any> 'TWD',
        TZS = <any> 'TZS',
        UAH = <any> 'UAH',
        UGX = <any> 'UGX',
        UYU = <any> 'UYU',
        UZS = <any> 'UZS',
        VEB = <any> 'VEB',
        VUV = <any> 'VUV',
        WST = <any> 'WST',
        XAF = <any> 'XAF',
        XAG = <any> 'XAG',
        XAU = <any> 'XAU',
        XCD = <any> 'XCD',
        XDR = <any> 'XDR',
        XOF = <any> 'XOF',
        XPD = <any> 'XPD',
        XPF = <any> 'XPF',
        XPT = <any> 'XPT',
        YER = <any> 'YER',
        YUM = <any> 'YUM',
        ZMK = <any> 'ZMK',
        ZWD = <any> 'ZWD',
        ADP = <any> 'ADP',
        ATS = <any> 'ATS',
        BEF = <any> 'BEF',
        BUK = <any> 'BUK',
        CSD = <any> 'CSD',
        CSK = <any> 'CSK',
        DDM = <any> 'DDM',
        DEM = <any> 'DEM',
        ECS = <any> 'ECS',
        ESP = <any> 'ESP',
        FIM = <any> 'FIM',
        GRD = <any> 'GRD',
        GWP = <any> 'GWP',
        IEP = <any> 'IEP',
        ITL = <any> 'ITL',
        LUF = <any> 'LUF',
        MLF = <any> 'MLF',
        NLG = <any> 'NLG',
        PTE = <any> 'PTE',
        SUR = <any> 'SUR',
        TPE = <any> 'TPE',
        UAK = <any> 'UAK',
        XBA = <any> 'XBA',
        XBB = <any> 'XBB',
        XBC = <any> 'XBC',
        XBD = <any> 'XBD',
        XEU = <any> 'XEU',
        XFO = <any> 'XFO',
        XFU = <any> 'XFU',
        XGF = <any> 'XGF',
        XMK = <any> 'XMK',
        XRM = <any> 'XRM',
        XTS = <any> 'XTS',
        YDD = <any> 'YDD',
        YUD = <any> 'YUD',
        ZRN = <any> 'ZRN',
        TJS = <any> 'TJS',
        RON = <any> 'RON',
        BGN = <any> 'BGN',
        BTC = <any> 'BTC',
        XBT = <any> 'XBT',
        CNH = <any> 'CNH',
        RUB = <any> 'RUB',
        TRY = <any> 'TRY',
        GHS = <any> 'GHS',
        TMT = <any> 'TMT',
        ZMW = <any> 'ZMW',
        VEF = <any> 'VEF',
        SSP = <any> 'SSP',
        ALK = <any> 'ALK'
    }
}
/**
 * 
 * @export
 * @interface Name
 */
export interface Name {
    /**
     * Middle name.
     * @type {string}
     * @memberof Name
     */
    middle?: string;
    /**
     * Last name.
     * @type {string}
     * @memberof Name
     */
    last?: string;
    /**
     * Full name.
     * @type {string}
     * @memberof Name
     */
    fullName?: string;
    /**
     * First name.
     * @type {string}
     * @memberof Name
     */
    first?: string;
}
/**
 * 
 * @export
 * @interface Option
 */
export interface Option {
    /**
     * The text that is displayed to the user for that option in the provider site.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts/{providerAccountId}</li><li>GET providers/{providerId}</li></ul>
     * @type {string}
     * @memberof Option
     */
    displayText?: string;
    /**
     * The value that is associated with the option.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts/{providerAccountId}</li><li>GET providers/{providerId}</li></ul>
     * @type {string}
     * @memberof Option
     */
    optionValue?: string;
    /**
     * The option that is selected by default in the provider site.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts/{providerAccountId}</li><li>GET providers/{providerId}</li></ul>
     * @type {boolean}
     * @memberof Option
     */
    isSelected?: boolean;
}
/**
 * 
 * @export
 * @interface PaymentBankTransferCode
 */
export interface PaymentBankTransferCode {
    /**
     * Value of the identifier
     * @type {string}
     * @memberof PaymentBankTransferCode
     */
    id?: string;
    /**
     * Type of BankTransferCode
     * @type {string}
     * @memberof PaymentBankTransferCode
     */
    type?: PaymentBankTransferCode.TypeEnum;
}

/**
 * @export
 * @namespace PaymentBankTransferCode
 */
export namespace PaymentBankTransferCode {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        ROUTINGNUMBER = <any> 'ROUTING_NUMBER',
        BSB = <any> 'BSB',
        IFSC = <any> 'IFSC',
        SORTCODE = <any> 'SORT_CODE'
    }
}
/**
 * 
 * @export
 * @interface PaymentIdentifier
 */
export interface PaymentIdentifier {
    /**
     * Type of Identifier
     * @type {string}
     * @memberof PaymentIdentifier
     */
    type?: PaymentIdentifier.TypeEnum;
    /**
     * Value of the identifier
     * @type {string}
     * @memberof PaymentIdentifier
     */
    value?: string;
}

/**
 * @export
 * @namespace PaymentIdentifier
 */
export namespace PaymentIdentifier {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        REFERENCENUMBER = <any> 'REFERENCE_NUMBER',
        PLATFORMCODE = <any> 'PLATFORM_CODE'
    }
}
/**
 * 
 * @export
 * @interface PaymentProfile
 */
export interface PaymentProfile {
    /**
     * 
     * @type {PaymentIdentifier}
     * @memberof PaymentProfile
     */
    identifier?: PaymentIdentifier;
    /**
     * The address of the lender to which the monthly payments or the loan payoff amount should be paid. <br><b>Additional Details:</b>The address field applies only to the student loan account type.<br><b>Account Type</b>: Aggregated<br><b>Applicable containers</b>: loan<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
     * @type {Array<AccountAddress>}
     * @memberof PaymentProfile
     */
    address?: Array<AccountAddress>;
    /**
     * 
     * @type {PaymentBankTransferCode}
     * @memberof PaymentProfile
     */
    paymentBankTransferCode?: PaymentBankTransferCode;
}
/**
 * 
 * @export
 * @interface PhoneNumber
 */
export interface PhoneNumber {
    /**
     * type of phone number
     * @type {string}
     * @memberof PhoneNumber
     */
    type?: PhoneNumber.TypeEnum;
    /**
     * Phone Number
     * @type {string}
     * @memberof PhoneNumber
     */
    value?: string;
}

/**
 * @export
 * @namespace PhoneNumber
 */
export namespace PhoneNumber {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        HOME = <any> 'HOME',
        WORK = <any> 'WORK',
        LANDLINE = <any> 'LANDLINE',
        MOBILE = <any> 'MOBILE'
    }
}
/**
 * 
 * @export
 * @interface Profile
 */
export interface Profile {
    /**
     * Identifiers available in the profile page of the account.<br><br><b>Account Type</b>: Aggregated<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
     * @type {Array<Identifier>}
     * @memberof Profile
     */
    identifier?: Array<Identifier>;
    /**
     * Address available in the profile page of the account.<br><br><b>Account Type</b>: Aggregated<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
     * @type {Array<AccountAddress>}
     * @memberof Profile
     */
    address?: Array<AccountAddress>;
    /**
     * Phone number available in the profile page of the account.<br><br><b>Account Type</b>: Aggregated<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
     * @type {Array<PhoneNumber>}
     * @memberof Profile
     */
    phoneNumber?: Array<PhoneNumber>;
    /**
     * Gender of the provider account holder.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Endpoints</b>:<ul><li>GET providerAccounts/profile</li></ul>
     * @type {string}
     * @memberof Profile
     */
    gender?: string;
    /**
     * 
     * @type {Name}
     * @memberof Profile
     */
    name?: Name;
    /**
     * Email Id available in the profile page of the account.<br><br><b>Account Type</b>: Aggregated<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
     * @type {Array<Email>}
     * @memberof Profile
     */
    email?: Array<Email>;
}
/**
 * 
 * @export
 * @interface ProviderAccount
 */
export interface ProviderAccount {
    /**
     * 
     * @type {ProviderAccountPreferences}
     * @memberof ProviderAccount
     */
    preferences?: ProviderAccountPreferences;
    /**
     * Indicates the migration status of the provider account from screen-scraping provider to the Open Banking provider. <br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>GET providerAccounts/{providerAccountId}</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof ProviderAccount
     */
    oauthMigrationStatus?: ProviderAccount.OauthMigrationStatusEnum;
    /**
     * Indicates whether account is a manual or aggregated provider account.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {boolean}
     * @memberof ProviderAccount
     */
    isManual?: boolean;
    /**
     * Attribute to specify whether the user has to input(credentials/MFA) for refreshing an account<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>GET providerAccounts/{providerAccountId}</li>
     * @type {boolean}
     * @memberof ProviderAccount
     */
    isRealTimeMFA?: boolean;
    /**
     * Indicate when the providerAccount is last updated successfully.<br><br><b>Account Type</b>: Aggregated<br><b>Endpoints</b>:<ul><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof ProviderAccount
     */
    lastUpdated?: string;
    /**
     * Consent Id generated through POST Consent.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li></ul>
     * @type {number}
     * @memberof ProviderAccount
     */
    consentId?: number;
    /**
     * The date on when the provider account is created in the system.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li></ul>
     * @type {string}
     * @memberof ProviderAccount
     */
    createdDate?: string;
    /**
     * The source through which the providerAccount is added in the system.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li><li>GET dataExtracts/userData</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof ProviderAccount
     */
    aggregationSource?: ProviderAccount.AggregationSourceEnum;
    /**
     * Unique identifier for the provider resource. This denotes the provider for which the provider account id is generated by the user.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {number}
     * @memberof ProviderAccount
     */
    providerId?: number;
    /**
     * Unique id generated to indicate the request.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li></ul>
     * @type {string}
     * @memberof ProviderAccount
     */
    requestId?: string;
    /**
     * Unique identifier for the provider account resource. This is created during account addition.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {number}
     * @memberof ProviderAccount
     */
    id?: number;
    /**
     * Logical grouping of dataset attributes into datasets such as Basic Aggregation Data, Account Profile and Documents.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {Array<AccountDataset>}
     * @memberof ProviderAccount
     */
    dataset?: Array<AccountDataset>;
    /**
     * The status of last update attempted for the account. <br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li><li>GET dataExtracts/userData</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof ProviderAccount
     */
    status?: ProviderAccount.StatusEnum;
}

/**
 * @export
 * @namespace ProviderAccount
 */
export namespace ProviderAccount {
    /**
     * @export
     * @enum {string}
     */
    export enum OauthMigrationStatusEnum {
        INPROGRESS = <any> 'IN_PROGRESS',
        TOBEMIGRATED = <any> 'TO_BE_MIGRATED',
        COMPLETED = <any> 'COMPLETED',
        MIGRATED = <any> 'MIGRATED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum AggregationSourceEnum {
        SYSTEM = <any> 'SYSTEM',
        USER = <any> 'USER'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        LOGININPROGRESS = <any> 'LOGIN_IN_PROGRESS',
        USERINPUTREQUIRED = <any> 'USER_INPUT_REQUIRED',
        INPROGRESS = <any> 'IN_PROGRESS',
        PARTIALSUCCESS = <any> 'PARTIAL_SUCCESS',
        SUCCESS = <any> 'SUCCESS',
        FAILED = <any> 'FAILED',
        MIGRATIONINPROGRESS = <any> 'MIGRATION_IN_PROGRESS'
    }
}
/**
 * 
 * @export
 * @interface ProviderAccountDetail
 */
export interface ProviderAccountDetail {
    /**
     * 
     * @type {ProviderAccountPreferences}
     * @memberof ProviderAccountDetail
     */
    preferences?: ProviderAccountPreferences;
    /**
     * Indicates the migration status of the provider account from screen-scraping provider to the Open Banking provider. <br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>GET providerAccounts/{providerAccountId}</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof ProviderAccountDetail
     */
    oauthMigrationStatus?: ProviderAccountDetail.OauthMigrationStatusEnum;
    /**
     * Indicates whether account is a manual or aggregated provider account.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {boolean}
     * @memberof ProviderAccountDetail
     */
    isManual?: boolean;
    /**
     * Attribute to specify whether the user has to input(credentials/MFA) for refreshing an account<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>GET providerAccounts/{providerAccountId}</li>
     * @type {boolean}
     * @memberof ProviderAccountDetail
     */
    isRealTimeMFA?: boolean;
    /**
     * Indicate when the providerAccount is last updated successfully.<br><br><b>Account Type</b>: Aggregated<br><b>Endpoints</b>:<ul><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof ProviderAccountDetail
     */
    lastUpdated?: string;
    /**
     * Consent Id generated through POST Consent.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li></ul>
     * @type {number}
     * @memberof ProviderAccountDetail
     */
    consentId: number;
    /**
     * This entity gets returned in the response for only MFA based provider accounts during the add/update account polling process. This indicates that the MFA information is expected from the user to complete the process. This represents the structure of MFA form that is displayed to the user in the provider site.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li></ul>
     * @type {Array<LoginForm>}
     * @memberof ProviderAccountDetail
     */
    loginForm?: Array<LoginForm>;
    /**
     * The date on when the provider account is created in the system.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li></ul>
     * @type {string}
     * @memberof ProviderAccountDetail
     */
    createdDate?: string;
    /**
     * The source through which the providerAccount is added in the system.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li><li>GET dataExtracts/userData</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof ProviderAccountDetail
     */
    aggregationSource?: ProviderAccountDetail.AggregationSourceEnum;
    /**
     * Unique identifier for the provider resource. This denotes the provider for which the provider account id is generated by the user.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {number}
     * @memberof ProviderAccountDetail
     */
    providerId?: number;
    /**
     * Unique id generated to indicate the request.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li></ul>
     * @type {string}
     * @memberof ProviderAccountDetail
     */
    requestId?: string;
    /**
     * Unique identifier for the provider account resource. This is created during account addition.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {number}
     * @memberof ProviderAccountDetail
     */
    id?: number;
    /**
     * Logical grouping of dataset attributes into datasets such as Basic Aggregation Data, Account Profile and Documents.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {Array<AccountDataset>}
     * @memberof ProviderAccountDetail
     */
    dataset?: Array<AccountDataset>;
    /**
     * The status of last update attempted for the account. <br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li><li>GET dataExtracts/userData</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof ProviderAccountDetail
     */
    status?: ProviderAccountDetail.StatusEnum;
}

/**
 * @export
 * @namespace ProviderAccountDetail
 */
export namespace ProviderAccountDetail {
    /**
     * @export
     * @enum {string}
     */
    export enum OauthMigrationStatusEnum {
        INPROGRESS = <any> 'IN_PROGRESS',
        TOBEMIGRATED = <any> 'TO_BE_MIGRATED',
        COMPLETED = <any> 'COMPLETED',
        MIGRATED = <any> 'MIGRATED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum AggregationSourceEnum {
        SYSTEM = <any> 'SYSTEM',
        USER = <any> 'USER'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        LOGININPROGRESS = <any> 'LOGIN_IN_PROGRESS',
        USERINPUTREQUIRED = <any> 'USER_INPUT_REQUIRED',
        INPROGRESS = <any> 'IN_PROGRESS',
        PARTIALSUCCESS = <any> 'PARTIAL_SUCCESS',
        SUCCESS = <any> 'SUCCESS',
        FAILED = <any> 'FAILED',
        MIGRATIONINPROGRESS = <any> 'MIGRATION_IN_PROGRESS'
    }
}
/**
 * 
 * @export
 * @interface ProviderAccountDetailResponse
 */
export interface ProviderAccountDetailResponse {
    /**
     * 
     * @type {Array<ProviderAccountDetail>}
     * @memberof ProviderAccountDetailResponse
     */
    providerAccount?: Array<ProviderAccountDetail>;
}
/**
 * 
 * @export
 * @interface ProviderAccountPreferences
 */
export interface ProviderAccountPreferences {
    /**
     * Indicates if the updates to the provider account should be part of the data extracts event notification or the data extract data retrieval service.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts?include=preferences</li><li>GET providerAccounts/{providerAccountId}?include=preferences</li></ul>
     * @type {boolean}
     * @memberof ProviderAccountPreferences
     */
    isDataExtractsEnabled?: boolean;
    /**
     * LinkedproviderAccountd is a providerAccountId linked by the user to the primary provider account. <br>LinkedProviderAccountId and the providerAccountId belongs to the same institution.<br><br><b>Endpoints</b>:<ul><li>POST Provider Account</li><li>PUT Provider Account</li><li>GET Provider Accounts</li></ul>
     * @type {number}
     * @memberof ProviderAccountPreferences
     */
    linkedProviderAccountId?: number;
    /**
     * Indicates if auto-refreshes have to be triggered for the provider account.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts?include=preferences</li><li>GET providerAccounts/{providerAccountId}?include=preferences</li></ul>
     * @type {boolean}
     * @memberof ProviderAccountPreferences
     */
    isAutoRefreshEnabled?: boolean;
}
/**
 * 
 * @export
 * @interface ProviderAccountPreferencesRequest
 */
export interface ProviderAccountPreferencesRequest {
    /**
     * 
     * @type {ProviderAccountPreferences}
     * @memberof ProviderAccountPreferencesRequest
     */
    preferences?: ProviderAccountPreferences;
}
/**
 * 
 * @export
 * @interface ProviderAccountProfile
 */
export interface ProviderAccountProfile {
    /**
     * PII related data like address, name, phoneNumber, identifier and email.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts/profile</li></ul>
     * @type {Array<Profile>}
     * @memberof ProviderAccountProfile
     */
    profile?: Array<Profile>;
    /**
     * Unique identifier for profile<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts/profile</li></ul>
     * @type {number}
     * @memberof ProviderAccountProfile
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface ProviderAccountRefreshRequest
 */
export interface ProviderAccountRefreshRequest {
    /**
     * The name of configuration created at the time onboarding or configuration creation.
     * @type {string}
     * @memberof ProviderAccountRefreshRequest
     */
    configName: string;
    /**
     * Comma separated providerAccountIds.
     * @type {Array<number>}
     * @memberof ProviderAccountRefreshRequest
     */
    providerAccountIds: Array<number>;
}
/**
 * 
 * @export
 * @interface ProviderAccountRequest
 */
export interface ProviderAccountRequest {
    /**
     * Consent Id generated for the request through POST Consent.<br><br><b>Endpoints</b>:<ul><li>POST Provider Account</li><li>PUT Provider Account</li></ul>
     * @type {number}
     * @memberof ProviderAccountRequest
     */
    consentId?: number;
    /**
     * 
     * @type {ProviderAccountPreferences}
     * @memberof ProviderAccountRequest
     */
    preferences?: ProviderAccountPreferences;
    /**
     * 
     * @type {string}
     * @memberof ProviderAccountRequest
     */
    aggregationSource?: ProviderAccountRequest.AggregationSourceEnum;
    /**
     * 
     * @type {Array<Field>}
     * @memberof ProviderAccountRequest
     */
    field: Array<Field>;
}

/**
 * @export
 * @namespace ProviderAccountRequest
 */
export namespace ProviderAccountRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum AggregationSourceEnum {
        SYSTEM = <any> 'SYSTEM',
        USER = <any> 'USER'
    }
}
/**
 * 
 * @export
 * @interface ProviderAccountResponse
 */
export interface ProviderAccountResponse {
    /**
     * 
     * @type {Array<ProviderAccount>}
     * @memberof ProviderAccountResponse
     */
    providerAccount?: Array<ProviderAccount>;
}
/**
 * 
 * @export
 * @interface ProviderAccountUserProfileResponse
 */
export interface ProviderAccountUserProfileResponse {
    /**
     * 
     * @type {Array<ProviderAccountProfile>}
     * @memberof ProviderAccountUserProfileResponse
     */
    providerAccount?: Array<ProviderAccountProfile>;
}
/**
 * 
 * @export
 * @interface ProviderDetail
 */
export interface ProviderDetail {
    /**
     * The language in which the provider details are provided. For example, a site supports two languages English and French. English being the primary language, the provider response will be provided in French depending on the user's locale. The language follows the two letter ISO code.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {string}
     * @memberof ProviderDetail
     */
    languageISOCode?: string;
    /**
     * Favicon link of the provider.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {string}
     * @memberof ProviderDetail
     */
    favicon?: string;
    /**
     * AccountType supported by the provider, eg: Brokerage Cash, Current<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {Array<string>}
     * @memberof ProviderDetail
     */
    accountType?: Array<ProviderDetail.AccountTypeEnum>;
    /**
     * Country to which the provider belongs.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {string}
     * @memberof ProviderDetail
     */
    countryISOCode?: string;
    /**
     * Indicates that the site has been added by the user at least once.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {string}
     * @memberof ProviderDetail
     */
    isAddedByUser?: string;
    /**
     * Indicates the priority for which the service is invoked.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof ProviderDetail
     */
    PRIORITY?: ProviderDetail.PRIORITYEnum;
    /**
     * The screen-scraping providers that are associated to the Open Banking provider ID.<br><br><b>Applicable containers</b>: All Containers<br><b>Endpoints</b>:<ul><li>GET providers</li><li>GET providers/{providerId}</li></ul>
     * @type {Array<number>}
     * @memberof ProviderDetail
     */
    associatedProviderIds?: Array<number>;
    /**
     * The primary language of the site.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {string}
     * @memberof ProviderDetail
     */
    primaryLanguageISOCode?: string;
    /**
     * Text to guide user through linking an account that belongs to the site<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {string}
     * @memberof ProviderDetail
     */
    help?: string;
    /**
     * The base URL of the provider's site.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {string}
     * @memberof ProviderDetail
     */
    baseUrl?: string;
    /**
     * Capability of the site<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul><br><b>Note : </b> capability has been deprecated
     * @type {Array<Capability>}
     * @memberof ProviderDetail
     */
    capability?: Array<Capability>;
    /**
     * This entity represents the structure of the login or MFA form that is displayed to the user at the provider site. For performance reasons, this field is returned only when a single provider is requested in the request.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li></ul>
     * @type {Array<LoginForm>}
     * @memberof ProviderDetail
     */
    loginForm?: Array<LoginForm>;
    /**
     * Indicates if a provider site requires consent.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {boolean}
     * @memberof ProviderDetail
     */
    isConsentRequired?: boolean;
    /**
     * The login URL of the provider's site.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {string}
     * @memberof ProviderDetail
     */
    loginUrl?: string;
    /**
     * Indicates if a provider site is auto-refreshed.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {boolean}
     * @memberof ProviderDetail
     */
    isAutoRefreshEnabled?: boolean;
    /**
     * The name of a provider site.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {string}
     * @memberof ProviderDetail
     */
    name?: string;
    /**
     * The logo link of the provider institution. The link will return the logo in the PNG format.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {string}
     * @memberof ProviderDetail
     */
    logo?: string;
    /**
     * Unique identifier for the provider site(e.g., financial institution sites, biller sites, lender sites, etc.).<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {number}
     * @memberof ProviderDetail
     */
    id?: number;
    /**
     * Determines when the provider information was updated by Yodlee. If the customer caches the data, the cache is recommended to be refreshed based on this field.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {string}
     * @memberof ProviderDetail
     */
    lastModified?: string;
    /**
     * AuthParameter appears in the response only in case of token-based aggregation sites.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {Array<string>}
     * @memberof ProviderDetail
     */
    authParameter?: Array<ProviderDetail.AuthParameterEnum>;
    /**
     * The authentication type enabled at the provider site. <br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof ProviderDetail
     */
    authType?: ProviderDetail.AuthTypeEnum;
    /**
     * Logical grouping of dataset attributes into datasets such as Basic Aggregation Data, Account Profile and Documents<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {Array<ProvidersDataset>}
     * @memberof ProviderDetail
     */
    dataset?: Array<ProvidersDataset>;
    /**
     * Determines if the provider is supported for the cobrand (customer), is in the beta stage, etc. <br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {string}
     * @memberof ProviderDetail
     */
    status?: ProviderDetail.StatusEnum;
}

/**
 * @export
 * @namespace ProviderDetail
 */
export namespace ProviderDetail {
    /**
     * @export
     * @enum {string}
     */
    export enum AccountTypeEnum {
        CURRENT = <any> 'CURRENT',
        BROKERAGECASH = <any> 'BROKERAGE_CASH'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum PRIORITYEnum {
        POPULAR = <any> 'POPULAR',
        SUGGESTED = <any> 'SUGGESTED',
        COBRAND = <any> 'COBRAND',
        SEARCH = <any> 'SEARCH',
        ALL = <any> 'ALL'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum AuthParameterEnum {
        AuthorizationCode = <any> 'authorizationCode',
        IdToken = <any> 'idToken',
        AuthResponse = <any> 'authResponse',
        State = <any> 'state'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum AuthTypeEnum {
        OAUTH = <any> 'OAUTH',
        CREDENTIALS = <any> 'CREDENTIALS',
        MFACREDENTIALS = <any> 'MFA_CREDENTIALS'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Supported = <any> 'Supported',
        Beta = <any> 'Beta',
        Unsupported = <any> 'Unsupported'
    }
}
/**
 * 
 * @export
 * @interface ProviderDetailResponse
 */
export interface ProviderDetailResponse {
    /**
     * 
     * @type {Array<ProviderDetail>}
     * @memberof ProviderDetailResponse
     */
    provider?: Array<ProviderDetail>;
}
/**
 * 
 * @export
 * @interface ProviderResponse
 */
export interface ProviderResponse {
    /**
     * 
     * @type {Array<Providers>}
     * @memberof ProviderResponse
     */
    provider?: Array<Providers>;
}
/**
 * 
 * @export
 * @interface Providers
 */
export interface Providers {
    /**
     * The language in which the provider details are provided. For example, a site supports two languages English and French. English being the primary language, the provider response will be provided in French depending on the user's locale. The language follows the two letter ISO code.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {string}
     * @memberof Providers
     */
    languageISOCode?: string;
    /**
     * The forget password URL of the provider site.<br><br><b>Endpoints</b>:<ul><li>GET providers</li></ul>
     * @type {string}
     * @memberof Providers
     */
    forgetPasswordUrl?: string;
    /**
     * Favicon link of the provider.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {string}
     * @memberof Providers
     */
    favicon?: string;
    /**
     * AccountType supported by the provider, eg: Brokerage Cash, Current<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {Array<string>}
     * @memberof Providers
     */
    accountType?: Array<Providers.AccountTypeEnum>;
    /**
     * Country to which the provider belongs.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {string}
     * @memberof Providers
     */
    countryISOCode?: string;
    /**
     * Indicates that the site has been added by the user at least once.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {string}
     * @memberof Providers
     */
    isAddedByUser?: string;
    /**
     * Indicates the priority for which the service is invoked.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof Providers
     */
    PRIORITY?: Providers.PRIORITYEnum;
    /**
     * The screen-scraping providers that are associated to the Open Banking provider ID.<br><br><b>Applicable containers</b>: All Containers<br><b>Endpoints</b>:<ul><li>GET providers</li><li>GET providers/{providerId}</li></ul>
     * @type {Array<number>}
     * @memberof Providers
     */
    associatedProviderIds?: Array<number>;
    /**
     * Help text to guide the user to choose the correct provider site.<br><br><b>Endpoints</b>:<ul><li>GET providers</li></ul>
     * @type {string}
     * @memberof Providers
     */
    loginHelp?: string;
    /**
     * The primary language of the site.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {string}
     * @memberof Providers
     */
    primaryLanguageISOCode?: string;
    /**
     * Text to guide user through linking an account that belongs to the site<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {string}
     * @memberof Providers
     */
    help?: string;
    /**
     * The base URL of the provider's site.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {string}
     * @memberof Providers
     */
    baseUrl?: string;
    /**
     * Capability of the site<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul><br><b>Note : </b> capability has been deprecated
     * @type {Array<Capability>}
     * @memberof Providers
     */
    capability?: Array<Capability>;
    /**
     * Indicates if a provider site requires consent.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {boolean}
     * @memberof Providers
     */
    isConsentRequired?: boolean;
    /**
     * The login URL of the provider's site.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {string}
     * @memberof Providers
     */
    loginUrl?: string;
    /**
     * Indicates if a provider site is auto-refreshed.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {boolean}
     * @memberof Providers
     */
    isAutoRefreshEnabled?: boolean;
    /**
     * The name of a provider site.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {string}
     * @memberof Providers
     */
    name?: string;
    /**
     * The logo link of the provider institution. The link will return the logo in the PNG format.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {string}
     * @memberof Providers
     */
    logo?: string;
    /**
     * Unique identifier for the provider site(e.g., financial institution sites, biller sites, lender sites, etc.).<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {number}
     * @memberof Providers
     */
    id?: number;
    /**
     * Determines when the provider information was updated by Yodlee. If the customer caches the data, the cache is recommended to be refreshed based on this field.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {string}
     * @memberof Providers
     */
    lastModified?: string;
    /**
     * AuthParameter appears in the response only in case of token-based aggregation sites.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {Array<string>}
     * @memberof Providers
     */
    authParameter?: Array<Providers.AuthParameterEnum>;
    /**
     * The authentication type enabled at the provider site. <br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof Providers
     */
    authType?: Providers.AuthTypeEnum;
    /**
     * Logical grouping of dataset attributes into datasets such as Basic Aggregation Data, Account Profile and Documents<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {Array<ProvidersDataset>}
     * @memberof Providers
     */
    dataset?: Array<ProvidersDataset>;
    /**
     * Determines if the provider is supported for the cobrand (customer), is in the beta stage, etc. <br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {string}
     * @memberof Providers
     */
    status?: Providers.StatusEnum;
}

/**
 * @export
 * @namespace Providers
 */
export namespace Providers {
    /**
     * @export
     * @enum {string}
     */
    export enum AccountTypeEnum {
        CURRENT = <any> 'CURRENT',
        BROKERAGECASH = <any> 'BROKERAGE_CASH'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum PRIORITYEnum {
        POPULAR = <any> 'POPULAR',
        SUGGESTED = <any> 'SUGGESTED',
        COBRAND = <any> 'COBRAND',
        SEARCH = <any> 'SEARCH',
        ALL = <any> 'ALL'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum AuthParameterEnum {
        AuthorizationCode = <any> 'authorizationCode',
        IdToken = <any> 'idToken',
        AuthResponse = <any> 'authResponse',
        State = <any> 'state'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum AuthTypeEnum {
        OAUTH = <any> 'OAUTH',
        CREDENTIALS = <any> 'CREDENTIALS',
        MFACREDENTIALS = <any> 'MFA_CREDENTIALS'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Supported = <any> 'Supported',
        Beta = <any> 'Beta',
        Unsupported = <any> 'Unsupported'
    }
}
/**
 * 
 * @export
 * @interface ProvidersCount
 */
export interface ProvidersCount {
    /**
     * 
     * @type {TotalCount}
     * @memberof ProvidersCount
     */
    TOTAL?: TotalCount;
}
/**
 * 
 * @export
 * @interface ProvidersCountResponse
 */
export interface ProvidersCountResponse {
    /**
     * 
     * @type {ProvidersCount}
     * @memberof ProvidersCountResponse
     */
    provider?: ProvidersCount;
}
/**
 * 
 * @export
 * @interface ProvidersDataset
 */
export interface ProvidersDataset {
    /**
     * The name of the dataset requested from the provider site<br><br><b>Account Type</b>: Manual<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li><li>GET providers/{providerId}</li><li>GET providers</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof ProvidersDataset
     */
    name?: ProvidersDataset.NameEnum;
    /**
     * The name of the dataset attribute suported by the provider.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
     * @type {Array<Attribute>}
     * @memberof ProvidersDataset
     */
    attribute?: Array<Attribute>;
}

/**
 * @export
 * @namespace ProvidersDataset
 */
export namespace ProvidersDataset {
    /**
     * @export
     * @enum {string}
     */
    export enum NameEnum {
        BASICAGGDATA = <any> 'BASIC_AGG_DATA',
        ADVANCEAGGDATA = <any> 'ADVANCE_AGG_DATA',
        ACCTPROFILE = <any> 'ACCT_PROFILE',
        DOCUMENT = <any> 'DOCUMENT'
    }
}
/**
 * 
 * @export
 * @interface RefreshProviderAccountResponse
 */
export interface RefreshProviderAccountResponse {
    /**
     * 
     * @type {Array<StatusLink>}
     * @memberof RefreshProviderAccountResponse
     */
    statusLink?: Array<StatusLink>;
}
/**
 * 
 * @export
 * @interface RewardBalance
 */
export interface RewardBalance {
    /**
     * The date on which the balance expires.<br><br><b>Account Type</b>: Aggregated<br><b>Applicable containers</b>: reward<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof RewardBalance
     */
    expiryDate?: string;
    /**
     * The balance required to qualify for a reward such as retaining membership, business reward, etc.<br><br><b>Account Type</b>: Aggregated<br><b>Applicable containers</b>: reward<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof RewardBalance
     */
    balanceToReward?: string;
    /**
     * The type of reward balance.<br><br><b>Account Type</b>: Aggregated<br><b>Applicable containers</b>: reward<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof RewardBalance
     */
    balanceType?: RewardBalance.BalanceTypeEnum;
    /**
     * The actual reward balance.<br><br><b>Account Type</b>: Aggregated<br><b>Applicable containers</b>: reward<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {number}
     * @memberof RewardBalance
     */
    balance?: number;
    /**
     * The description for the reward balance as available at provider source.<br><br><b>Account Type</b>: Aggregated<br><b>Applicable containers</b>: reward<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof RewardBalance
     */
    description?: string;
    /**
     * The balance required to reach a reward level.<br><br><b>Account Type</b>: Aggregated<br><b>Applicable containers</b>: reward<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof RewardBalance
     */
    balanceToLevel?: string;
    /**
     * Unit of reward balance - miles, points, segments, dollars, credits.<br><br><b>Account Type</b>: Aggregated<br><b>Applicable containers</b>: reward<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof RewardBalance
     */
    units?: string;
}

/**
 * @export
 * @namespace RewardBalance
 */
export namespace RewardBalance {
    /**
     * @export
     * @enum {string}
     */
    export enum BalanceTypeEnum {
        EXPIRINGBALANCE = <any> 'EXPIRING_BALANCE',
        BALANCETOLEVEL = <any> 'BALANCE_TO_LEVEL',
        BALANCETOREWARD = <any> 'BALANCE_TO_REWARD',
        BALANCE = <any> 'BALANCE',
        TOTALBALANCE = <any> 'TOTAL_BALANCE'
    }
}
/**
 * 
 * @export
 * @interface Row
 */
export interface Row {
    /**
     * Fields that belong to a particular choice are collected together using this field.<br><b>Recommendations</b>: All the field row choices label to be grouped and displayed as options to the customer. On choosing a particular choice field, we recommend displaying the fields relevant to them. First field choice could be selected by default.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts/{providerAccountId}</li><li>GET providers/{providerId}</li></ul>
     * @type {string}
     * @memberof Row
     */
    fieldRowChoice?: string;
    /**
     * Details of fields that belong to the row.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts/{providerAccountId}</li><li>GET providers/{providerId}</li></ul>
     * @type {Array<Field>}
     * @memberof Row
     */
    field?: Array<Field>;
    /**
     * Form denotes the set of the fields that are related. <br><br><b>Endpoints</b>:<ul><li>GET providerAccounts/{providerAccountId}</li><li>GET providers/{providerId}</li></ul>
     * @type {string}
     * @memberof Row
     */
    form?: string;
    /**
     * Unique identifier of the row.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts/{providerAccountId}</li><li>GET providers/{providerId}</li></ul>
     * @type {string}
     * @memberof Row
     */
    id?: string;
    /**
     * The label text displayed for a row in the form.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts/{providerAccountId}</li><li>GET providers/{providerId}</li></ul>
     * @type {string}
     * @memberof Row
     */
    label?: string;
}
/**
 * 
 * @export
 * @interface RuleClause
 */
export interface RuleClause {
    /**
     * Field for which the clause is created.<br><br><br><b>Valid Values</b>:amount,description<b>Applicable containers</b>: creditCard, investment, insurance, loan<br>
     * @type {string}
     * @memberof RuleClause
     */
    field?: RuleClause.FieldEnum;
    /**
     * Unique identifier generated for every rule the user creates.<br><br><b>Applicable containers</b>: creditCard, investment, insurance, loan<br>
     * @type {number}
     * @memberof RuleClause
     */
    userDefinedRuleId?: number;
    /**
     * The value would be the amount value in case of amount based rule clause or the string value in case of description based rule clause.<br><br><b>Applicable containers</b>: creditCard, investment, insurance, loan<br>
     * @type {string}
     * @memberof RuleClause
     */
    fieldValue?: string;
    /**
     * Operation for which the clause is created.<br><br><b>Applicable containers</b>: creditCard, investment, insurance, loan<br>
     * @type {string}
     * @memberof RuleClause
     */
    operation?: RuleClause.OperationEnum;
    /**
     * Unique identifier generated for the rule clause.<br><br><b>Applicable containers</b>: creditCard, investment, insurance, loan<br>
     * @type {number}
     * @memberof RuleClause
     */
    ruleClauseId?: number;
}

/**
 * @export
 * @namespace RuleClause
 */
export namespace RuleClause {
    /**
     * @export
     * @enum {string}
     */
    export enum FieldEnum {
        Amount = <any> 'amount',
        Description = <any> 'description'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum OperationEnum {
        NumberEquals = <any> 'numberEquals',
        NumberLessThan = <any> 'numberLessThan',
        NumberLessThanEquals = <any> 'numberLessThanEquals',
        NumberGreaterThan = <any> 'numberGreaterThan',
        NumberGreaterThanEquals = <any> 'numberGreaterThanEquals',
        StringEquals = <any> 'stringEquals',
        StringContains = <any> 'stringContains'
    }
}
/**
 * 
 * @export
 * @interface Security
 */
export interface Security {
    /**
     * Securities exchange provide the securities information at the corresponding exchanges. <br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {Array<StockExchangeDetail>}
     * @memberof Security
     */
    stockExchangeDetails?: Array<StockExchangeDetail>;
    /**
     * Price units corresponding to the security style. This is used to derive actual price of the security from market value.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {number}
     * @memberof Security
     */
    issueTypeMultiplier?: number;
    /**
     * The state in which the security is taxed.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {boolean}
     * @memberof Security
     */
    stateTaxable?: boolean;
    /**
     * Next call date of the security.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof Security
     */
    callDate?: string;
    /**
     * cdsc fund flag of the security.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {boolean}
     * @memberof Security
     */
    cdscFundFlag?: boolean;
    /**
     * A CUSIP is a nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof Security
     */
    cusip?: string;
    /**
     * Flag indicating federal taxable.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {boolean}
     * @memberof Security
     */
    federalTaxable?: boolean;
    /**
     * Unique identifier for S&P rating on Envestnet platform.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof Security
     */
    sAndPRating?: string;
    /**
     * Share class of the security.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof Security
     */
    shareClass?: string;
    /**
     * Flag indicating a dummy security.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {boolean}
     * @memberof Security
     */
    isEnvestnetDummySecurity?: boolean;
    /**
     * The description (name) of the security. For example, Cisco Systems.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof Security
     */
    description?: string;
    /**
     * Minimum purchase of security.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {number}
     * @memberof Security
     */
    minimumPurchase?: number;
    /**
     * Indicates the type of security like stocks, mutual fund, etc. <br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof Security
     */
    type?: string;
    /**
     * First coupon date of security.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof Security
     */
    firstCouponDate?: string;
    /**
     * Coupon Frequency.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {number}
     * @memberof Security
     */
    frequency?: number;
    /**
     * The method in which interest is accrued or earned.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof Security
     */
    accrualMethod?: string;
    /**
     * ISO 4217 currency code indicating income currency of the security.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof Security
     */
    incomeCurrency?: string;
    /**
     * Maturity date of the security.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof Security
     */
    maturityDate?: string;
    /**
     * Next call price of the security.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {number}
     * @memberof Security
     */
    callPrice?: number;
    /**
     * The unique identifier of the security.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {number}
     * @memberof Security
     */
    id?: number;
    /**
     * Issue date of the security.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof Security
     */
    issueDate?: string;
    /**
     * Identifier of the sector to which the security belongs to.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof Security
     */
    sector?: string;
    /**
     * Agency factor of the security.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {number}
     * @memberof Security
     */
    agencyFactor?: number;
    /**
     * The rate of interest paid annually, expressed as a percentage of the bond's par or face value.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {number}
     * @memberof Security
     */
    interestRate?: number;
    /**
     * The last updated date of the security.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof Security
     */
    lastModifiedDate?: string;
    /**
     * GICS Sector is a categorization the S&P assigns to all publically traded companies. <br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof Security
     */
    gicsSector?: string;
    /**
     * <b>true</b>:Closed for all investors , <b>false</b>: Open to all investors.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {boolean}
     * @memberof Security
     */
    closedFlag?: boolean;
    /**
     * The Stock Exchange Daily Official List (SEDOL) is a set of security identifiers used in the United Kingdom and Ireland for clearing purposes.<br><b>Note</b>: The SEDOL field is only applicable to the trade related transactions.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof Security
     */
    sedol?: string;
    /**
     * GICS sector ID to which the security belongs to.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof Security
     */
    subSector?: string;
    /**
     * Last coupon date of security.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof Security
     */
    lastCouponDate?: string;
    /**
     * Indicates whether the security is a simulated security.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {boolean}
     * @memberof Security
     */
    isSyntheticSecurity?: boolean;
    /**
     * ISO 4217 currency code indicating trading currency of the security.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof Security
     */
    tradeCurrencyCode?: string;
    /**
     * Indicates whether the security is a dummy security.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {boolean}
     * @memberof Security
     */
    isDummySecurity?: boolean;
    /**
     * Unique identifier for Moody rating on Envestnet platform.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof Security
     */
    moodyRating?: string;
    /**
     * Classification of the style for the security.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof Security
     */
    style?: string;
    /**
     * <b>1</b>- indicates Eligible,<b>0</b>- indicates firm is not eligible.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof Security
     */
    firmEligible?: string;
    /**
     * Mutual Fund Family Name.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof Security
     */
    fundFamily?: string;
    /**
     * The International Securities Identification Number (ISIN) is used worldwide to identify specific securities. It is equivalent to CUSIP for international markets.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof Security
     */
    isin?: string;
}
/**
 * 
 * @export
 * @interface SecurityHolding
 */
export interface SecurityHolding {
    /**
     * 
     * @type {Security}
     * @memberof SecurityHolding
     */
    security?: Security;
    /**
     * 
     * @type {string}
     * @memberof SecurityHolding
     */
    id?: string;
}
/**
 * 
 * @export
 * @interface Statement
 */
export interface Statement {
    /**
     * The APR applied to the balance on the credit card account, as available in the statement.<br><b>Note:</b> In case of variable APR, the APR available on the statement might differ from the APR available at the account-level.<br><br><b>Applicable containers</b>: creditCard, loan, insurance<br>
     * @type {number}
     * @memberof Statement
     */
    apr?: number;
    /**
     * The APR applicable to cash withdrawals on the credit card account.<br><br><b>Applicable containers</b>: creditCard, loan, insurance<br>
     * @type {number}
     * @memberof Statement
     */
    cashApr?: number;
    /**
     * The start date of the statement period.<br><br><b>Applicable containers</b>: creditCard, loan, insurance<br>
     * @type {string}
     * @memberof Statement
     */
    billingPeriodStart?: string;
    /**
     * The date by when the minimum payment is due to be paid.<br><b>Note:</b> The due date that appears in the statement may differ from the due date at the account-level.<br><br><b>Applicable containers</b>: creditCard, loan, insurance<br>
     * @type {string}
     * @memberof Statement
     */
    dueDate?: string;
    /**
     * 
     * @type {Money}
     * @memberof Statement
     */
    interestAmount?: Money;
    /**
     * The date on which the statement is generated.<br><br><b>Applicable containers</b>: creditCard, loan, insurance<br>
     * @type {string}
     * @memberof Statement
     */
    statementDate?: string;
    /**
     * 
     * @type {Money}
     * @memberof Statement
     */
    cashAdvance?: Money;
    /**
     * The end date of the statement period.<br><br><b>Applicable containers</b>: creditCard, loan, insurance<br>
     * @type {string}
     * @memberof Statement
     */
    billingPeriodEnd?: string;
    /**
     * 
     * @type {Money}
     * @memberof Statement
     */
    principalAmount?: Money;
    /**
     * 
     * @type {Money}
     * @memberof Statement
     */
    loanBalance?: Money;
    /**
     * 
     * @type {Money}
     * @memberof Statement
     */
    amountDue?: Money;
    /**
     * Account to which the statement belongs to.<br><br><b>Applicable containers</b>: creditCard, loan, insurance<br>
     * @type {number}
     * @memberof Statement
     */
    accountId?: number;
    /**
     * The date when the account was last updated by Yodlee.<br><br><b>Applicable containers</b>: creditCard, loan, insurance<br>
     * @type {string}
     * @memberof Statement
     */
    lastUpdated?: string;
    /**
     * The field is set to true if the statement is the latest generated statement.<br><br><b>Applicable containers</b>: creditCard, loan, insurance<br>
     * @type {boolean}
     * @memberof Statement
     */
    isLatest?: boolean;
    /**
     * 
     * @type {Money}
     * @memberof Statement
     */
    minimumPayment?: Money;
    /**
     * The date on which the last payment was done during the billing cycle.<br><br><b>Applicable containers</b>: creditCard, loan, insurance<br>
     * @type {string}
     * @memberof Statement
     */
    lastPaymentDate?: string;
    /**
     * 
     * @type {Money}
     * @memberof Statement
     */
    lastPaymentAmount?: Money;
    /**
     * Unique identifier for the statement.<br><br><b>Applicable containers</b>: creditCard, loan, insurance<br>
     * @type {number}
     * @memberof Statement
     */
    id?: number;
    /**
     * 
     * @type {Money}
     * @memberof Statement
     */
    newCharges?: Money;
}
/**
 * 
 * @export
 * @interface StatementResponse
 */
export interface StatementResponse {
    /**
     * 
     * @type {Array<Statement>}
     * @memberof StatementResponse
     */
    statement?: Array<Statement>;
}
/**
 * 
 * @export
 * @interface StatusLink
 */
export interface StatusLink {
    /**
     * 
     * @type {string}
     * @memberof StatusLink
     */
    methodType?: string;
    /**
     * 
     * @type {string}
     * @memberof StatusLink
     */
    rel?: string;
    /**
     * 
     * @type {string}
     * @memberof StatusLink
     */
    href?: string;
}
/**
 * 
 * @export
 * @interface StockExchangeDetail
 */
export interface StockExchangeDetail {
    /**
     * Ticker symbol representing particular securities listed on an exchange.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof StockExchangeDetail
     */
    symbol?: string;
    /**
     * Country codes are geocodes developed to represent countries and dependent areas.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof StockExchangeDetail
     */
    countryCode?: string;
    /**
     * ISO codes of currency.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof StockExchangeDetail
     */
    currencyCode?: string;
    /**
     * An Exchange code is a four-character code used to identify stock markets and other trading exchanges within global trading.<br><br><b>Applicable containers</b>: investment, insurance<br>
     * @type {string}
     * @memberof StockExchangeDetail
     */
    exchangeCode?: string;
}
/**
 * 
 * @export
 * @interface TotalCount
 */
export interface TotalCount {
    /**
     * 
     * @type {number}
     * @memberof TotalCount
     */
    count?: number;
}
/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * The value provided will be either postDate or transactionDate. postDate takes higher priority than transactionDate, except for the investment container as only transactionDate is available. The availability of postDate or transactionDate depends on the provider site.<br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br>
     * @type {string}
     * @memberof Transaction
     */
    date?: string;
    /**
     * A unique ID that the provider site has assigned to the transaction. The source ID is only available for the pre-populated accounts.<br>Pre-populated accounts are the accounts that the FI customers shares with Yodlee, so that the user does not have to add or aggregate those accounts.
     * @type {string}
     * @memberof Transaction
     */
    sourceId?: string;
    /**
     * The symbol of the security being traded.<br><b>Note</b>: The settle date field applies only to trade-related transactions. <br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof Transaction
     */
    symbol?: string;
    /**
     * The CUSIP (Committee on Uniform Securities Identification Procedures) identifies the financial instruments in the United States and Canada.<br><b><br><b>Note</b></b>: The CUSIP number field applies only to trade related transactions.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof Transaction
     */
    cusipNumber?: string;
    /**
     * The high level category assigned to the transaction. The supported values are provided by the GET transactions/categories. <br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br>
     * @type {number}
     * @memberof Transaction
     */
    highLevelCategoryId?: number;
    /**
     * The id of the detail category that is assigned to the transaction. The supported values are provided by GET transactions/categories.<br><br><b>Applicable containers</b>: bank,creditCard<br>
     * @type {number}
     * @memberof Transaction
     */
    detailCategoryId?: number;
    /**
     * 
     * @type {Description}
     * @memberof Transaction
     */
    description?: Description;
    /**
     * Additional notes provided by the user for a particular  transaction through application or API services. <br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br>
     * @type {string}
     * @memberof Transaction
     */
    memo?: string;
    /**
     * It is the date on which the transaction is finalized, that is, the date the ownership of the security is transferred to the buyer. The settlement date is usually few days after the transaction date.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof Transaction
     */
    settleDate?: string;
    /**
     * The nature of the transaction, i.e., deposit, refund, payment, etc.<br><b>Note</b>: The transaction type field is available only for the United States, Canada, United Kingdom, and India based provider sites. <br><br><b>Applicable containers</b>: bank,creditCard,investment<br>
     * @type {string}
     * @memberof Transaction
     */
    type?: string;
    /**
     * The intermediary of the transaction.<br><br><b>Applicable containers</b>:  bank,creditCard,investment,loan<br>
     * @type {Array<string>}
     * @memberof Transaction
     */
    intermediary?: Array<string>;
    /**
     * Indicates if the transaction appears as a debit or a credit transaction in the account. <br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br><b>Applicable Values</b><br>
     * @type {string}
     * @memberof Transaction
     */
    baseType?: Transaction.BaseTypeEnum;
    /**
     * Indicates the source of the category, i.e., categories derived by the system or assigned/provided by the consumer. This is the source field of the transaction category resource. The supported values are provided by the GET transactions/categories.<br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br><b>Applicable Values</b><br>
     * @type {string}
     * @memberof Transaction
     */
    categorySource?: Transaction.CategorySourceEnum;
    /**
     * 
     * @type {Money}
     * @memberof Transaction
     */
    principal?: Money;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    lastUpdated?: string;
    /**
     * 
     * @type {Money}
     * @memberof Transaction
     */
    interest?: Money;
    /**
     * 
     * @type {Money}
     * @memberof Transaction
     */
    price?: Money;
    /**
     * 
     * @type {Money}
     * @memberof Transaction
     */
    commission?: Money;
    /**
     * An unique identifier for the transaction. The combination of the id and account container are unique in the system. <br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br>
     * @type {number}
     * @memberof Transaction
     */
    id?: number;
    /**
     * Indicates the merchantType of the transaction.e.g:-BILLERS,SUBSCRIPTION,OTHERS <br><br><b>Applicable containers</b>: bank,creditCard,investment,loan<br>
     * @type {string}
     * @memberof Transaction
     */
    merchantType?: string;
    /**
     * 
     * @type {Money}
     * @memberof Transaction
     */
    amount?: Money;
    /**
     * The checkNumber of the transaction.<br><br><b>Applicable containers</b>: bank<br>
     * @type {string}
     * @memberof Transaction
     */
    checkNumber?: string;
    /**
     * Indicates if the transaction is happened online or in-store. <br><br><b>Applicable containers</b>: bank,creditCard,investment,loan<br>
     * @type {boolean}
     * @memberof Transaction
     */
    isPhysical?: boolean;
    /**
     * The quantity associated with the transaction.<br><b>Note</b>: The quantity field applies only to trade-related transactions.<br><br><b>Applicable containers</b>: investment<br>
     * @type {number}
     * @memberof Transaction
     */
    quantity?: number;
    /**
     * It is an identification number that is assigned to financial instruments such as stocks and bonds trading in Switzerland.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof Transaction
     */
    valoren?: string;
    /**
     * Indicates if the transaction is aggregated from the FI site or the consumer has manually created the transaction using the application or an API. <br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br>
     * @type {boolean}
     * @memberof Transaction
     */
    isManual?: boolean;
    /**
     * 
     * @type {Merchant}
     * @memberof Transaction
     */
    merchant?: Merchant;
    /**
     * SEDOL stands for Stock Exchange Daily Official List, a list of security identifiers used in the United Kingdom and Ireland for clearing purposes.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof Transaction
     */
    sedol?: string;
    /**
     * The date the transaction happens in the account. <br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br>
     * @type {string}
     * @memberof Transaction
     */
    transactionDate?: string;
    /**
     * The categoryType of the category assigned to the transaction. This is the type field of the transaction category resource. The supported values are provided by the GET transactions/categories.<br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br>
     * @type {string}
     * @memberof Transaction
     */
    categoryType?: Transaction.CategoryTypeEnum;
    /**
     * The account from which the transaction was made. This is basically the primary key of the account resource. <br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br>
     * @type {number}
     * @memberof Transaction
     */
    accountId?: number;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    createdDate?: string;
    /**
     * The source through which the transaction is added to the Yodlee system.<br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loann<br><b>Applicable Values:</b><br>
     * @type {string}
     * @memberof Transaction
     */
    sourceType?: Transaction.SourceTypeEnum;
    /**
     * The account's container.<br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br><b>Applicable Values</b><br>
     * @type {string}
     * @memberof Transaction
     */
    CONTAINER?: Transaction.CONTAINEREnum;
    /**
     * The date on which the transaction is posted to the account.<br><br><b>Applicable containers</b>: bank,creditCard,insurance,loan<br>
     * @type {string}
     * @memberof Transaction
     */
    postDate?: string;
    /**
     * The parentCategoryId of the category assigned to the transaction.<br><b>Note</b>: This field will be provided in the response if the transaction is assigned to a user-created category. <br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br>
     * @type {number}
     * @memberof Transaction
     */
    parentCategoryId?: number;
    /**
     * The transaction subtype field provides a detailed transaction type. For example, purchase is a transaction type and the transaction subtype field indicates if the purchase was made using a debit or credit card.<br><b>Note</b>: The transaction subtype field is available only in the United States, Canada, United Kingdom, and India.<br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br>
     * @type {string}
     * @memberof Transaction
     */
    subType?: Transaction.SubTypeEnum;
    /**
     * The name of the category assigned to the transaction. This is the category field of the transaction category resource. The supported values are provided by the GET transactions/categories.<br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br>
     * @type {string}
     * @memberof Transaction
     */
    category?: string;
    /**
     * 
     * @type {Money}
     * @memberof Transaction
     */
    runningBalance?: Money;
    /**
     * The id of the category assigned to the transaction. This is the id field of the transaction category resource. The supported values are provided by the GET transactions/categories.<br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br>
     * @type {number}
     * @memberof Transaction
     */
    categoryId?: number;
    /**
     * For transactions involving securities, this captures the securities description.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof Transaction
     */
    holdingDescription?: string;
    /**
     * International Securities Identification Number (ISIN) standard is used worldwide to identify specific securities.<br><br><b>Applicable containers</b>: investment<br>
     * @type {string}
     * @memberof Transaction
     */
    isin?: string;
    /**
     * The status of the transaction: pending or posted.<br><b>Note</b>: Most FI sites only display posted transactions. If the FI site displays transaction status, same will be aggregated.  <br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br><b>Applicable Values</b><br>
     * @type {string}
     * @memberof Transaction
     */
    status?: Transaction.StatusEnum;
}

/**
 * @export
 * @namespace Transaction
 */
export namespace Transaction {
    /**
     * @export
     * @enum {string}
     */
    export enum BaseTypeEnum {
        CREDIT = <any> 'CREDIT',
        DEBIT = <any> 'DEBIT'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum CategorySourceEnum {
        SYSTEM = <any> 'SYSTEM',
        USER = <any> 'USER'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum CategoryTypeEnum {
        TRANSFER = <any> 'TRANSFER',
        DEFERREDCOMPENSATION = <any> 'DEFERRED_COMPENSATION',
        UNCATEGORIZE = <any> 'UNCATEGORIZE',
        INCOME = <any> 'INCOME',
        EXPENSE = <any> 'EXPENSE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SourceTypeEnum {
        AGGREGATED = <any> 'AGGREGATED',
        MANUAL = <any> 'MANUAL'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum CONTAINEREnum {
        Bank = <any> 'bank',
        CreditCard = <any> 'creditCard',
        Investment = <any> 'investment',
        Insurance = <any> 'insurance',
        Loan = <any> 'loan',
        Reward = <any> 'reward',
        Bill = <any> 'bill',
        RealEstate = <any> 'realEstate',
        OtherAssets = <any> 'otherAssets',
        OtherLiabilities = <any> 'otherLiabilities'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SubTypeEnum {
        OVERDRAFTCHARGE = <any> 'OVERDRAFT_CHARGE',
        ONLINEPURCHASE = <any> 'ONLINE_PURCHASE',
        TAXPAYMENT = <any> 'TAX_PAYMENT',
        PAYMENTBYCHECK = <any> 'PAYMENT_BY_CHECK',
        ATMCASHWITHDRAWAL = <any> 'ATM_CASH_WITHDRAWAL',
        SERVICECHARGE = <any> 'SERVICE_CHARGE',
        RETURNEDCHECKCHARGE = <any> 'RETURNED_CHECK_CHARGE',
        STOPPAYMENTCHARGE = <any> 'STOP_PAYMENT_CHARGE',
        CONVENIENCEFEE = <any> 'CONVENIENCE_FEE',
        AUTOLOAN = <any> 'AUTO_LOAN',
        HOMELOANMORTGAGE = <any> 'HOME_LOAN_MORTGAGE',
        RECURRINGSUBSCRIPTIONPAYMENT = <any> 'RECURRING_SUBSCRIPTION_PAYMENT',
        INTEREST = <any> 'INTEREST',
        PAYMENT = <any> 'PAYMENT',
        PURCHASE = <any> 'PURCHASE',
        REFUND = <any> 'REFUND',
        TRANSFER = <any> 'TRANSFER',
        FINANCECHARGE = <any> 'FINANCE_CHARGE',
        OTHERCHARGESFEES = <any> 'OTHER_CHARGES_FEES',
        ANNUALFEE = <any> 'ANNUAL_FEE',
        DEPOSIT = <any> 'DEPOSIT',
        DIRECTDEPOSITSALARY = <any> 'DIRECT_DEPOSIT_SALARY',
        INVESTMENTINCOMECASH = <any> 'INVESTMENT_INCOME_CASH',
        SSA = <any> 'SSA',
        REWARDS = <any> 'REWARDS',
        TAXREFUND = <any> 'TAX_REFUND',
        CREDITCARDPAYMENT = <any> 'CREDIT_CARD_PAYMENT',
        INSURANCEPAYMENT = <any> 'INSURANCE_PAYMENT',
        UTILITIESPAYMENT = <any> 'UTILITIES_PAYMENT',
        CHILDSUPPORT = <any> 'CHILD_SUPPORT',
        LOAN = <any> 'LOAN',
        PERSONALLOAN = <any> 'PERSONAL_LOAN',
        STUDENTLOAN = <any> 'STUDENT_LOAN',
        REIMBURSEMENT = <any> 'REIMBURSEMENT',
        BALANCETRANSFER = <any> 'BALANCE_TRANSFER',
        OVERDRAFTPROTECTION = <any> 'OVERDRAFT_PROTECTION',
        CREDIT = <any> 'CREDIT',
        NSFFEES = <any> 'NSF_FEES'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        POSTED = <any> 'POSTED',
        PENDING = <any> 'PENDING',
        SCHEDULED = <any> 'SCHEDULED',
        FAILED = <any> 'FAILED',
        CLEARED = <any> 'CLEARED'
    }
}
/**
 * 
 * @export
 * @interface TransactionCategorizationRule
 */
export interface TransactionCategorizationRule {
    /**
     * Details of rules. <br><br><b>Applicable containers</b>: creditCard, investment, insurance, loan<br>
     * @type {Array<RuleClause>}
     * @memberof TransactionCategorizationRule
     */
    ruleClauses?: Array<RuleClause>;
    /**
     * Unique identifier generated for every rule the user creates.<br><br><b>Applicable containers</b>: creditCard, investment, insurance, loan<br>
     * @type {number}
     * @memberof TransactionCategorizationRule
     */
    userDefinedRuleId?: number;
    /**
     * The level of the category for which the rule is created.<br><br><b>Applicable containers</b>: creditCard, insurance, loan<br>
     * @type {number}
     * @memberof TransactionCategorizationRule
     */
    categoryLevelId?: number;
    /**
     * Category id that is assigned to the transaction when the transaction matches the rule clause. This is the id field of the transaction category resource.<br><br><b>Applicable containers</b>: creditCard, investment, insurance, loan<br>
     * @type {number}
     * @memberof TransactionCategorizationRule
     */
    transactionCategorisationId?: number;
    /**
     * Unique identifier of the user.<br><br><b>Applicable containers</b>: creditCard, investment, insurance, loan<br>
     * @type {number}
     * @memberof TransactionCategorizationRule
     */
    memId?: number;
    /**
     * The order in which the rules get executed on transactions.<br><br><b>Applicable containers</b>: creditCard, investment, insurance, loan<br>
     * @type {number}
     * @memberof TransactionCategorizationRule
     */
    rulePriority?: number;
}
/**
 * 
 * @export
 * @interface TransactionCategorizationRuleInfo
 */
export interface TransactionCategorizationRuleInfo {
    /**
     * 
     * @type {Array<FieldOperation>}
     * @memberof TransactionCategorizationRuleInfo
     */
    ruleClause: Array<FieldOperation>;
    /**
     * 
     * @type {string}
     * @memberof TransactionCategorizationRuleInfo
     */
    source?: TransactionCategorizationRuleInfo.SourceEnum;
    /**
     * 
     * @type {number}
     * @memberof TransactionCategorizationRuleInfo
     */
    priority?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionCategorizationRuleInfo
     */
    categoryId: number;
}

/**
 * @export
 * @namespace TransactionCategorizationRuleInfo
 */
export namespace TransactionCategorizationRuleInfo {
    /**
     * @export
     * @enum {string}
     */
    export enum SourceEnum {
        SYSTEM = <any> 'SYSTEM',
        USER = <any> 'USER'
    }
}
/**
 * 
 * @export
 * @interface TransactionCategorizationRuleRequest
 */
export interface TransactionCategorizationRuleRequest {
    /**
     * 
     * @type {TransactionCategorizationRuleInfo}
     * @memberof TransactionCategorizationRuleRequest
     */
    rule: TransactionCategorizationRuleInfo;
}
/**
 * 
 * @export
 * @interface TransactionCategorizationRuleResponse
 */
export interface TransactionCategorizationRuleResponse {
    /**
     * 
     * @type {Array<TransactionCategorizationRule>}
     * @memberof TransactionCategorizationRuleResponse
     */
    txnRules?: Array<TransactionCategorizationRule>;
}
/**
 * 
 * @export
 * @interface TransactionCategory
 */
export interface TransactionCategory {
    /**
     * The name of the high level category. A group of similar transaction categories are clubbed together to form a high-level category.<br><br><b>Applicable containers</b>: creditCard, investment, insurance, loan<br>
     * @type {string}
     * @memberof TransactionCategory
     */
    highLevelCategoryName?: string;
    /**
     * A attribute which will always hold the first value(initial name) of Yodlee defined highLevelCategoryName attribute.<br><br><b>Applicable containers</b>: creditCard, investment, insurance, loan<br>
     * @type {string}
     * @memberof TransactionCategory
     */
    defaultHighLevelCategoryName?: string;
    /**
     * The unique identifier of the high level category.<br><br><b>Applicable containers</b>: creditCard, investment, insurance, loan<br>
     * @type {number}
     * @memberof TransactionCategory
     */
    highLevelCategoryId?: number;
    /**
     * Entity that provides detail category attributes<br><br><b>Applicable containers</b>: creditCard, investment, insurance, loan<br>
     * @type {Array<DetailCategory>}
     * @memberof TransactionCategory
     */
    detailCategory?: Array<DetailCategory>;
    /**
     * Unique identifier of the category.<br><br><b>Applicable containers</b>: creditCard, investment, insurance, loan<br>
     * @type {number}
     * @memberof TransactionCategory
     */
    id?: number;
    /**
     * Source used to identify whether the transaction category is user defined category or system created category.<br><br><b>Applicable containers</b>: creditCard, investment, insurance, loan<br><b>Applicable Values</b><br>
     * @type {string}
     * @memberof TransactionCategory
     */
    source?: TransactionCategory.SourceEnum;
    /**
     * The name of the category.<br><b>Note</b>: Transaction categorization is one of the core features offered by Yodlee and the categories are assigned to the transactions by the system. Transactions can be clubbed together by the category that is assigned to them.  <br><br><b>Applicable containers</b>: creditCard, investment, insurance, loan<br>
     * @type {string}
     * @memberof TransactionCategory
     */
    category?: string;
    /**
     * Category Classification.<br><br><b>Applicable containers</b>: creditCard, investment, insurance, loan<br><b>Applicable Values</b><br>
     * @type {string}
     * @memberof TransactionCategory
     */
    classification?: TransactionCategory.ClassificationEnum;
    /**
     * Transaction categories and high-level categories are further mapped to five transaction category types. Customers, based on their needs can either use the transaction categories, the high-level categories, or the transaction category types. <br><br><b>Applicable containers</b>: creditCard, investment, insurance, loan<br><b>Applicable Values</b><br>
     * @type {string}
     * @memberof TransactionCategory
     */
    type?: TransactionCategory.TypeEnum;
    /**
     * A attribute which will always hold the first value(initial name) of Yodlee defined category attribute.<br><br><b>Applicable containers</b>: creditCard, investment, insurance, loan<br>
     * @type {string}
     * @memberof TransactionCategory
     */
    defaultCategoryName?: string;
}

/**
 * @export
 * @namespace TransactionCategory
 */
export namespace TransactionCategory {
    /**
     * @export
     * @enum {string}
     */
    export enum SourceEnum {
        SYSTEM = <any> 'SYSTEM',
        USER = <any> 'USER'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ClassificationEnum {
        PERSONAL = <any> 'PERSONAL',
        BUSINESS = <any> 'BUSINESS'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        TRANSFER = <any> 'TRANSFER',
        DEFERREDCOMPENSATION = <any> 'DEFERRED_COMPENSATION',
        UNCATEGORIZE = <any> 'UNCATEGORIZE',
        INCOME = <any> 'INCOME',
        EXPENSE = <any> 'EXPENSE'
    }
}
/**
 * 
 * @export
 * @interface TransactionCategoryRequest
 */
export interface TransactionCategoryRequest {
    /**
     * 
     * @type {number}
     * @memberof TransactionCategoryRequest
     */
    parentCategoryId: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionCategoryRequest
     */
    source?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionCategoryRequest
     */
    categoryName?: string;
}
/**
 * 
 * @export
 * @interface TransactionCategoryResponse
 */
export interface TransactionCategoryResponse {
    /**
     * 
     * @type {Array<TransactionCategory>}
     * @memberof TransactionCategoryResponse
     */
    transactionCategory?: Array<TransactionCategory>;
}
/**
 * 
 * @export
 * @interface TransactionCount
 */
export interface TransactionCount {
    /**
     * 
     * @type {TransactionTotal}
     * @memberof TransactionCount
     */
    TOTAL?: TransactionTotal;
}
/**
 * 
 * @export
 * @interface TransactionCountResponse
 */
export interface TransactionCountResponse {
    /**
     * 
     * @type {TransactionCount}
     * @memberof TransactionCountResponse
     */
    transaction?: TransactionCount;
}
/**
 * 
 * @export
 * @interface TransactionDays
 */
export interface TransactionDays {
    /**
     * 
     * @type {Array<string>}
     * @memberof TransactionDays
     */
    fullAccountNumberFields?: Array<TransactionDays.FullAccountNumberFieldsEnum>;
    /**
     * 
     * @type {number}
     * @memberof TransactionDays
     */
    numberOfTransactionDays?: number;
}

/**
 * @export
 * @namespace TransactionDays
 */
export namespace TransactionDays {
    /**
     * @export
     * @enum {string}
     */
    export enum FullAccountNumberFieldsEnum {
        PaymentAccountNumber = <any> 'paymentAccountNumber',
        UnmaskedAccountNumber = <any> 'unmaskedAccountNumber'
    }
}
/**
 * 
 * @export
 * @interface TransactionRequest
 */
export interface TransactionRequest {
    /**
     * 
     * @type {UpdateTransaction}
     * @memberof TransactionRequest
     */
    transaction: UpdateTransaction;
}
/**
 * 
 * @export
 * @interface TransactionResponse
 */
export interface TransactionResponse {
    /**
     * 
     * @type {Array<Transaction>}
     * @memberof TransactionResponse
     */
    transaction?: Array<Transaction>;
}
/**
 * 
 * @export
 * @interface TransactionTotal
 */
export interface TransactionTotal {
    /**
     * 
     * @type {number}
     * @memberof TransactionTotal
     */
    count?: number;
}
/**
 * 
 * @export
 * @interface UpdateAccountInfo
 */
export interface UpdateAccountInfo {
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountInfo
     */
    container?: UpdateAccountInfo.ContainerEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountInfo
     */
    includeInNetWorth?: string;
    /**
     * 
     * @type {AccountAddress}
     * @memberof UpdateAccountInfo
     */
    address?: AccountAddress;
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountInfo
     */
    accountName?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountInfo
     */
    dueDate?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountInfo
     */
    memo?: string;
    /**
     * 
     * @type {Money}
     * @memberof UpdateAccountInfo
     */
    homeValue?: Money;
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountInfo
     */
    accountNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountInfo
     */
    frequency?: UpdateAccountInfo.FrequencyEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountInfo
     */
    accountStatus?: UpdateAccountInfo.AccountStatusEnum;
    /**
     * 
     * @type {Money}
     * @memberof UpdateAccountInfo
     */
    amountDue?: Money;
    /**
     * List of loan accounts to which a real-estate account is linked.
     * @type {Array<number>}
     * @memberof UpdateAccountInfo
     */
    linkedAccountIds?: Array<number>;
    /**
     * 
     * @type {Money}
     * @memberof UpdateAccountInfo
     */
    balance?: Money;
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountInfo
     */
    isEbillEnrolled?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountInfo
     */
    nickname?: string;
}

/**
 * @export
 * @namespace UpdateAccountInfo
 */
export namespace UpdateAccountInfo {
    /**
     * @export
     * @enum {string}
     */
    export enum ContainerEnum {
        Bank = <any> 'bank',
        CreditCard = <any> 'creditCard',
        Investment = <any> 'investment',
        Insurance = <any> 'insurance',
        Loan = <any> 'loan',
        Reward = <any> 'reward',
        Bill = <any> 'bill',
        RealEstate = <any> 'realEstate',
        OtherAssets = <any> 'otherAssets',
        OtherLiabilities = <any> 'otherLiabilities'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum FrequencyEnum {
        DAILY = <any> 'DAILY',
        ONETIME = <any> 'ONE_TIME',
        WEEKLY = <any> 'WEEKLY',
        EVERY2WEEKS = <any> 'EVERY_2_WEEKS',
        SEMIMONTHLY = <any> 'SEMI_MONTHLY',
        MONTHLY = <any> 'MONTHLY',
        QUARTERLY = <any> 'QUARTERLY',
        SEMIANNUALLY = <any> 'SEMI_ANNUALLY',
        ANNUALLY = <any> 'ANNUALLY',
        EVERY2MONTHS = <any> 'EVERY_2_MONTHS',
        EBILL = <any> 'EBILL',
        FIRSTDAYMONTHLY = <any> 'FIRST_DAY_MONTHLY',
        LASTDAYMONTHLY = <any> 'LAST_DAY_MONTHLY',
        EVERY4WEEKS = <any> 'EVERY_4_WEEKS',
        UNKNOWN = <any> 'UNKNOWN',
        OTHER = <any> 'OTHER'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum AccountStatusEnum {
        ACTIVE = <any> 'ACTIVE',
        INACTIVE = <any> 'INACTIVE',
        TOBECLOSED = <any> 'TO_BE_CLOSED',
        CLOSED = <any> 'CLOSED',
        DELETED = <any> 'DELETED'
    }
}
/**
 * 
 * @export
 * @interface UpdateAccountRequest
 */
export interface UpdateAccountRequest {
    /**
     * 
     * @type {UpdateAccountInfo}
     * @memberof UpdateAccountRequest
     */
    account: UpdateAccountInfo;
}
/**
 * 
 * @export
 * @interface UpdateCategoryRequest
 */
export interface UpdateCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateCategoryRequest
     */
    highLevelCategoryName?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateCategoryRequest
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateCategoryRequest
     */
    source: UpdateCategoryRequest.SourceEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateCategoryRequest
     */
    categoryName?: string;
}

/**
 * @export
 * @namespace UpdateCategoryRequest
 */
export namespace UpdateCategoryRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum SourceEnum {
        SYSTEM = <any> 'SYSTEM',
        USER = <any> 'USER'
    }
}
/**
 * 
 * @export
 * @interface UpdateCobrandNotificationEvent
 */
export interface UpdateCobrandNotificationEvent {
    /**
     * URL to which the notification should be posted.<br><br><b>Endpoints</b>:<ul><li>GET cobrand/config/notifications/events</li></ul>
     * @type {string}
     * @memberof UpdateCobrandNotificationEvent
     */
    callbackUrl?: string;
}
/**
 * 
 * @export
 * @interface UpdateCobrandNotificationEventRequest
 */
export interface UpdateCobrandNotificationEventRequest {
    /**
     * 
     * @type {UpdateCobrandNotificationEvent}
     * @memberof UpdateCobrandNotificationEventRequest
     */
    event: UpdateCobrandNotificationEvent;
}
/**
 * 
 * @export
 * @interface UpdateConfigsNotificationEvent
 */
export interface UpdateConfigsNotificationEvent {
    /**
     * URL to which the notification should be posted.<br><br><b>Endpoints</b>:<ul><li>GET configs/notifications/events</li></ul>
     * @type {string}
     * @memberof UpdateConfigsNotificationEvent
     */
    callbackUrl?: string;
}
/**
 * 
 * @export
 * @interface UpdateConfigsNotificationEventRequest
 */
export interface UpdateConfigsNotificationEventRequest {
    /**
     * 
     * @type {UpdateConfigsNotificationEvent}
     * @memberof UpdateConfigsNotificationEventRequest
     */
    event: UpdateConfigsNotificationEvent;
}
/**
 * 
 * @export
 * @interface UpdateTransaction
 */
export interface UpdateTransaction {
    /**
     * 
     * @type {string}
     * @memberof UpdateTransaction
     */
    categorySource: UpdateTransaction.CategorySourceEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateTransaction
     */
    container: UpdateTransaction.ContainerEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateTransaction
     */
    isPhysical?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UpdateTransaction
     */
    detailCategoryId?: number;
    /**
     * 
     * @type {Description}
     * @memberof UpdateTransaction
     */
    description?: Description;
    /**
     * 
     * @type {string}
     * @memberof UpdateTransaction
     */
    memo?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTransaction
     */
    merchantType?: UpdateTransaction.MerchantTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof UpdateTransaction
     */
    categoryId: number;
}

/**
 * @export
 * @namespace UpdateTransaction
 */
export namespace UpdateTransaction {
    /**
     * @export
     * @enum {string}
     */
    export enum CategorySourceEnum {
        SYSTEM = <any> 'SYSTEM',
        USER = <any> 'USER'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ContainerEnum {
        Bank = <any> 'bank',
        CreditCard = <any> 'creditCard',
        Investment = <any> 'investment',
        Insurance = <any> 'insurance',
        Loan = <any> 'loan',
        Reward = <any> 'reward',
        Bill = <any> 'bill',
        RealEstate = <any> 'realEstate',
        OtherAssets = <any> 'otherAssets',
        OtherLiabilities = <any> 'otherLiabilities'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum MerchantTypeEnum {
        BILLERS = <any> 'BILLERS',
        SUBSCRIPTION = <any> 'SUBSCRIPTION',
        OTHERS = <any> 'OTHERS'
    }
}
/**
 * 
 * @export
 * @interface UpdateUserRegistration
 */
export interface UpdateUserRegistration {
    /**
     * 
     * @type {UserRequestPreferences}
     * @memberof UpdateUserRegistration
     */
    preferences?: UserRequestPreferences;
    /**
     * 
     * @type {UserAddress}
     * @memberof UpdateUserRegistration
     */
    address?: UserAddress;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRegistration
     */
    phoneNumber?: string;
    /**
     * 
     * @type {Name}
     * @memberof UpdateUserRegistration
     */
    name?: Name;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRegistration
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRegistration
     */
    segmentName?: string;
}
/**
 * 
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * 
     * @type {UpdateUserRegistration}
     * @memberof UpdateUserRequest
     */
    user: UpdateUserRegistration;
}
/**
 * 
 * @export
 * @interface UpdateVerification
 */
export interface UpdateVerification {
    /**
     * Unique identifier for the account.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul>
     * @type {number}
     * @memberof UpdateVerification
     */
    accountId?: number;
    /**
     * The reason the account verification failed.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul>
     * @type {string}
     * @memberof UpdateVerification
     */
    reason?: UpdateVerification.ReasonEnum;
    /**
     * The status of the account verification.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul><br><b>Applicable Values</b>
     * @type {string}
     * @memberof UpdateVerification
     */
    verificationStatus?: UpdateVerification.VerificationStatusEnum;
    /**
     * Unique identifier for the provider account.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul>
     * @type {number}
     * @memberof UpdateVerification
     */
    providerAccountId?: number;
    /**
     * The account verification type.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul><br><b>Applicable Values</b>
     * @type {string}
     * @memberof UpdateVerification
     */
    verificationType?: UpdateVerification.VerificationTypeEnum;
    /**
     * 
     * @type {VerificationAccount}
     * @memberof UpdateVerification
     */
    account?: VerificationAccount;
    /**
     * 
     * @type {Array<VerificationTransaction>}
     * @memberof UpdateVerification
     */
    transaction: Array<VerificationTransaction>;
    /**
     * The date of the account verification.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul>
     * @type {string}
     * @memberof UpdateVerification
     */
    verificationDate?: string;
    /**
     * Unique identifier for the verification request.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul>
     * @type {number}
     * @memberof UpdateVerification
     */
    verificationId?: number;
}

/**
 * @export
 * @namespace UpdateVerification
 */
export namespace UpdateVerification {
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonEnum {
        DATANOTAVAILABLE = <any> 'DATA_NOT_AVAILABLE',
        ACCOUNTHOLDERMISMATCH = <any> 'ACCOUNT_HOLDER_MISMATCH',
        FULLACCOUNTNUMBERANDBANKTRANSFERCODENOTAVAILABLE = <any> 'FULL_ACCOUNT_NUMBER_AND_BANK_TRANSFER_CODE_NOT_AVAILABLE',
        FULLACCOUNTNUMBERNOTAVAILABLE = <any> 'FULL_ACCOUNT_NUMBER_NOT_AVAILABLE',
        BANKTRANSFERCODENOTAVAILABLE = <any> 'BANK_TRANSFER_CODE_NOT_AVAILABLE',
        EXPIRED = <any> 'EXPIRED',
        DATAMISMATCH = <any> 'DATA_MISMATCH',
        INSTRUCTIONGENERATIONERROR = <any> 'INSTRUCTION_GENERATION_ERROR'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum VerificationStatusEnum {
        INITIATED = <any> 'INITIATED',
        DEPOSITED = <any> 'DEPOSITED',
        SUCCESS = <any> 'SUCCESS',
        FAILED = <any> 'FAILED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum VerificationTypeEnum {
        MATCHING = <any> 'MATCHING',
        CHALLENGEDEPOSIT = <any> 'CHALLENGE_DEPOSIT'
    }
}
/**
 * 
 * @export
 * @interface UpdateVerificationRequest
 */
export interface UpdateVerificationRequest {
    /**
     * 
     * @type {UpdateVerification}
     * @memberof UpdateVerificationRequest
     */
    verification?: UpdateVerification;
}
/**
 * 
 * @export
 * @interface UpdatedProviderAccount
 */
export interface UpdatedProviderAccount {
    /**
     * Indicate when the providerAccount is last updated successfully.<br><br><b>Account Type</b>: Aggregated<br><b>Endpoints</b>:<ul><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof UpdatedProviderAccount
     */
    lastUpdated?: string;
    /**
     * This entity gets returned in the response for only MFA based provider accounts during the add/update account polling process. This indicates that the MFA information is expected from the user to complete the process. This represents the structure of MFA form that is displayed to the user in the provider site.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li></ul>
     * @type {Array<LoginForm>}
     * @memberof UpdatedProviderAccount
     */
    loginForm?: Array<LoginForm>;
    /**
     * The date on when the provider account is created in the system.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof UpdatedProviderAccount
     */
    createdDate?: string;
    /**
     * The source through which the providerAccount is added in the system.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li><li>GET dataExtracts/userData</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof UpdatedProviderAccount
     */
    aggregationSource?: UpdatedProviderAccount.AggregationSourceEnum;
    /**
     * Indicates the migration status of the provider account from screen-scraping provider to the Open Banking provider. <br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>GET providerAccounts/{providerAccountId}</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {string}
     * @memberof UpdatedProviderAccount
     */
    oauthMigrationStatus?: UpdatedProviderAccount.OauthMigrationStatusEnum;
    /**
     * Unique identifier for the provider resource. This denotes the provider for which the provider account id is generated by the user.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {number}
     * @memberof UpdatedProviderAccount
     */
    providerId?: number;
    /**
     * Unique id generated to indicate the request.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li></ul>
     * @type {string}
     * @memberof UpdatedProviderAccount
     */
    requestId?: string;
    /**
     * Indicates whether account is a manual or aggregated provider account.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {boolean}
     * @memberof UpdatedProviderAccount
     */
    isManual?: boolean;
    /**
     * Unique identifier for the provider account resource. This is created during account addition.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {number}
     * @memberof UpdatedProviderAccount
     */
    id?: number;
    /**
     * Logical grouping of dataset attributes into datasets such as Basic Aggregation Data, Account Profile and Documents.<br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li><li>GET dataExtracts/userData</li></ul>
     * @type {Array<AccountDataset>}
     * @memberof UpdatedProviderAccount
     */
    dataset?: Array<AccountDataset>;
    /**
     * The status of last update attempted for the account. <br><br><b>Endpoints</b>:<ul><li>GET providerAccounts</li><li>POST providerAccounts</li><li>PUT providerAccounts/{providerAccountId}</li><li>GET providerAccounts/{providerAccountId}</li><li>GET dataExtracts/userData</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof UpdatedProviderAccount
     */
    status?: UpdatedProviderAccount.StatusEnum;
}

/**
 * @export
 * @namespace UpdatedProviderAccount
 */
export namespace UpdatedProviderAccount {
    /**
     * @export
     * @enum {string}
     */
    export enum AggregationSourceEnum {
        SYSTEM = <any> 'SYSTEM',
        USER = <any> 'USER'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum OauthMigrationStatusEnum {
        INPROGRESS = <any> 'IN_PROGRESS',
        TOBEMIGRATED = <any> 'TO_BE_MIGRATED',
        COMPLETED = <any> 'COMPLETED',
        MIGRATED = <any> 'MIGRATED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        LOGININPROGRESS = <any> 'LOGIN_IN_PROGRESS',
        USERINPUTREQUIRED = <any> 'USER_INPUT_REQUIRED',
        INPROGRESS = <any> 'IN_PROGRESS',
        PARTIALSUCCESS = <any> 'PARTIAL_SUCCESS',
        SUCCESS = <any> 'SUCCESS',
        FAILED = <any> 'FAILED',
        MIGRATIONINPROGRESS = <any> 'MIGRATION_IN_PROGRESS'
    }
}
/**
 * 
 * @export
 * @interface UpdatedProviderAccountResponse
 */
export interface UpdatedProviderAccountResponse {
    /**
     * 
     * @type {Array<UpdatedProviderAccount>}
     * @memberof UpdatedProviderAccountResponse
     */
    providerAccount?: Array<UpdatedProviderAccount>;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {UserResponsePreferences}
     * @memberof User
     */
    preferences?: UserResponsePreferences;
    /**
     * 
     * @type {UserSession}
     * @memberof User
     */
    session?: UserSession;
    /**
     * The login name of the user used for authentication.<br><br><b>Endpoints</b>:<ul><li>POST user/register</li><li>GET user</li></ul>
     * @type {string}
     * @memberof User
     */
    loginName?: string;
    /**
     * 
     * @type {Name}
     * @memberof User
     */
    name?: Name;
    /**
     * The unique identifier of a consumer/user in Yodlee system for whom the API services would be accessed for.<br><br><b>Endpoints</b>:<ul><li>POST user/samlLogin</li><li>POST user/register</li><li>GET user</li></ul>
     * @type {number}
     * @memberof User
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    roleType?: User.RoleTypeEnum;
}

/**
 * @export
 * @namespace User
 */
export namespace User {
    /**
     * @export
     * @enum {string}
     */
    export enum RoleTypeEnum {
        INDIVIDUAL = <any> 'INDIVIDUAL'
    }
}
/**
 * 
 * @export
 * @interface UserAccessToken
 */
export interface UserAccessToken {
    /**
     * 
     * @type {Array<AccessTokens>}
     * @memberof UserAccessToken
     */
    accessTokens?: Array<AccessTokens>;
}
/**
 * 
 * @export
 * @interface UserAccessTokensResponse
 */
export interface UserAccessTokensResponse {
    /**
     * 
     * @type {UserAccessToken}
     * @memberof UserAccessTokensResponse
     */
    user?: UserAccessToken;
}
/**
 * 
 * @export
 * @interface UserAddress
 */
export interface UserAddress {
    /**
     * Zip.
     * @type {string}
     * @memberof UserAddress
     */
    zip?: string;
    /**
     * Country.
     * @type {string}
     * @memberof UserAddress
     */
    country?: string;
    /**
     * Address Line 3.
     * @type {string}
     * @memberof UserAddress
     */
    address3?: string;
    /**
     * Address Line 2.
     * @type {string}
     * @memberof UserAddress
     */
    address2?: string;
    /**
     * City.
     * @type {string}
     * @memberof UserAddress
     */
    city?: string;
    /**
     * Address Line 1.
     * @type {string}
     * @memberof UserAddress
     */
    address1?: string;
    /**
     * State.
     * @type {string}
     * @memberof UserAddress
     */
    state?: string;
}
/**
 * 
 * @export
 * @interface UserDetail
 */
export interface UserDetail {
    /**
     * 
     * @type {UserResponsePreferences}
     * @memberof UserDetail
     */
    preferences?: UserResponsePreferences;
    /**
     * 
     * @type {UserAddress}
     * @memberof UserDetail
     */
    address?: UserAddress;
    /**
     * 
     * @type {string}
     * @memberof UserDetail
     */
    phoneNumber?: string;
    /**
     * The login name of the user used for authentication.<br><br><b>Endpoints</b>:<ul><li>POST user/register</li><li>GET user</li></ul>
     * @type {string}
     * @memberof UserDetail
     */
    loginName?: string;
    /**
     * 
     * @type {Name}
     * @memberof UserDetail
     */
    name?: Name;
    /**
     * The unique identifier of a consumer/user in Yodlee system for whom the API services would be accessed for.<br><br><b>Endpoints</b>:<ul><li>POST user/samlLogin</li><li>POST user/register</li><li>GET user</li></ul>
     * @type {number}
     * @memberof UserDetail
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof UserDetail
     */
    roleType?: UserDetail.RoleTypeEnum;
    /**
     * The email address of the user.<br><br><b>Endpoints</b>:<ul><li>GET user</li></ul>
     * @type {string}
     * @memberof UserDetail
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDetail
     */
    segmentName?: string;
}

/**
 * @export
 * @namespace UserDetail
 */
export namespace UserDetail {
    /**
     * @export
     * @enum {string}
     */
    export enum RoleTypeEnum {
        INDIVIDUAL = <any> 'INDIVIDUAL'
    }
}
/**
 * 
 * @export
 * @interface UserDetailResponse
 */
export interface UserDetailResponse {
    /**
     * 
     * @type {UserDetail}
     * @memberof UserDetailResponse
     */
    user?: UserDetail;
}
/**
 * 
 * @export
 * @interface UserRegistration
 */
export interface UserRegistration {
    /**
     * 
     * @type {UserRequestPreferences}
     * @memberof UserRegistration
     */
    preferences?: UserRequestPreferences;
    /**
     * 
     * @type {UserAddress}
     * @memberof UserRegistration
     */
    address?: UserAddress;
    /**
     * 
     * @type {string}
     * @memberof UserRegistration
     */
    phoneNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRegistration
     */
    loginName: string;
    /**
     * 
     * @type {Name}
     * @memberof UserRegistration
     */
    name?: Name;
    /**
     * 
     * @type {string}
     * @memberof UserRegistration
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRegistration
     */
    segmentName?: string;
}
/**
 * 
 * @export
 * @interface UserRequest
 */
export interface UserRequest {
    /**
     * 
     * @type {UserRegistration}
     * @memberof UserRequest
     */
    user: UserRegistration;
}
/**
 * 
 * @export
 * @interface UserRequestPreferences
 */
export interface UserRequestPreferences {
    /**
     * The dateformat of the user.This attribute is just a place holder and has no impact on any other API services.
     * @type {string}
     * @memberof UserRequestPreferences
     */
    dateFormat?: string;
    /**
     * The timezone of the user. This attribute is just a place holder and has no impact on any other API services.
     * @type {string}
     * @memberof UserRequestPreferences
     */
    timeZone?: string;
    /**
     * The currency of the user. This currency will be respected while providing the response for derived API services.<br><b>Applicable Values</b><br>
     * @type {string}
     * @memberof UserRequestPreferences
     */
    currency?: UserRequestPreferences.CurrencyEnum;
    /**
     * The locale of the user. This locale will be considered for localization features like providing the provider information in the supported locale or providing category names in the transaction related services.<br><b>Applicable Values</b><br>
     * @type {string}
     * @memberof UserRequestPreferences
     */
    locale?: UserRequestPreferences.LocaleEnum;
}

/**
 * @export
 * @namespace UserRequestPreferences
 */
export namespace UserRequestPreferences {
    /**
     * @export
     * @enum {string}
     */
    export enum CurrencyEnum {
        USD = <any> 'USD',
        AUD = <any> 'AUD',
        BRL = <any> 'BRL',
        CAD = <any> 'CAD',
        EUR = <any> 'EUR',
        GBP = <any> 'GBP',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        INR = <any> 'INR',
        JPY = <any> 'JPY',
        NZD = <any> 'NZD',
        SGD = <any> 'SGD',
        ZAR = <any> 'ZAR',
        CNY = <any> 'CNY',
        VND = <any> 'VND',
        MYR = <any> 'MYR',
        CHF = <any> 'CHF',
        AED = <any> 'AED',
        AFA = <any> 'AFA',
        ALL = <any> 'ALL',
        AMD = <any> 'AMD',
        ANG = <any> 'ANG',
        AOA = <any> 'AOA',
        ARS = <any> 'ARS',
        AWG = <any> 'AWG',
        AZM = <any> 'AZM',
        BAM = <any> 'BAM',
        BBD = <any> 'BBD',
        BDT = <any> 'BDT',
        BGL = <any> 'BGL',
        BHD = <any> 'BHD',
        BIF = <any> 'BIF',
        BMD = <any> 'BMD',
        BND = <any> 'BND',
        BOB = <any> 'BOB',
        BSD = <any> 'BSD',
        BTN = <any> 'BTN',
        BWP = <any> 'BWP',
        BYR = <any> 'BYR',
        BZD = <any> 'BZD',
        CDF = <any> 'CDF',
        CLP = <any> 'CLP',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        CVE = <any> 'CVE',
        CYP = <any> 'CYP',
        CZK = <any> 'CZK',
        DJF = <any> 'DJF',
        DKK = <any> 'DKK',
        DOP = <any> 'DOP',
        DZD = <any> 'DZD',
        EEK = <any> 'EEK',
        EGP = <any> 'EGP',
        ERN = <any> 'ERN',
        ETB = <any> 'ETB',
        FJD = <any> 'FJD',
        FKP = <any> 'FKP',
        GEL = <any> 'GEL',
        GGP = <any> 'GGP',
        GHC = <any> 'GHC',
        GIP = <any> 'GIP',
        GMD = <any> 'GMD',
        GNF = <any> 'GNF',
        GTQ = <any> 'GTQ',
        GYD = <any> 'GYD',
        HNL = <any> 'HNL',
        HRK = <any> 'HRK',
        HTG = <any> 'HTG',
        HUF = <any> 'HUF',
        ILS = <any> 'ILS',
        IMP = <any> 'IMP',
        IQD = <any> 'IQD',
        IRR = <any> 'IRR',
        ISK = <any> 'ISK',
        JEP = <any> 'JEP',
        JMD = <any> 'JMD',
        JOD = <any> 'JOD',
        KES = <any> 'KES',
        KGS = <any> 'KGS',
        KHR = <any> 'KHR',
        KMF = <any> 'KMF',
        KPW = <any> 'KPW',
        KRW = <any> 'KRW',
        KWD = <any> 'KWD',
        KYD = <any> 'KYD',
        KZT = <any> 'KZT',
        LAK = <any> 'LAK',
        LBP = <any> 'LBP',
        LKR = <any> 'LKR',
        LRD = <any> 'LRD',
        LSL = <any> 'LSL',
        LTL = <any> 'LTL',
        LVL = <any> 'LVL',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        MDL = <any> 'MDL',
        MGF = <any> 'MGF',
        MKD = <any> 'MKD',
        MMK = <any> 'MMK',
        MNT = <any> 'MNT',
        MOP = <any> 'MOP',
        MRO = <any> 'MRO',
        MTL = <any> 'MTL',
        MUR = <any> 'MUR',
        MVR = <any> 'MVR',
        MWK = <any> 'MWK',
        MXN = <any> 'MXN',
        MZM = <any> 'MZM',
        NAD = <any> 'NAD',
        NGN = <any> 'NGN',
        NIO = <any> 'NIO',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        OMR = <any> 'OMR',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PGK = <any> 'PGK',
        PHP = <any> 'PHP',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        PYG = <any> 'PYG',
        QAR = <any> 'QAR',
        ROL = <any> 'ROL',
        RUR = <any> 'RUR',
        RWF = <any> 'RWF',
        SAR = <any> 'SAR',
        SBD = <any> 'SBD',
        SCR = <any> 'SCR',
        SDD = <any> 'SDD',
        SEK = <any> 'SEK',
        SHP = <any> 'SHP',
        SIT = <any> 'SIT',
        SKK = <any> 'SKK',
        SLL = <any> 'SLL',
        SOS = <any> 'SOS',
        SPL = <any> 'SPL',
        SRG = <any> 'SRG',
        STD = <any> 'STD',
        SVC = <any> 'SVC',
        SYP = <any> 'SYP',
        SZL = <any> 'SZL',
        THB = <any> 'THB',
        TJR = <any> 'TJR',
        TMM = <any> 'TMM',
        TND = <any> 'TND',
        TOP = <any> 'TOP',
        TRL = <any> 'TRL',
        TTD = <any> 'TTD',
        TVD = <any> 'TVD',
        TWD = <any> 'TWD',
        TZS = <any> 'TZS',
        UAH = <any> 'UAH',
        UGX = <any> 'UGX',
        UYU = <any> 'UYU',
        UZS = <any> 'UZS',
        VEB = <any> 'VEB',
        VUV = <any> 'VUV',
        WST = <any> 'WST',
        XAF = <any> 'XAF',
        XAG = <any> 'XAG',
        XAU = <any> 'XAU',
        XCD = <any> 'XCD',
        XDR = <any> 'XDR',
        XOF = <any> 'XOF',
        XPD = <any> 'XPD',
        XPF = <any> 'XPF',
        XPT = <any> 'XPT',
        YER = <any> 'YER',
        YUM = <any> 'YUM',
        ZMK = <any> 'ZMK',
        ZWD = <any> 'ZWD',
        ADP = <any> 'ADP',
        ATS = <any> 'ATS',
        BEF = <any> 'BEF',
        BUK = <any> 'BUK',
        CSD = <any> 'CSD',
        CSK = <any> 'CSK',
        DDM = <any> 'DDM',
        DEM = <any> 'DEM',
        ECS = <any> 'ECS',
        ESP = <any> 'ESP',
        FIM = <any> 'FIM',
        GRD = <any> 'GRD',
        GWP = <any> 'GWP',
        IEP = <any> 'IEP',
        ITL = <any> 'ITL',
        LUF = <any> 'LUF',
        MLF = <any> 'MLF',
        NLG = <any> 'NLG',
        PTE = <any> 'PTE',
        SUR = <any> 'SUR',
        TPE = <any> 'TPE',
        UAK = <any> 'UAK',
        XBA = <any> 'XBA',
        XBB = <any> 'XBB',
        XBC = <any> 'XBC',
        XBD = <any> 'XBD',
        XEU = <any> 'XEU',
        XFO = <any> 'XFO',
        XFU = <any> 'XFU',
        XGF = <any> 'XGF',
        XMK = <any> 'XMK',
        XRM = <any> 'XRM',
        XTS = <any> 'XTS',
        YDD = <any> 'YDD',
        YUD = <any> 'YUD',
        ZRN = <any> 'ZRN',
        TJS = <any> 'TJS',
        RON = <any> 'RON',
        BGN = <any> 'BGN',
        BTC = <any> 'BTC',
        XBT = <any> 'XBT',
        CNH = <any> 'CNH',
        RUB = <any> 'RUB',
        TRY = <any> 'TRY',
        GHS = <any> 'GHS',
        TMT = <any> 'TMT',
        ZMW = <any> 'ZMW',
        VEF = <any> 'VEF',
        SSP = <any> 'SSP',
        ALK = <any> 'ALK'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum LocaleEnum {
        EnUS = <any> 'en_US',
        EnAN = <any> 'en_AN',
        EnGB = <any> 'en_GB',
        EnAU = <any> 'en_AU',
        EnBE = <any> 'en_BE',
        ZhCN = <any> 'zh_CN',
        EnIN = <any> 'en_IN',
        EnCA = <any> 'en_CA',
        EnES = <any> 'en_ES',
        EnNZ = <any> 'en_NZ',
        EnIE = <any> 'en_IE',
        EnIL = <any> 'en_IL',
        EnFR = <any> 'en_FR',
        EnAE = <any> 'en_AE',
        EnFJ = <any> 'en_FJ',
        EnGU = <any> 'en_GU',
        EnHK = <any> 'en_HK',
        EnIT = <any> 'en_IT',
        EnJP = <any> 'en_JP',
        EnKH = <any> 'en_KH',
        EnKP = <any> 'en_KP',
        EnKR = <any> 'en_KR',
        EnMY = <any> 'en_MY',
        EnPG = <any> 'en_PG',
        EnPH = <any> 'en_PH',
        EnSB = <any> 'en_SB',
        EnSG = <any> 'en_SG',
        EnTH = <any> 'en_TH',
        EnTO = <any> 'en_TO',
        EnVN = <any> 'en_VN',
        EnVU = <any> 'en_VU',
        EnWS = <any> 'en_WS',
        EsES = <any> 'es_ES',
        FrCA = <any> 'fr_CA',
        FrFR = <any> 'fr_FR',
        NlAN = <any> 'nl_AN',
        EnCH = <any> 'en_CH',
        EnZA = <any> 'en_ZA',
        EnCN = <any> 'en_CN',
        EnFI = <any> 'en_FI',
        EnAT = <any> 'en_AT',
        DeAT = <any> 'de_AT',
        EnDE = <any> 'en_DE',
        DeDE = <any> 'de_DE',
        DeRU = <any> 'de_RU',
        EnID = <any> 'en_ID',
        EnMX = <any> 'en_MX',
        EsMX = <any> 'es_MX',
        EnPT = <any> 'en_PT',
        EnSE = <any> 'en_SE',
        EnGLOBAL = <any> 'en_GLOBAL',
        PtBR = <any> 'pt_BR',
        EnDK = <any> 'en_DK',
        EnBR = <any> 'en_BR',
        EnBM = <any> 'en_BM',
        EnCK = <any> 'en_CK',
        EnCO = <any> 'en_CO',
        EnJE = <any> 'en_JE',
        EnBG = <any> 'en_BG',
        EnBW = <any> 'en_BW',
        EnMW = <any> 'en_MW',
        EnKE = <any> 'en_KE',
        EnSZ = <any> 'en_SZ',
        EnZW = <any> 'en_ZW',
        EnNL = <any> 'en_NL',
        NlNL = <any> 'nl_NL'
    }
}
/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * 
     * @type {User}
     * @memberof UserResponse
     */
    user?: User;
}
/**
 * 
 * @export
 * @interface UserResponsePreferences
 */
export interface UserResponsePreferences {
    /**
     * The dateformat of the user.This attribute is just a place holder and has no impact on any other API services.
     * @type {string}
     * @memberof UserResponsePreferences
     */
    dateFormat?: string;
    /**
     * The timezone of the user. This attribute is just a place holder and has no impact on any other API services.
     * @type {string}
     * @memberof UserResponsePreferences
     */
    timeZone?: string;
    /**
     * The currency of the user. This currency will be respected while providing the response for derived API services.<br><b>Applicable Values</b><br>
     * @type {string}
     * @memberof UserResponsePreferences
     */
    currency?: UserResponsePreferences.CurrencyEnum;
    /**
     * The locale of the user. This locale will be considered for localization features like providing the provider information in the supported locale or providing category names in the transaction related services.<br><b>Applicable Values</b><br>
     * @type {string}
     * @memberof UserResponsePreferences
     */
    locale?: UserResponsePreferences.LocaleEnum;
}

/**
 * @export
 * @namespace UserResponsePreferences
 */
export namespace UserResponsePreferences {
    /**
     * @export
     * @enum {string}
     */
    export enum CurrencyEnum {
        USD = <any> 'USD',
        AUD = <any> 'AUD',
        BRL = <any> 'BRL',
        CAD = <any> 'CAD',
        EUR = <any> 'EUR',
        GBP = <any> 'GBP',
        HKD = <any> 'HKD',
        IDR = <any> 'IDR',
        INR = <any> 'INR',
        JPY = <any> 'JPY',
        NZD = <any> 'NZD',
        SGD = <any> 'SGD',
        ZAR = <any> 'ZAR',
        CNY = <any> 'CNY',
        VND = <any> 'VND',
        MYR = <any> 'MYR',
        CHF = <any> 'CHF',
        AED = <any> 'AED',
        AFA = <any> 'AFA',
        ALL = <any> 'ALL',
        AMD = <any> 'AMD',
        ANG = <any> 'ANG',
        AOA = <any> 'AOA',
        ARS = <any> 'ARS',
        AWG = <any> 'AWG',
        AZM = <any> 'AZM',
        BAM = <any> 'BAM',
        BBD = <any> 'BBD',
        BDT = <any> 'BDT',
        BGL = <any> 'BGL',
        BHD = <any> 'BHD',
        BIF = <any> 'BIF',
        BMD = <any> 'BMD',
        BND = <any> 'BND',
        BOB = <any> 'BOB',
        BSD = <any> 'BSD',
        BTN = <any> 'BTN',
        BWP = <any> 'BWP',
        BYR = <any> 'BYR',
        BZD = <any> 'BZD',
        CDF = <any> 'CDF',
        CLP = <any> 'CLP',
        COP = <any> 'COP',
        CRC = <any> 'CRC',
        CUP = <any> 'CUP',
        CVE = <any> 'CVE',
        CYP = <any> 'CYP',
        CZK = <any> 'CZK',
        DJF = <any> 'DJF',
        DKK = <any> 'DKK',
        DOP = <any> 'DOP',
        DZD = <any> 'DZD',
        EEK = <any> 'EEK',
        EGP = <any> 'EGP',
        ERN = <any> 'ERN',
        ETB = <any> 'ETB',
        FJD = <any> 'FJD',
        FKP = <any> 'FKP',
        GEL = <any> 'GEL',
        GGP = <any> 'GGP',
        GHC = <any> 'GHC',
        GIP = <any> 'GIP',
        GMD = <any> 'GMD',
        GNF = <any> 'GNF',
        GTQ = <any> 'GTQ',
        GYD = <any> 'GYD',
        HNL = <any> 'HNL',
        HRK = <any> 'HRK',
        HTG = <any> 'HTG',
        HUF = <any> 'HUF',
        ILS = <any> 'ILS',
        IMP = <any> 'IMP',
        IQD = <any> 'IQD',
        IRR = <any> 'IRR',
        ISK = <any> 'ISK',
        JEP = <any> 'JEP',
        JMD = <any> 'JMD',
        JOD = <any> 'JOD',
        KES = <any> 'KES',
        KGS = <any> 'KGS',
        KHR = <any> 'KHR',
        KMF = <any> 'KMF',
        KPW = <any> 'KPW',
        KRW = <any> 'KRW',
        KWD = <any> 'KWD',
        KYD = <any> 'KYD',
        KZT = <any> 'KZT',
        LAK = <any> 'LAK',
        LBP = <any> 'LBP',
        LKR = <any> 'LKR',
        LRD = <any> 'LRD',
        LSL = <any> 'LSL',
        LTL = <any> 'LTL',
        LVL = <any> 'LVL',
        LYD = <any> 'LYD',
        MAD = <any> 'MAD',
        MDL = <any> 'MDL',
        MGF = <any> 'MGF',
        MKD = <any> 'MKD',
        MMK = <any> 'MMK',
        MNT = <any> 'MNT',
        MOP = <any> 'MOP',
        MRO = <any> 'MRO',
        MTL = <any> 'MTL',
        MUR = <any> 'MUR',
        MVR = <any> 'MVR',
        MWK = <any> 'MWK',
        MXN = <any> 'MXN',
        MZM = <any> 'MZM',
        NAD = <any> 'NAD',
        NGN = <any> 'NGN',
        NIO = <any> 'NIO',
        NOK = <any> 'NOK',
        NPR = <any> 'NPR',
        OMR = <any> 'OMR',
        PAB = <any> 'PAB',
        PEN = <any> 'PEN',
        PGK = <any> 'PGK',
        PHP = <any> 'PHP',
        PKR = <any> 'PKR',
        PLN = <any> 'PLN',
        PYG = <any> 'PYG',
        QAR = <any> 'QAR',
        ROL = <any> 'ROL',
        RUR = <any> 'RUR',
        RWF = <any> 'RWF',
        SAR = <any> 'SAR',
        SBD = <any> 'SBD',
        SCR = <any> 'SCR',
        SDD = <any> 'SDD',
        SEK = <any> 'SEK',
        SHP = <any> 'SHP',
        SIT = <any> 'SIT',
        SKK = <any> 'SKK',
        SLL = <any> 'SLL',
        SOS = <any> 'SOS',
        SPL = <any> 'SPL',
        SRG = <any> 'SRG',
        STD = <any> 'STD',
        SVC = <any> 'SVC',
        SYP = <any> 'SYP',
        SZL = <any> 'SZL',
        THB = <any> 'THB',
        TJR = <any> 'TJR',
        TMM = <any> 'TMM',
        TND = <any> 'TND',
        TOP = <any> 'TOP',
        TRL = <any> 'TRL',
        TTD = <any> 'TTD',
        TVD = <any> 'TVD',
        TWD = <any> 'TWD',
        TZS = <any> 'TZS',
        UAH = <any> 'UAH',
        UGX = <any> 'UGX',
        UYU = <any> 'UYU',
        UZS = <any> 'UZS',
        VEB = <any> 'VEB',
        VUV = <any> 'VUV',
        WST = <any> 'WST',
        XAF = <any> 'XAF',
        XAG = <any> 'XAG',
        XAU = <any> 'XAU',
        XCD = <any> 'XCD',
        XDR = <any> 'XDR',
        XOF = <any> 'XOF',
        XPD = <any> 'XPD',
        XPF = <any> 'XPF',
        XPT = <any> 'XPT',
        YER = <any> 'YER',
        YUM = <any> 'YUM',
        ZMK = <any> 'ZMK',
        ZWD = <any> 'ZWD',
        ADP = <any> 'ADP',
        ATS = <any> 'ATS',
        BEF = <any> 'BEF',
        BUK = <any> 'BUK',
        CSD = <any> 'CSD',
        CSK = <any> 'CSK',
        DDM = <any> 'DDM',
        DEM = <any> 'DEM',
        ECS = <any> 'ECS',
        ESP = <any> 'ESP',
        FIM = <any> 'FIM',
        GRD = <any> 'GRD',
        GWP = <any> 'GWP',
        IEP = <any> 'IEP',
        ITL = <any> 'ITL',
        LUF = <any> 'LUF',
        MLF = <any> 'MLF',
        NLG = <any> 'NLG',
        PTE = <any> 'PTE',
        SUR = <any> 'SUR',
        TPE = <any> 'TPE',
        UAK = <any> 'UAK',
        XBA = <any> 'XBA',
        XBB = <any> 'XBB',
        XBC = <any> 'XBC',
        XBD = <any> 'XBD',
        XEU = <any> 'XEU',
        XFO = <any> 'XFO',
        XFU = <any> 'XFU',
        XGF = <any> 'XGF',
        XMK = <any> 'XMK',
        XRM = <any> 'XRM',
        XTS = <any> 'XTS',
        YDD = <any> 'YDD',
        YUD = <any> 'YUD',
        ZRN = <any> 'ZRN',
        TJS = <any> 'TJS',
        RON = <any> 'RON',
        BGN = <any> 'BGN',
        BTC = <any> 'BTC',
        XBT = <any> 'XBT',
        CNH = <any> 'CNH',
        RUB = <any> 'RUB',
        TRY = <any> 'TRY',
        GHS = <any> 'GHS',
        TMT = <any> 'TMT',
        ZMW = <any> 'ZMW',
        VEF = <any> 'VEF',
        SSP = <any> 'SSP',
        ALK = <any> 'ALK'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum LocaleEnum {
        EnUS = <any> 'en_US',
        EnAN = <any> 'en_AN',
        EnGB = <any> 'en_GB',
        EnAU = <any> 'en_AU',
        EnBE = <any> 'en_BE',
        ZhCN = <any> 'zh_CN',
        EnIN = <any> 'en_IN',
        EnCA = <any> 'en_CA',
        EnES = <any> 'en_ES',
        EnNZ = <any> 'en_NZ',
        EnIE = <any> 'en_IE',
        EnIL = <any> 'en_IL',
        EnFR = <any> 'en_FR',
        EnAE = <any> 'en_AE',
        EnFJ = <any> 'en_FJ',
        EnGU = <any> 'en_GU',
        EnHK = <any> 'en_HK',
        EnIT = <any> 'en_IT',
        EnJP = <any> 'en_JP',
        EnKH = <any> 'en_KH',
        EnKP = <any> 'en_KP',
        EnKR = <any> 'en_KR',
        EnMY = <any> 'en_MY',
        EnPG = <any> 'en_PG',
        EnPH = <any> 'en_PH',
        EnSB = <any> 'en_SB',
        EnSG = <any> 'en_SG',
        EnTH = <any> 'en_TH',
        EnTO = <any> 'en_TO',
        EnVN = <any> 'en_VN',
        EnVU = <any> 'en_VU',
        EnWS = <any> 'en_WS',
        EsES = <any> 'es_ES',
        FrCA = <any> 'fr_CA',
        FrFR = <any> 'fr_FR',
        NlAN = <any> 'nl_AN',
        EnCH = <any> 'en_CH',
        EnZA = <any> 'en_ZA',
        EnCN = <any> 'en_CN',
        EnFI = <any> 'en_FI',
        EnAT = <any> 'en_AT',
        DeAT = <any> 'de_AT',
        EnDE = <any> 'en_DE',
        DeDE = <any> 'de_DE',
        DeRU = <any> 'de_RU',
        EnID = <any> 'en_ID',
        EnMX = <any> 'en_MX',
        EsMX = <any> 'es_MX',
        EnPT = <any> 'en_PT',
        EnSE = <any> 'en_SE',
        EnGLOBAL = <any> 'en_GLOBAL',
        PtBR = <any> 'pt_BR',
        EnDK = <any> 'en_DK',
        EnBR = <any> 'en_BR',
        EnBM = <any> 'en_BM',
        EnCK = <any> 'en_CK',
        EnCO = <any> 'en_CO',
        EnJE = <any> 'en_JE',
        EnBG = <any> 'en_BG',
        EnBW = <any> 'en_BW',
        EnMW = <any> 'en_MW',
        EnKE = <any> 'en_KE',
        EnSZ = <any> 'en_SZ',
        EnZW = <any> 'en_ZW',
        EnNL = <any> 'en_NL',
        NlNL = <any> 'nl_NL'
    }
}
/**
 * 
 * @export
 * @interface UserSession
 */
export interface UserSession {
    /**
     * Session provided for a valid user to access API services upon successful authentication.<br><br><b>Endpoints</b>:<ul><li>POST user/samlLogin</li><li>POST user/register</li></ul>
     * @type {string}
     * @memberof UserSession
     */
    userSession?: string;
}
/**
 * 
 * @export
 * @interface Verification
 */
export interface Verification {
    /**
     * Unique identifier for the account.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul>
     * @type {number}
     * @memberof Verification
     */
    accountId?: number;
    /**
     * The reason the account verification failed.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul>
     * @type {string}
     * @memberof Verification
     */
    reason?: Verification.ReasonEnum;
    /**
     * The status of the account verification.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul><br><b>Applicable Values</b>
     * @type {string}
     * @memberof Verification
     */
    verificationStatus?: Verification.VerificationStatusEnum;
    /**
     * Unique identifier for the provider account.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul>
     * @type {number}
     * @memberof Verification
     */
    providerAccountId?: number;
    /**
     * The account verification type.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul><br><b>Applicable Values</b>
     * @type {string}
     * @memberof Verification
     */
    verificationType?: Verification.VerificationTypeEnum;
    /**
     * 
     * @type {VerificationAccount}
     * @memberof Verification
     */
    account?: VerificationAccount;
    /**
     * The date of the account verification.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul>
     * @type {string}
     * @memberof Verification
     */
    verificationDate?: string;
    /**
     * Unique identifier for the verification request.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul>
     * @type {number}
     * @memberof Verification
     */
    verificationId?: number;
}

/**
 * @export
 * @namespace Verification
 */
export namespace Verification {
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonEnum {
        DATANOTAVAILABLE = <any> 'DATA_NOT_AVAILABLE',
        ACCOUNTHOLDERMISMATCH = <any> 'ACCOUNT_HOLDER_MISMATCH',
        FULLACCOUNTNUMBERANDBANKTRANSFERCODENOTAVAILABLE = <any> 'FULL_ACCOUNT_NUMBER_AND_BANK_TRANSFER_CODE_NOT_AVAILABLE',
        FULLACCOUNTNUMBERNOTAVAILABLE = <any> 'FULL_ACCOUNT_NUMBER_NOT_AVAILABLE',
        BANKTRANSFERCODENOTAVAILABLE = <any> 'BANK_TRANSFER_CODE_NOT_AVAILABLE',
        EXPIRED = <any> 'EXPIRED',
        DATAMISMATCH = <any> 'DATA_MISMATCH',
        INSTRUCTIONGENERATIONERROR = <any> 'INSTRUCTION_GENERATION_ERROR'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum VerificationStatusEnum {
        INITIATED = <any> 'INITIATED',
        DEPOSITED = <any> 'DEPOSITED',
        SUCCESS = <any> 'SUCCESS',
        FAILED = <any> 'FAILED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum VerificationTypeEnum {
        MATCHING = <any> 'MATCHING',
        CHALLENGEDEPOSIT = <any> 'CHALLENGE_DEPOSIT'
    }
}
/**
 * 
 * @export
 * @interface VerificationAccount
 */
export interface VerificationAccount {
    /**
     * 
     * @type {string}
     * @memberof VerificationAccount
     */
    accountName?: string;
    /**
     * 
     * @type {string}
     * @memberof VerificationAccount
     */
    accountType: VerificationAccount.AccountTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof VerificationAccount
     */
    accountNumber: string;
    /**
     * 
     * @type {string}
     * @memberof VerificationAccount
     */
    userClassification?: VerificationAccount.UserClassificationEnum;
    /**
     * 
     * @type {VerificationBankTransferCode}
     * @memberof VerificationAccount
     */
    bankTransferCode: VerificationBankTransferCode;
}

/**
 * @export
 * @namespace VerificationAccount
 */
export namespace VerificationAccount {
    /**
     * @export
     * @enum {string}
     */
    export enum AccountTypeEnum {
        SAVINGS = <any> 'SAVINGS',
        CHECKING = <any> 'CHECKING'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum UserClassificationEnum {
        BUSINESS = <any> 'BUSINESS',
        PERSONAL = <any> 'PERSONAL'
    }
}
/**
 * 
 * @export
 * @interface VerificationBankTransferCode
 */
export interface VerificationBankTransferCode {
    /**
     * The FI's branch identification number.Additional Details: The routing number of the bank account in the United States. For non-United States accounts, it is the IFSC code (India), BSB number (Australia), and sort code (United Kingdom). <br><b>Account Type</b>: Aggregated<br><b>Applicable containers</b>: bank, investment<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>POST verification</li></ul>
     * @type {string}
     * @memberof VerificationBankTransferCode
     */
    id?: string;
    /**
     * The bank transfer code type varies depending on the region of the account origination. <br><b>Account Type</b>: Aggregated<br><b>Applicable containers</b>: bank, investment<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>POST verification</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof VerificationBankTransferCode
     */
    type?: VerificationBankTransferCode.TypeEnum;
}

/**
 * @export
 * @namespace VerificationBankTransferCode
 */
export namespace VerificationBankTransferCode {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        BSB = <any> 'BSB',
        IFSC = <any> 'IFSC',
        ROUTINGNUMBER = <any> 'ROUTING_NUMBER',
        SORTCODE = <any> 'SORT_CODE'
    }
}
/**
 * 
 * @export
 * @interface VerificationHolder
 */
export interface VerificationHolder {
    /**
     * Indicates the ownership of the account
     * @type {string}
     * @memberof VerificationHolder
     */
    ownership?: string;
    /**
     * 
     * @type {Name}
     * @memberof VerificationHolder
     */
    name?: Name;
}
/**
 * 
 * @export
 * @interface VerificationHolderProfile
 */
export interface VerificationHolderProfile {
    /**
     * The primary key of the account resource and the unique identifier for the account
     * @type {number}
     * @memberof VerificationHolderProfile
     */
    accountId?: number;
    /**
     * The account holder's address available at the profile and account levels
     * @type {Array<AbstractAddress>}
     * @memberof VerificationHolderProfile
     */
    address?: Array<AbstractAddress>;
    /**
     * The account holder's phone number available at the profile and account levels
     * @type {Array<PhoneNumber>}
     * @memberof VerificationHolderProfile
     */
    phoneNumber?: Array<PhoneNumber>;
    /**
     * The primary key of the provider account resource
     * @type {number}
     * @memberof VerificationHolderProfile
     */
    providerAccountId?: number;
    /**
     * The holder entity is account-specific and captures the ownership status and the name details of the user
     * @type {Array<VerificationHolder>}
     * @memberof VerificationHolderProfile
     */
    holder?: Array<VerificationHolder>;
    /**
     * The account holder's email ID available at the profile and account levels
     * @type {Array<Email>}
     * @memberof VerificationHolderProfile
     */
    email?: Array<Email>;
}
/**
 * 
 * @export
 * @interface VerificationRequest
 */
export interface VerificationRequest {
    /**
     * 
     * @type {Verification}
     * @memberof VerificationRequest
     */
    verification: Verification;
}
/**
 * 
 * @export
 * @interface VerificationResponse
 */
export interface VerificationResponse {
    /**
     * 
     * @type {Array<Verification>}
     * @memberof VerificationResponse
     */
    verification?: Array<Verification>;
}
/**
 * 
 * @export
 * @interface VerificationStatus
 */
export interface VerificationStatus {
    /**
     * Unique identifier for the account.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul>
     * @type {number}
     * @memberof VerificationStatus
     */
    accountId?: number;
    /**
     * The reason the account verification failed.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul>
     * @type {string}
     * @memberof VerificationStatus
     */
    reason?: VerificationStatus.ReasonEnum;
    /**
     * The status of the account verification.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul><br><b>Applicable Values</b>
     * @type {string}
     * @memberof VerificationStatus
     */
    verificationStatus?: VerificationStatus.VerificationStatusEnum;
    /**
     * Unique identifier for the provider account.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul>
     * @type {number}
     * @memberof VerificationStatus
     */
    providerAccountId?: number;
    /**
     * The account verification type.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul><br><b>Applicable Values</b>
     * @type {string}
     * @memberof VerificationStatus
     */
    verificationType?: VerificationStatus.VerificationTypeEnum;
    /**
     * 
     * @type {VerificationAccount}
     * @memberof VerificationStatus
     */
    account?: VerificationAccount;
    /**
     * 
     * @type {number}
     * @memberof VerificationStatus
     */
    remainingAttempts?: number;
    /**
     * The date of the account verification.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul>
     * @type {string}
     * @memberof VerificationStatus
     */
    verificationDate?: string;
    /**
     * Unique identifier for the verification request.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul>
     * @type {number}
     * @memberof VerificationStatus
     */
    verificationId?: number;
}

/**
 * @export
 * @namespace VerificationStatus
 */
export namespace VerificationStatus {
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonEnum {
        DATANOTAVAILABLE = <any> 'DATA_NOT_AVAILABLE',
        ACCOUNTHOLDERMISMATCH = <any> 'ACCOUNT_HOLDER_MISMATCH',
        FULLACCOUNTNUMBERANDBANKTRANSFERCODENOTAVAILABLE = <any> 'FULL_ACCOUNT_NUMBER_AND_BANK_TRANSFER_CODE_NOT_AVAILABLE',
        FULLACCOUNTNUMBERNOTAVAILABLE = <any> 'FULL_ACCOUNT_NUMBER_NOT_AVAILABLE',
        BANKTRANSFERCODENOTAVAILABLE = <any> 'BANK_TRANSFER_CODE_NOT_AVAILABLE',
        EXPIRED = <any> 'EXPIRED',
        DATAMISMATCH = <any> 'DATA_MISMATCH',
        INSTRUCTIONGENERATIONERROR = <any> 'INSTRUCTION_GENERATION_ERROR'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum VerificationStatusEnum {
        INITIATED = <any> 'INITIATED',
        DEPOSITED = <any> 'DEPOSITED',
        SUCCESS = <any> 'SUCCESS',
        FAILED = <any> 'FAILED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum VerificationTypeEnum {
        MATCHING = <any> 'MATCHING',
        CHALLENGEDEPOSIT = <any> 'CHALLENGE_DEPOSIT'
    }
}
/**
 * 
 * @export
 * @interface VerificationStatusResponse
 */
export interface VerificationStatusResponse {
    /**
     * 
     * @type {Array<VerificationStatus>}
     * @memberof VerificationStatusResponse
     */
    verification?: Array<VerificationStatus>;
}
/**
 * 
 * @export
 * @interface VerificationTransaction
 */
export interface VerificationTransaction {
    /**
     * 
     * @type {Money}
     * @memberof VerificationTransaction
     */
    amount: Money;
    /**
     * 
     * @type {string}
     * @memberof VerificationTransaction
     */
    baseType: VerificationTransaction.BaseTypeEnum;
}

/**
 * @export
 * @namespace VerificationTransaction
 */
export namespace VerificationTransaction {
    /**
     * @export
     * @enum {string}
     */
    export enum BaseTypeEnum {
        CREDIT = <any> 'CREDIT',
        DEBIT = <any> 'DEBIT'
    }
}
/**
 * 
 * @export
 * @interface VerifiedAccount
 */
export interface VerifiedAccount {
    /**
     * 
     * @type {string}
     * @memberof VerifiedAccount
     */
    fullAccountNumber?: string;
    /**
     * The type of account that is aggregated, i.e., savings, checking, credit card, charge, HELOC, etc. The account type is derived based on the attributes of the account. <br><b>Valid Values:</b><br><b>Aggregated Account Type</b><br><b>bank</b><ul><li>CHECKING</li><li>SAVINGS</li><li>CD</li><li>PPF</li><li>RECURRING_DEPOSIT</li><li>FSA</li><li>MONEY_MARKET</li><li>IRA</li><li>PREPAID</li></ul><b>creditCard</b><ul><li>OTHER</li><li>CREDIT</li><li>STORE</li><li>CHARGE</li><li>OTHER</li></ul><b>investment (SN 1.0)</b><ul><li>BROKERAGE_MARGIN</li><li>HSA</li><li>IRA</li><li>BROKERAGE_CASH</li><li>401K</li><li>403B</li><li>TRUST</li><li>ANNUITY</li><li>SIMPLE</li><li>CUSTODIAL</li><li>BROKERAGE_CASH_OPTION</li><li>BROKERAGE_MARGIN_OPTION</li><li>INDIVIDUAL</li><li>CORPORATE</li><li>JTTIC</li><li>JTWROS</li><li>COMMUNITY_PROPERTY</li><li>JOINT_BY_ENTIRETY</li><li>CONSERVATORSHIP</li><li>ROTH</li><li>ROTH_CONVERSION</li><li>ROLLOVER</li><li>EDUCATIONAL</li><li>529_PLAN</li><li>457_DEFERRED_COMPENSATION</li><li>401A</li><li>PSP</li><li>MPP</li><li>STOCK_BASKET</li><li>LIVING_TRUST</li><li>REVOCABLE_TRUST</li><li>IRREVOCABLE_TRUST</li><li>CHARITABLE_REMAINDER</li><li>CHARITABLE_LEAD</li><li>CHARITABLE_GIFT_ACCOUNT</li><li>SEP</li><li>UTMA</li><li>UGMA</li><li>ESOPP</li><li>ADMINISTRATOR</li><li>EXECUTOR</li><li>PARTNERSHIP</li><li>SOLE_PROPRIETORSHIP</li><li>CHURCH</li><li>INVESTMENT_CLUB</li><li>RESTRICTED_STOCK_AWARD</li><li>CMA</li><li>EMPLOYEE_STOCK_PURCHASE_PLAN</li><li>PERFORMANCE_PLAN</li><li>BROKERAGE_LINK_ACCOUNT</li><li>MONEY_MARKET</li><li>SUPER_ANNUATION</li><li>REGISTERED_RETIREMENT_SAVINGS_PLAN</li><li>SPOUSAL_RETIREMENT_SAVINGS_PLAN</li><li>DEFERRED_PROFIT_SHARING_PLAN</li><li>NON_REGISTERED_SAVINGS_PLAN</li><li>REGISTERED_EDUCATION_SAVINGS_PLAN</li><li>GROUP_RETIREMENT_SAVINGS_PLAN</li><li>LOCKED_IN_RETIREMENT_SAVINGS_PLAN</li><li>RESTRICTED_LOCKED_IN_SAVINGS_PLAN</li><li>LOCKED_IN_RETIREMENT_ACCOUNT</li><li>REGISTERED_PENSION_PLAN</li><li>TAX_FREE_SAVINGS_ACCOUNT</li><li>LIFE_INCOME_FUND</li><li>REGISTERED_RETIREMENT_INCOME_FUND</li><li>SPOUSAL_RETIREMENT_INCOME_FUND</li><li>LOCKED_IN_REGISTERED_INVESTMENT_FUND</li><li>PRESCRIBED_REGISTERED_RETIREMENT_INCOME_FUND</li><li>GUARANTEED_INVESTMENT_CERTIFICATES</li><li>REGISTERED_DISABILITY_SAVINGS_PLAN</li><li>DIGITAL_WALLET</li><li>OTHER</li></ul><b>investment (SN 2.0)</b><ul><li>BROKERAGE_CASH</li><li>BROKERAGE_MARGIN</li><li>INDIVIDUAL_RETIREMENT_ACCOUNT_IRA</li><li>EMPLOYEE_RETIREMENT_ACCOUNT_401K</li><li>EMPLOYEE_RETIREMENT_SAVINGS_PLAN_403B</li><li>TRUST</li><li>ANNUITY</li><li>SIMPLE_IRA</li><li>CUSTODIAL_ACCOUNT</li><li>BROKERAGE_CASH_OPTION</li><li>BROKERAGE_MARGIN_OPTION</li><li>INDIVIDUAL</li><li>CORPORATE_INVESTMENT_ACCOUNT</li><li>JOINT_TENANTS_TENANCY_IN_COMMON_JTIC</li><li>JOINT_TENANTS_WITH_RIGHTS_OF_SURVIVORSHIP_JTWROS</li><li>JOINT_TENANTS_COMMUNITY_PROPERTY</li><li>JOINT_TENANTS_TENANTS_BY_ENTIRETY</li><li>CONSERVATOR</li><li>ROTH_IRA</li><li>ROTH_CONVERSION</li><li>ROLLOVER_IRA</li><li>EDUCATIONAL</li><li>EDUCATIONAL_SAVINGS_PLAN_529</li><li>DEFERRED_COMPENSATION_PLAN_457</li><li>MONEY_PURCHASE_RETIREMENT_PLAN_401A</li><li>PROFIT_SHARING_PLAN</li><li>MONEY_PURCHASE_PLAN</li><li>STOCK_BASKET_ACCOUNT</li><li>LIVING_TRUST</li><li>REVOCABLE_TRUST</li><li>IRREVOCABLE_TRUST</li><li>CHARITABLE_REMAINDER_TRUST</li><li>CHARITABLE_LEAD_TRUST</li><li>CHARITABLE_GIFT_ACCOUNT</li><li>SEP_IRA</li><li>UNIFORM_TRANSFER_TO_MINORS_ACT_UTMA</li><li>UNIFORM_GIFT_TO_MINORS_ACT_UGMA</li><li>EMPLOYEE_STOCK_OWNERSHIP_PLAN_ESOP</li><li>ADMINISTRATOR</li><li>EXECUTOR</li><li>PARTNERSHIP</li><li>PROPRIETORSHIP</li><li>CHURCH_ACCOUNT</li><li>INVESTMENT_CLUB</li><li>RESTRICTED_STOCK_AWARD</li><li>CASH_MANAGEMENT_ACCOUNT</li><li>EMPLOYEE_STOCK_PURCHASE_PLAN_ESPP</li><li>PERFORMANCE_PLAN</li><li>BROKERAGE_LINK_ACCOUNT</li><li>MONEY_MARKET_ACCOUNT</li><li>SUPERANNUATION</li><li>REGISTERED_RETIREMENT_SAVINGS_PLAN_RRSP</li><li>SPOUSAL_RETIREMENT_SAVINGS_PLAN_SRSP</li><li>DEFERRED_PROFIT_SHARING_PLAN_DPSP</li><li>NON_REGISTERED_SAVINGS_PLAN_NRSP</li><li>REGISTERED_EDUCATION_SAVINGS_PLAN_RESP</li><li>GROUP_RETIREMENT_SAVINGS_PLAN_GRSP</li><li>LOCKED_IN_RETIREMENT_SAVINGS_PLAN_LRSP</li><li>RESTRICTED_LOCKED_IN_SAVINGS_PLAN_RLSP</li><li>LOCKED_IN_RETIREMENT_ACCOUNT_LIRA</li><li>REGISTERED_PENSION_PLAN_RPP</li><li>TAX_FREE_SAVINGS_ACCOUNT_TFSA</li><li>LIFE_INCOME_FUND_LIF</li><li>REGISTERED_RETIREMENT_INCOME_FUND_RIF</li><li>SPOUSAL_RETIREMENT_INCOME_FUND_SRIF</li><li>LOCKED_IN_REGISTERED_INVESTMENT_FUND_LRIF</li><li>PRESCRIBED_REGISTERED_RETIREMENT_INCOME_FUND_PRIF</li><li>GUARANTEED_INVESTMENT_CERTIFICATES_GIC</li><li>REGISTERED_DISABILITY_SAVINGS_PLAN_RDSP</li><li>DEFINED_CONTRIBUTION_PLAN</li><li>DEFINED_BENEFIT_PLAN</li><li>EMPLOYEE_STOCK_OPTION_PLAN</li><li>NONQUALIFIED_DEFERRED_COMPENSATION_PLAN_409A</li><li>KEOGH_PLAN</li><li>EMPLOYEE_RETIREMENT_ACCOUNT_ROTH_401K</li><li>DEFERRED_CONTINGENT_CAPITAL_PLAN_DCCP</li><li>EMPLOYEE_BENEFIT_PLAN</li><li>EMPLOYEE_SAVINGS_PLAN</li><li>HEALTH_SAVINGS_ACCOUNT_HSA</li><li>COVERDELL_EDUCATION_SAVINGS_ACCOUNT_ESA</li><li>TESTAMENTARY_TRUST</li><li>ESTATE</li><li>GRANTOR_RETAINED_ANNUITY_TRUST_GRAT</li><li>ADVISORY_ACCOUNT</li><li>NON_PROFIT_ORGANIZATION_501C</li><li>HEALTH_REIMBURSEMENT_ARRANGEMENT_HRA</li><li>INDIVIDUAL_SAVINGS_ACCOUNT_ISA</li><li>CASH_ISA</li><li>STOCKS_AND_SHARES_ISA</li><li>INNOVATIVE_FINANCE_ISA</li><li>JUNIOR_ISA</li><li>EMPLOYEES_PROVIDENT_FUND_ORGANIZATION_EPFO</li><li>PUBLIC_PROVIDENT_FUND_PPF</li><li>EMPLOYEES_PENSION_SCHEME_EPS</li><li>NATIONAL_PENSION_SYSTEM_NPS</li><li>INDEXED_ANNUITY</li><li>ANNUITIZED_ANNUITY</li><li>VARIABLE_ANNUITY</li><li>ROTH_403B</li><li>SPOUSAL_IRA</li><li>SPOUSAL_ROTH_IRA</li><li>SARSEP_IRA</li><li>SUBSTANTIALLY_EQUAL_PERIODIC_PAYMENTS_SEPP</li><li>OFFSHORE_TRUST</li><li>IRREVOCABLE_LIFE_INSURANCE_TRUST</li><li>INTERNATIONAL_TRUST</li><li>LIFE_INTEREST_TRUST</li><li>EMPLOYEE_BENEFIT_TRUST</li><li>PRECIOUS_METAL_ACCOUNT</li><li>INVESTMENT_LOAN_ACCOUNT</li><li>GRANTOR_RETAINED_INCOME_TRUST</li><li>PENSION_PLAN</li><li>DIGITAL_WALLET</li><li>OTHER</li></ul><b>loan</b><ul><li>MORTGAGE</li><li>INSTALLMENT_LOAN</li><li>PERSONAL_LOAN</li><li>HOME_EQUITY_LINE_OF_CREDIT</li><li>LINE_OF_CREDIT</li><li>AUTO_LOAN</li><li>STUDENT_LOAN</li><li>HOME_LOAN</li></ul><b>insurance</b><ul><li>AUTO_INSURANCE</li><li>HEALTH_INSURANCE</li><li>HOME_INSURANCE</li><li>LIFE_INSURANCE</li><li>ANNUITY</li><li>TRAVEL_INSURANCE</li><li>INSURANCE</li></ul><b>realEstate</b><ul> <li>REAL_ESTATE</li></ul><b>reward</b><ul><li>REWARD_POINTS</li></ul><b>Manual Account Type</b><br><b>bank</b><ul><li>CHECKING</li><li>SAVINGS</li><li>CD</li><li>PREPAID</li></ul><b>credit</b><ul>  <li>CREDIT</li></ul><b>loan</b><ul>  <li>PERSONAL_LOAN</li><li>HOME_LOAN</li></ul><b>insurance</b><ul><li>INSURANCE</li><li>ANNUITY</li></ul><b>investment</b><ul><li>BROKERAGE_CASH</li></ul><br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br></ul>
     * @type {string}
     * @memberof VerifiedAccount
     */
    accountType?: string;
    /**
     * The primary key of the provider account resource.<br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br>
     * @type {number}
     * @memberof VerifiedAccount
     */
    providerAccountId?: number;
    /**
     * 
     * @type {Array<AccountHolder>}
     * @memberof VerifiedAccount
     */
    holder?: Array<AccountHolder>;
    /**
     * 
     * @type {number}
     * @memberof VerifiedAccount
     */
    id?: number;
    /**
     * The account number as it appears on the site. (The POST accounts service response return this field as number)<br><b>Additional Details</b>:<b> Bank/ Loan/ Insurance/ Investment</b>:<br> The account number for the bank account as it appears at the site.<br><b>Credit Card</b>: The account number of the card account as it appears at the site,<br>i.e., the card number.The account number can be full or partial based on how it is displayed in the account summary page of the site.In most cases, the site does not display the full account number in the account summary page and additional navigation is required to aggregate it.<br><b>Applicable containers</b>: All Containers<br><b>Aggregated / Manual</b>: Both <br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>POST accounts</li></ul>
     * @type {string}
     * @memberof VerifiedAccount
     */
    accountNumber?: string;
    /**
     * Bank and branch identification information.<br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank, investment, loan<br><b>Endpoints</b>:<br><ul></ul>
     * @type {Array<BankTransferCode>}
     * @memberof VerifiedAccount
     */
    bankTransferCode?: Array<BankTransferCode>;
    /**
     * <b>Applicable containers</b>: reward, bank, creditCard, investment, loan, insurance, realEstate, otherLiabilities<br>
     * @type {string}
     * @memberof VerifiedAccount
     */
    providerName?: string;
}
/**
 * 
 * @export
 * @interface VerifiedAccountResponse
 */
export interface VerifiedAccountResponse {
    /**
     * The unique identifier for the verification request that returns contextual data
     * @type {string}
     * @memberof VerifiedAccountResponse
     */
    requestId?: string;
    /**
     * The date of the verification request
     * @type {string}
     * @memberof VerifiedAccountResponse
     */
    requestDate?: string;
    /**
     * The overall status of the verification request
     * @type {string}
     * @memberof VerifiedAccountResponse
     */
    state?: VerifiedAccountResponse.StateEnum;
    /**
     * 
     * @type {Array<VerifiedAccounts>}
     * @memberof VerifiedAccountResponse
     */
    verifiedAccount?: Array<VerifiedAccounts>;
    /**
     * The reason for the failure of the verification request
     * @type {string}
     * @memberof VerifiedAccountResponse
     */
    failedReason?: VerifiedAccountResponse.FailedReasonEnum;
}

/**
 * @export
 * @namespace VerifiedAccountResponse
 */
export namespace VerifiedAccountResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        COMPLETED = <any> 'COMPLETED',
        FAILED = <any> 'FAILED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum FailedReasonEnum {
        ACCOUNTLOCKED = <any> 'ACCOUNT_LOCKED',
        ADDLAUTHENTICATIONREQUIRED = <any> 'ADDL_AUTHENTICATION_REQUIRED',
        CREDENTIALSUPDATENEEDED = <any> 'CREDENTIALS_UPDATE_NEEDED',
        INCORRECTCREDENTIALS = <any> 'INCORRECT_CREDENTIALS',
        INVALIDADDLINFOPROVIDED = <any> 'INVALID_ADDL_INFO_PROVIDED',
        REQUESTTIMEOUT = <any> 'REQUEST_TIME_OUT',
        SITEBLOCKINGERROR = <any> 'SITE_BLOCKING_ERROR',
        UNEXPECTEDSITEERROR = <any> 'UNEXPECTED_SITE_ERROR',
        SITENOTSUPPORTED = <any> 'SITE_NOT_SUPPORTED',
        SITEUNAVAILABLE = <any> 'SITE_UNAVAILABLE',
        TECHERROR = <any> 'TECH_ERROR',
        USERACTIONNEEDEDATSITE = <any> 'USER_ACTION_NEEDED_AT_SITE',
        SITESESSIONINVALIDATED = <any> 'SITE_SESSION_INVALIDATED',
        NEWAUTHENTICATIONREQUIRED = <any> 'NEW_AUTHENTICATION_REQUIRED',
        CONSENTREQUIRED = <any> 'CONSENT_REQUIRED',
        CONSENTEXPIRED = <any> 'CONSENT_EXPIRED',
        CONSENTREVOKED = <any> 'CONSENT_REVOKED',
        INCORRECTOAUTHTOKEN = <any> 'INCORRECT_OAUTH_TOKEN',
        REQUIREDDATANOTAVAILABLE = <any> 'REQUIRED_DATA_NOT_AVAILABLE',
        MATCHINGFAILED = <any> 'MATCHING_FAILED',
        NOELIGIBLEACCOUNTS = <any> 'NO_ELIGIBLE_ACCOUNTS',
        USERINPUTREQUIRED = <any> 'USER_INPUT_REQUIRED'
    }
}
/**
 * 
 * @export
 * @interface VerifiedAccounts
 */
export interface VerifiedAccounts {
    /**
     * The account name as it appears at the site.<br>(The POST accounts service response return this field as name)<br><b>Applicable containers</b>: bank, investment<br><b>Aggregated / Manual</b>: Aggregated<br><b>Endpoints</b>:<br><ul><li>GET /verification/verifiedAccounts</li></ul>
     * @type {string}
     * @memberof VerifiedAccounts
     */
    accountName?: string;
    /**
     * The status of the account verification.
     * @type {string}
     * @memberof VerifiedAccounts
     */
    verificationStatus?: VerifiedAccounts.VerificationStatusEnum;
    /**
     * The type of account that is aggregated, i.e., savings, checking, charge, HELOC, etc. The account type is derived based on the attributes of the account. <br><b>Valid Values:</b><br><b>Aggregated Account Type</b><br><b>bank</b><ul><li>CHECKING</li><li>SAVINGS</li><li>MONEY_MARKET</li></ul><b>investment (SN 1.0)</b><ul><li>BROKERAGE_MARGIN</li><li>BROKERAGE_CASH</li><li>BROKERAGE_LINK_ACCOUNT</li><li>INDIVIDUAL</li><li>CMA</li></ul><b>investment (SN 2.0)</b><ul><li>BROKERAGE_MARGIN</li><li>BROKERAGE_CASH</li><li>BROKERAGE_LINK_ACCOUNT</li><li>INDIVIDUAL</li><li>CMA</li></ul><ul><li>GET /verification/verifiedAccounts</li></ul>
     * @type {string}
     * @memberof VerifiedAccounts
     */
    accountType?: string;
    /**
     * 
     * @type {Money}
     * @memberof VerifiedAccounts
     */
    currentBalance?: Money;
    /**
     * The name or identification of the account owner, as it appears at the FI site. <br><b>Note:</b> The account holder name can be full or partial based on how it is displayed in the account summary page of the FI site. In most cases, the FI site does not display the full account holder name in the account summary page.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank, investment<br><b>Endpoints</b>:<ul><li>GET /verification/verifiedAccounts</li></ul>
     * @type {string}
     * @memberof VerifiedAccounts
     */
    displayedName?: string;
    /**
     * Holder details of the account.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank<br><b>Endpoints</b>:<ul><li>GET /verification/verifiedAccounts</li></ul>
     * @type {Array<AccountHolder>}
     * @memberof VerifiedAccounts
     */
    holder?: Array<AccountHolder>;
    /**
     * The account number as it appears on the site. (The POST accounts service response return this field as number)<br><b>Additional Details</b>:<b> Bank / Investment</b>:<br> The account number for the bank account as it appears at the site.<br>In most cases, the site does not display the full account number in the account summary page and additional navigation is required to aggregate it.<br><b>Applicable containers</b>: bank, investment<br><b>Aggregated / Manual</b>: Aggregated<br><b>Endpoints</b>:<br><ul><li>GET /verification/verifiedAccounts</li></ul>
     * @type {string}
     * @memberof VerifiedAccounts
     */
    accountNumber?: string;
    /**
     * The classification of the account such as personal, corporate, etc.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank, investment<br><b>Endpoints</b>:<li>GET /verification/verifiedAccounts</li></ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof VerifiedAccounts
     */
    classification?: VerifiedAccounts.ClassificationEnum;
    /**
     * 
     * @type {Money}
     * @memberof VerifiedAccounts
     */
    availableBalance?: Money;
    /**
     * 
     * @type {FullAccountNumberList}
     * @memberof VerifiedAccounts
     */
    fullAccountNumberList?: FullAccountNumberList;
    /**
     * The primary key of the provider account resource.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank, investment<br><b>Endpoints</b>:<ul><li>GET /verification/verifiedAccounts</li></ul>
     * @type {number}
     * @memberof VerifiedAccounts
     */
    accountId?: number;
    /**
     * Attribute to return the classification of the account age by specifying whether the account is old/new/recent as relevant for a verification use case. If it could not be classified into any one of these values, the attribute would return the value as 'unclassified'
     * @type {string}
     * @memberof VerifiedAccounts
     */
    accountAgeClassification?: VerifiedAccounts.AccountAgeClassificationEnum;
    /**
     * 
     * @type {Money}
     * @memberof VerifiedAccounts
     */
    balance?: Money;
    /**
     * Identifier of the provider site. The primary key of provider resource. <br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank, investment<br><b>Endpoints</b>:<ul><li>GET /verification/verifiedAccounts</li></ul>
     * @type {string}
     * @memberof VerifiedAccounts
     */
    providerId?: string;
    /**
     * The primary key of the provider account resource.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank, investment<br><b>Endpoints</b>:<ul><li>GET /verification/verifiedAccounts</li></ul>
     * @type {number}
     * @memberof VerifiedAccounts
     */
    providerAccountId?: number;
    /**
     * The type of service. E.g., Bank, Investment <br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank, investment<br><b>Endpoints</b>:<ul><li>GET /verification/verifiedAccounts</ul><b>Applicable Values</b><br>
     * @type {string}
     * @memberof VerifiedAccounts
     */
    CONTAINER?: VerifiedAccounts.CONTAINEREnum;
    /**
     * Indicates if an account is selected by the user in the FastLink 4 application
     * @type {boolean}
     * @memberof VerifiedAccounts
     */
    isSelected?: boolean;
    /**
     * 
     * @type {Money}
     * @memberof VerifiedAccounts
     */
    cash?: Money;
    /**
     * Bank and branch identification information.<br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank, investment<br><b>Endpoints</b>:<br><ul><li>GET /verification/verifiedAccounts</li></ul>
     * @type {Array<BankTransferCode>}
     * @memberof VerifiedAccounts
     */
    bankTransferCode?: Array<BankTransferCode>;
    /**
     * Service provider or institution name where the account originates. This belongs to the provider resource.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank, investment<br><b>Endpoints</b>:<ul><li>GET /verification/verifiedAccounts</li></ul>
     * @type {string}
     * @memberof VerifiedAccounts
     */
    providerName?: string;
    /**
     * The reason for the verification failure of the account.
     * @type {string}
     * @memberof VerifiedAccounts
     */
    failedReason?: VerifiedAccounts.FailedReasonEnum;
}

/**
 * @export
 * @namespace VerifiedAccounts
 */
export namespace VerifiedAccounts {
    /**
     * @export
     * @enum {string}
     */
    export enum VerificationStatusEnum {
        SUCCESS = <any> 'SUCCESS',
        FAILED = <any> 'FAILED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ClassificationEnum {
        OTHER = <any> 'OTHER',
        PERSONAL = <any> 'PERSONAL',
        CORPORATE = <any> 'CORPORATE',
        SMALLBUSINESS = <any> 'SMALL_BUSINESS',
        TRUST = <any> 'TRUST',
        ADDONCARD = <any> 'ADD_ON_CARD',
        VIRTUALCARD = <any> 'VIRTUAL_CARD'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum AccountAgeClassificationEnum {
        UNCLASSIFIED = <any> 'UNCLASSIFIED',
        OLD = <any> 'OLD',
        NEW = <any> 'NEW',
        RECENT = <any> 'RECENT'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum CONTAINEREnum {
        Bank = <any> 'bank',
        Investment = <any> 'investment'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum FailedReasonEnum {
        REQUIREDDATANOTAVAILABLE = <any> 'REQUIRED_DATA_NOT_AVAILABLE',
        MATCHINGFAILED = <any> 'MATCHING_FAILED'
    }
}
/**
 * 
 * @export
 * @interface VerifyAccount
 */
export interface VerifyAccount {
    /**
     * 
     * @type {Array<VerifyTransactionCriteria>}
     * @memberof VerifyAccount
     */
    transactionCriteria?: Array<VerifyTransactionCriteria>;
    /**
     * 
     * @type {Array<VerifiedAccount>}
     * @memberof VerifyAccount
     */
    account?: Array<VerifiedAccount>;
}
/**
 * 
 * @export
 * @interface VerifyAccountRequest
 */
export interface VerifyAccountRequest {
    /**
     * 
     * @type {string}
     * @memberof VerifyAccountRequest
     */
    container?: VerifyAccountRequest.ContainerEnum;
    /**
     * 
     * @type {number}
     * @memberof VerifyAccountRequest
     */
    accountId?: number;
    /**
     * 
     * @type {Array<VerifyTransactionCriteria>}
     * @memberof VerifyAccountRequest
     */
    transactionCriteria: Array<VerifyTransactionCriteria>;
}

/**
 * @export
 * @namespace VerifyAccountRequest
 */
export namespace VerifyAccountRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum ContainerEnum {
        Bank = <any> 'bank',
        CreditCard = <any> 'creditCard',
        Investment = <any> 'investment',
        Insurance = <any> 'insurance',
        Loan = <any> 'loan',
        Reward = <any> 'reward',
        Bill = <any> 'bill',
        RealEstate = <any> 'realEstate',
        OtherAssets = <any> 'otherAssets',
        OtherLiabilities = <any> 'otherLiabilities'
    }
}
/**
 * 
 * @export
 * @interface VerifyAccountResponse
 */
export interface VerifyAccountResponse {
    /**
     * 
     * @type {VerifyAccount}
     * @memberof VerifyAccountResponse
     */
    verifyAccount?: VerifyAccount;
}
/**
 * 
 * @export
 * @interface VerifyTransactionCriteria
 */
export interface VerifyTransactionCriteria {
    /**
     * 
     * @type {string}
     * @memberof VerifyTransactionCriteria
     */
    date: string;
    /**
     * 
     * @type {number}
     * @memberof VerifyTransactionCriteria
     */
    amount: number;
    /**
     * 
     * @type {Array<Transaction>}
     * @memberof VerifyTransactionCriteria
     */
    verifiedTransaction?: Array<Transaction>;
    /**
     * Indicates if the criteria is matched or not. <br><b>Applicable Values</b><br>
     * @type {string}
     * @memberof VerifyTransactionCriteria
     */
    matched?: VerifyTransactionCriteria.MatchedEnum;
    /**
     * 
     * @type {string}
     * @memberof VerifyTransactionCriteria
     */
    keyword?: string;
    /**
     * 
     * @type {string}
     * @memberof VerifyTransactionCriteria
     */
    dateVariance?: string;
    /**
     * Indicates if the transaction appears as a debit or a credit transaction in the account. <br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br><b>Applicable Values</b><br>
     * @type {string}
     * @memberof VerifyTransactionCriteria
     */
    baseType?: VerifyTransactionCriteria.BaseTypeEnum;
}

/**
 * @export
 * @namespace VerifyTransactionCriteria
 */
export namespace VerifyTransactionCriteria {
    /**
     * @export
     * @enum {string}
     */
    export enum MatchedEnum {
        COMPLETE = <any> 'COMPLETE',
        NONE = <any> 'NONE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum BaseTypeEnum {
        CREDIT = <any> 'CREDIT',
        DEBIT = <any> 'DEBIT'
    }
}
/**
 * 
 * @export
 * @interface YodleeError
 */
export interface YodleeError {
    /**
     * The descriptive message that explains the error scenario.
     * @type {string}
     * @memberof YodleeError
     */
    errorMessage?: string;
    /**
     * The error code follows the format YNNN. The error codes do not change. New error codes may be added as we introduce new features and enhance functionalities.
     * @type {string}
     * @memberof YodleeError
     */
    errorCode?: string;
    /**
     * Unique Yodlee identifier used to troubleshoot issues at Yodlees end.
     * @type {string}
     * @memberof YodleeError
     */
    referenceCode?: string;
}
/**
 * AccountsApi - fetch parameter creator
 * @export
 */
export const AccountsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The add account service is used to add manual accounts.<br>The response of add account service includes the account name , account number and Yodlee generated account id.<br>All manual accounts added will be included as part of networth calculation by default.<br>Add manual account support is available for bank, card, investment, insurance and loan container only.<br><br><b>Note:</b><ul> <li>A real estate account addition is only supported for SYSTEM and MANUAL valuation type.</li></ul>
         * @summary Add Manual Account
         * @param {CreateAccountRequest} body accountParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createManualAccount(body: CreateAccountRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createManualAccount.');
            }
            const localVarPath = `/accounts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateAccountRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The delete account service allows an account to be deleted.<br>This service does not return a response. The HTTP response code is 204 (Success with no content).<br>
         * @summary Delete Account
         * @param {number} accountId accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(accountId: number, options: any = {}): FetchArgs {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling deleteAccount.');
            }
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this service to validate the address before adding the real estate account.<br>If the address is valid, the service will return the complete address information.<br>The response will contain multiple addresses if the user-provided input matches with multiple entries in the vendor database.<br>In the case of multiple matches, the user can select the appropriate address from the list and then invoke the add account service with the complete address.<br><br><b>Note:</b> <ul><li>Yodlee recommends to use this service before adding the real estate account to avoid failures.</li></ul>
         * @summary Evaluate Address
         * @param {EvaluateAddressRequest} body addressParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateAddress(body: EvaluateAddressRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling evaluateAddress.');
            }
            const localVarPath = `/accounts/evaluateAddress`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EvaluateAddressRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The get account details service provides detailed information of an account.<br><br><b>Note:</b><li> fullAccountNumber is deprecated and is replaced with fullAccountNumberList in include parameter and response.</li>
         * @summary Get Account Details
         * @param {number} accountId accountId
         * @param {string} [include] profile, holder, fullAccountNumber, fullAccountNumberList, paymentProfile, autoRefresh&lt;br&gt;&lt;b&gt;Note:&lt;/b&gt;fullAccountNumber is deprecated and is replaced with fullAccountNumberList in include parameter and response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(accountId: number, include?: string, options: any = {}): FetchArgs {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getAccount.');
            }
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <i>This API implementation notes is intended for FastLink 4 users. For FastLink 3 users, additional integration notes related to this endpoint is available <a href=\"https://developer.envestnet.com/resources/yodlee/fastlink-3/docs/api-integrations\">here</a>.</i><br><br>The get accounts service provides information about accounts added by the user.<br>By default, this service returns information for active and to be closed accounts.<br>If requestId is provided, the accounts that are updated in the context of the requestId will be provided in the response.<br><br> This API returns all the accounts that were chosen by the user in both the verification selection screen and the aggregation selection screen. In FastLink 4, we have separate APIs to provide the data for verification product-related data (/verification/verifiedAccounts) and the GET accounts should be utilized with an additional query param (isSelectedForAggregation=true) to retrieve only the aggregation accounts.
         * @summary Get Accounts
         * @param {string} [accountId] Comma separated accountIds.
         * @param {string} [container] bank/creditCard/investment/insurance/loan/reward/realEstate/otherAssets/otherLiabilities
         * @param {string} [include] profile, paymentProfile, autoRefresh&lt;br&gt;&lt;b&gt;Note:&lt;/b&gt;&lt;br&gt;&lt;li&gt;fullAccountNumber is deprecated and is replaced with fullAccountNumberList in include parameter and response.&lt;/li&gt;&lt;br&gt;&lt;li&gt;profile is deprecated, and to retrieve the profile information, call the GET /verification/holderProfile API instead.&lt;/li&gt;
         * @param {string} [providerAccountId] Comma separated providerAccountIds.
         * @param {string} [requestId] The unique identifier that returns contextual data
         * @param {string} [status] ACTIVE,INACTIVE,TO_BE_CLOSED,CLOSED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAccounts(accountId?: string, container?: string, include?: string, providerAccountId?: string, requestId?: string, status?: string, options: any = {}): FetchArgs {
            const localVarPath = `/accounts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (container !== undefined) {
                localVarQueryParameter['container'] = container;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            if (providerAccountId !== undefined) {
                localVarQueryParameter['providerAccountId'] = providerAccountId;
            }

            if (requestId !== undefined) {
                localVarQueryParameter['requestId'] = requestId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The historical balances service is used to retrieve the historical balances for an account or a user.<br>Historical balances are daily (D), weekly (W), and monthly (M). <br>The interval input should be passed as D, W, and M to retrieve the desired historical balances. The default interval is daily (D). <br>When no account id is provided, historical balances of the accounts that are active, to be closed, and closed are provided in the response. <br>If the fromDate and toDate are not passed, the last 90 days of data will be provided. <br>The fromDate and toDate should be passed in the YYYY-MM-DD format. <br>The date field in the response denotes the date for which the balance is requested.<br>includeCF needs to be sent as true if the customer wants to return carried forward balances for a date when the data is not available. <br>asofDate field in the response denotes the date as of which the balance was updated for that account.<br>When there is no balance available for a requested date and if includeCF is sent as true, the previous date for which the balance is available is provided in the response. <br>When there is no previous balance available, no data will be sent. <br>By default, pagination is available for the historicalBalances entity in this API. The skip and top parameters are used for pagination. In the skip and top parameters, pass the number of records to be skipped and retrieved, respectively. The response header provides the links to retrieve the next and previous set of historical balances.<br> The API will only retrieve a maximum 500 records by default when values for skip and top parameters are not provided.
         * @summary Get Historical Balances
         * @param {string} [accountId] accountId
         * @param {string} [fromDate] from date for balance retrieval (YYYY-MM-DD)
         * @param {boolean} [includeCF] Consider carry forward logic for missing balances
         * @param {string} [interval] D-daily, W-weekly or M-monthly
         * @param {number} [skip] skip (Min 0)
         * @param {string} [toDate] toDate for balance retrieval (YYYY-MM-DD)
         * @param {number} [top] top (Max 500)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricalBalances(accountId?: string, fromDate?: string, includeCF?: boolean, interval?: string, skip?: number, toDate?: string, top?: number, options: any = {}): FetchArgs {
            const localVarPath = `/accounts/historicalBalances`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (includeCF !== undefined) {
                localVarQueryParameter['includeCF'] = includeCF;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }

            if (top !== undefined) {
                localVarQueryParameter['top'] = top;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The latest balances service provides the latest account balance by initiating a new balance refresh request
         * @summary Get Latest Balances
         * @param {string} accountId Comma separated accountIds.
         * @param {string} providerAccountId providerAccountId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestBalances(accountId: string, providerAccountId: string, options: any = {}): FetchArgs {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getLatestBalances.');
            }
            // verify required parameter 'providerAccountId' is not null or undefined
            if (providerAccountId === null || providerAccountId === undefined) {
                throw new RequiredError('providerAccountId','Required parameter providerAccountId was null or undefined when calling getLatestBalances.');
            }
            const localVarPath = `/accounts/latestBalances`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (providerAccountId !== undefined) {
                localVarQueryParameter['providerAccountId'] = providerAccountId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The update account service is used to update manual and aggregated accounts.<br>The HTTP response code is 204 (Success without content).<br>Update manual account support is available for bank, card, investment, insurance, loan, otherAssets, otherLiabilities and realEstate containers only.<br><br><b>Note:</b><li> A real estate account update is only supported for SYSTEM and MANUAL valuation type.</li> <li> A real estate account can be linked to a loan account by passing accountId of a loan account in linkedAccountIds .</li> <li> Attribute <b>isEbillEnrolled</b> is deprecated as it is applicable for bill accounts only.</li>
         * @summary Update Account
         * @param {UpdateAccountRequest} body accountRequest
         * @param {number} accountId accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(body: UpdateAccountRequest, accountId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateAccount.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling updateAccount.');
            }
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateAccountRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * The add account service is used to add manual accounts.<br>The response of add account service includes the account name , account number and Yodlee generated account id.<br>All manual accounts added will be included as part of networth calculation by default.<br>Add manual account support is available for bank, card, investment, insurance and loan container only.<br><br><b>Note:</b><ul> <li>A real estate account addition is only supported for SYSTEM and MANUAL valuation type.</li></ul>
         * @summary Add Manual Account
         * @param {CreateAccountRequest} body accountParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createManualAccount(body: CreateAccountRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreatedAccountResponse> {
            const localVarFetchArgs = AccountsApiFetchParamCreator(configuration).createManualAccount(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The delete account service allows an account to be deleted.<br>This service does not return a response. The HTTP response code is 204 (Success with no content).<br>
         * @summary Delete Account
         * @param {number} accountId accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(accountId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountsApiFetchParamCreator(configuration).deleteAccount(accountId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Use this service to validate the address before adding the real estate account.<br>If the address is valid, the service will return the complete address information.<br>The response will contain multiple addresses if the user-provided input matches with multiple entries in the vendor database.<br>In the case of multiple matches, the user can select the appropriate address from the list and then invoke the add account service with the complete address.<br><br><b>Note:</b> <ul><li>Yodlee recommends to use this service before adding the real estate account to avoid failures.</li></ul>
         * @summary Evaluate Address
         * @param {EvaluateAddressRequest} body addressParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateAddress(body: EvaluateAddressRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EvaluateAddressResponse> {
            const localVarFetchArgs = AccountsApiFetchParamCreator(configuration).evaluateAddress(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The get account details service provides detailed information of an account.<br><br><b>Note:</b><li> fullAccountNumber is deprecated and is replaced with fullAccountNumberList in include parameter and response.</li>
         * @summary Get Account Details
         * @param {number} accountId accountId
         * @param {string} [include] profile, holder, fullAccountNumber, fullAccountNumberList, paymentProfile, autoRefresh&lt;br&gt;&lt;b&gt;Note:&lt;/b&gt;fullAccountNumber is deprecated and is replaced with fullAccountNumberList in include parameter and response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(accountId: number, include?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountResponse> {
            const localVarFetchArgs = AccountsApiFetchParamCreator(configuration).getAccount(accountId, include, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * <i>This API implementation notes is intended for FastLink 4 users. For FastLink 3 users, additional integration notes related to this endpoint is available <a href=\"https://developer.envestnet.com/resources/yodlee/fastlink-3/docs/api-integrations\">here</a>.</i><br><br>The get accounts service provides information about accounts added by the user.<br>By default, this service returns information for active and to be closed accounts.<br>If requestId is provided, the accounts that are updated in the context of the requestId will be provided in the response.<br><br> This API returns all the accounts that were chosen by the user in both the verification selection screen and the aggregation selection screen. In FastLink 4, we have separate APIs to provide the data for verification product-related data (/verification/verifiedAccounts) and the GET accounts should be utilized with an additional query param (isSelectedForAggregation=true) to retrieve only the aggregation accounts.
         * @summary Get Accounts
         * @param {string} [accountId] Comma separated accountIds.
         * @param {string} [container] bank/creditCard/investment/insurance/loan/reward/realEstate/otherAssets/otherLiabilities
         * @param {string} [include] profile, paymentProfile, autoRefresh&lt;br&gt;&lt;b&gt;Note:&lt;/b&gt;&lt;br&gt;&lt;li&gt;fullAccountNumber is deprecated and is replaced with fullAccountNumberList in include parameter and response.&lt;/li&gt;&lt;br&gt;&lt;li&gt;profile is deprecated, and to retrieve the profile information, call the GET /verification/holderProfile API instead.&lt;/li&gt;
         * @param {string} [providerAccountId] Comma separated providerAccountIds.
         * @param {string} [requestId] The unique identifier that returns contextual data
         * @param {string} [status] ACTIVE,INACTIVE,TO_BE_CLOSED,CLOSED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAccounts(accountId?: string, container?: string, include?: string, providerAccountId?: string, requestId?: string, status?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountResponse> {
            const localVarFetchArgs = AccountsApiFetchParamCreator(configuration).getAllAccounts(accountId, container, include, providerAccountId, requestId, status, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The historical balances service is used to retrieve the historical balances for an account or a user.<br>Historical balances are daily (D), weekly (W), and monthly (M). <br>The interval input should be passed as D, W, and M to retrieve the desired historical balances. The default interval is daily (D). <br>When no account id is provided, historical balances of the accounts that are active, to be closed, and closed are provided in the response. <br>If the fromDate and toDate are not passed, the last 90 days of data will be provided. <br>The fromDate and toDate should be passed in the YYYY-MM-DD format. <br>The date field in the response denotes the date for which the balance is requested.<br>includeCF needs to be sent as true if the customer wants to return carried forward balances for a date when the data is not available. <br>asofDate field in the response denotes the date as of which the balance was updated for that account.<br>When there is no balance available for a requested date and if includeCF is sent as true, the previous date for which the balance is available is provided in the response. <br>When there is no previous balance available, no data will be sent. <br>By default, pagination is available for the historicalBalances entity in this API. The skip and top parameters are used for pagination. In the skip and top parameters, pass the number of records to be skipped and retrieved, respectively. The response header provides the links to retrieve the next and previous set of historical balances.<br> The API will only retrieve a maximum 500 records by default when values for skip and top parameters are not provided.
         * @summary Get Historical Balances
         * @param {string} [accountId] accountId
         * @param {string} [fromDate] from date for balance retrieval (YYYY-MM-DD)
         * @param {boolean} [includeCF] Consider carry forward logic for missing balances
         * @param {string} [interval] D-daily, W-weekly or M-monthly
         * @param {number} [skip] skip (Min 0)
         * @param {string} [toDate] toDate for balance retrieval (YYYY-MM-DD)
         * @param {number} [top] top (Max 500)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricalBalances(accountId?: string, fromDate?: string, includeCF?: boolean, interval?: string, skip?: number, toDate?: string, top?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountHistoricalBalancesResponse> {
            const localVarFetchArgs = AccountsApiFetchParamCreator(configuration).getHistoricalBalances(accountId, fromDate, includeCF, interval, skip, toDate, top, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The latest balances service provides the latest account balance by initiating a new balance refresh request
         * @summary Get Latest Balances
         * @param {string} accountId Comma separated accountIds.
         * @param {string} providerAccountId providerAccountId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestBalances(accountId: string, providerAccountId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountBalanceResponse> {
            const localVarFetchArgs = AccountsApiFetchParamCreator(configuration).getLatestBalances(accountId, providerAccountId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The update account service is used to update manual and aggregated accounts.<br>The HTTP response code is 204 (Success without content).<br>Update manual account support is available for bank, card, investment, insurance, loan, otherAssets, otherLiabilities and realEstate containers only.<br><br><b>Note:</b><li> A real estate account update is only supported for SYSTEM and MANUAL valuation type.</li> <li> A real estate account can be linked to a loan account by passing accountId of a loan account in linkedAccountIds .</li> <li> Attribute <b>isEbillEnrolled</b> is deprecated as it is applicable for bill accounts only.</li>
         * @summary Update Account
         * @param {UpdateAccountRequest} body accountRequest
         * @param {number} accountId accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(body: UpdateAccountRequest, accountId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountsApiFetchParamCreator(configuration).updateAccount(body, accountId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * The add account service is used to add manual accounts.<br>The response of add account service includes the account name , account number and Yodlee generated account id.<br>All manual accounts added will be included as part of networth calculation by default.<br>Add manual account support is available for bank, card, investment, insurance and loan container only.<br><br><b>Note:</b><ul> <li>A real estate account addition is only supported for SYSTEM and MANUAL valuation type.</li></ul>
         * @summary Add Manual Account
         * @param {CreateAccountRequest} body accountParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createManualAccount(body: CreateAccountRequest, options?: any) {
            return AccountsApiFp(configuration).createManualAccount(body, options)(fetch, basePath);
        },
        /**
         * The delete account service allows an account to be deleted.<br>This service does not return a response. The HTTP response code is 204 (Success with no content).<br>
         * @summary Delete Account
         * @param {number} accountId accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(accountId: number, options?: any) {
            return AccountsApiFp(configuration).deleteAccount(accountId, options)(fetch, basePath);
        },
        /**
         * Use this service to validate the address before adding the real estate account.<br>If the address is valid, the service will return the complete address information.<br>The response will contain multiple addresses if the user-provided input matches with multiple entries in the vendor database.<br>In the case of multiple matches, the user can select the appropriate address from the list and then invoke the add account service with the complete address.<br><br><b>Note:</b> <ul><li>Yodlee recommends to use this service before adding the real estate account to avoid failures.</li></ul>
         * @summary Evaluate Address
         * @param {EvaluateAddressRequest} body addressParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateAddress(body: EvaluateAddressRequest, options?: any) {
            return AccountsApiFp(configuration).evaluateAddress(body, options)(fetch, basePath);
        },
        /**
         * The get account details service provides detailed information of an account.<br><br><b>Note:</b><li> fullAccountNumber is deprecated and is replaced with fullAccountNumberList in include parameter and response.</li>
         * @summary Get Account Details
         * @param {number} accountId accountId
         * @param {string} [include] profile, holder, fullAccountNumber, fullAccountNumberList, paymentProfile, autoRefresh&lt;br&gt;&lt;b&gt;Note:&lt;/b&gt;fullAccountNumber is deprecated and is replaced with fullAccountNumberList in include parameter and response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(accountId: number, include?: string, options?: any) {
            return AccountsApiFp(configuration).getAccount(accountId, include, options)(fetch, basePath);
        },
        /**
         * <i>This API implementation notes is intended for FastLink 4 users. For FastLink 3 users, additional integration notes related to this endpoint is available <a href=\"https://developer.envestnet.com/resources/yodlee/fastlink-3/docs/api-integrations\">here</a>.</i><br><br>The get accounts service provides information about accounts added by the user.<br>By default, this service returns information for active and to be closed accounts.<br>If requestId is provided, the accounts that are updated in the context of the requestId will be provided in the response.<br><br> This API returns all the accounts that were chosen by the user in both the verification selection screen and the aggregation selection screen. In FastLink 4, we have separate APIs to provide the data for verification product-related data (/verification/verifiedAccounts) and the GET accounts should be utilized with an additional query param (isSelectedForAggregation=true) to retrieve only the aggregation accounts.
         * @summary Get Accounts
         * @param {string} [accountId] Comma separated accountIds.
         * @param {string} [container] bank/creditCard/investment/insurance/loan/reward/realEstate/otherAssets/otherLiabilities
         * @param {string} [include] profile, paymentProfile, autoRefresh&lt;br&gt;&lt;b&gt;Note:&lt;/b&gt;&lt;br&gt;&lt;li&gt;fullAccountNumber is deprecated and is replaced with fullAccountNumberList in include parameter and response.&lt;/li&gt;&lt;br&gt;&lt;li&gt;profile is deprecated, and to retrieve the profile information, call the GET /verification/holderProfile API instead.&lt;/li&gt;
         * @param {string} [providerAccountId] Comma separated providerAccountIds.
         * @param {string} [requestId] The unique identifier that returns contextual data
         * @param {string} [status] ACTIVE,INACTIVE,TO_BE_CLOSED,CLOSED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAccounts(accountId?: string, container?: string, include?: string, providerAccountId?: string, requestId?: string, status?: string, options?: any) {
            return AccountsApiFp(configuration).getAllAccounts(accountId, container, include, providerAccountId, requestId, status, options)(fetch, basePath);
        },
        /**
         * The historical balances service is used to retrieve the historical balances for an account or a user.<br>Historical balances are daily (D), weekly (W), and monthly (M). <br>The interval input should be passed as D, W, and M to retrieve the desired historical balances. The default interval is daily (D). <br>When no account id is provided, historical balances of the accounts that are active, to be closed, and closed are provided in the response. <br>If the fromDate and toDate are not passed, the last 90 days of data will be provided. <br>The fromDate and toDate should be passed in the YYYY-MM-DD format. <br>The date field in the response denotes the date for which the balance is requested.<br>includeCF needs to be sent as true if the customer wants to return carried forward balances for a date when the data is not available. <br>asofDate field in the response denotes the date as of which the balance was updated for that account.<br>When there is no balance available for a requested date and if includeCF is sent as true, the previous date for which the balance is available is provided in the response. <br>When there is no previous balance available, no data will be sent. <br>By default, pagination is available for the historicalBalances entity in this API. The skip and top parameters are used for pagination. In the skip and top parameters, pass the number of records to be skipped and retrieved, respectively. The response header provides the links to retrieve the next and previous set of historical balances.<br> The API will only retrieve a maximum 500 records by default when values for skip and top parameters are not provided.
         * @summary Get Historical Balances
         * @param {string} [accountId] accountId
         * @param {string} [fromDate] from date for balance retrieval (YYYY-MM-DD)
         * @param {boolean} [includeCF] Consider carry forward logic for missing balances
         * @param {string} [interval] D-daily, W-weekly or M-monthly
         * @param {number} [skip] skip (Min 0)
         * @param {string} [toDate] toDate for balance retrieval (YYYY-MM-DD)
         * @param {number} [top] top (Max 500)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricalBalances(accountId?: string, fromDate?: string, includeCF?: boolean, interval?: string, skip?: number, toDate?: string, top?: number, options?: any) {
            return AccountsApiFp(configuration).getHistoricalBalances(accountId, fromDate, includeCF, interval, skip, toDate, top, options)(fetch, basePath);
        },
        /**
         * The latest balances service provides the latest account balance by initiating a new balance refresh request
         * @summary Get Latest Balances
         * @param {string} accountId Comma separated accountIds.
         * @param {string} providerAccountId providerAccountId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestBalances(accountId: string, providerAccountId: string, options?: any) {
            return AccountsApiFp(configuration).getLatestBalances(accountId, providerAccountId, options)(fetch, basePath);
        },
        /**
         * The update account service is used to update manual and aggregated accounts.<br>The HTTP response code is 204 (Success without content).<br>Update manual account support is available for bank, card, investment, insurance, loan, otherAssets, otherLiabilities and realEstate containers only.<br><br><b>Note:</b><li> A real estate account update is only supported for SYSTEM and MANUAL valuation type.</li> <li> A real estate account can be linked to a loan account by passing accountId of a loan account in linkedAccountIds .</li> <li> Attribute <b>isEbillEnrolled</b> is deprecated as it is applicable for bill accounts only.</li>
         * @summary Update Account
         * @param {UpdateAccountRequest} body accountRequest
         * @param {number} accountId accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(body: UpdateAccountRequest, accountId: number, options?: any) {
            return AccountsApiFp(configuration).updateAccount(body, accountId, options)(fetch, basePath);
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * The add account service is used to add manual accounts.<br>The response of add account service includes the account name , account number and Yodlee generated account id.<br>All manual accounts added will be included as part of networth calculation by default.<br>Add manual account support is available for bank, card, investment, insurance and loan container only.<br><br><b>Note:</b><ul> <li>A real estate account addition is only supported for SYSTEM and MANUAL valuation type.</li></ul>
     * @summary Add Manual Account
     * @param {CreateAccountRequest} body accountParam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public createManualAccount(body: CreateAccountRequest, options?: any) {
        return AccountsApiFp(this.configuration).createManualAccount(body, options)(this.fetch, this.basePath);
    }

    /**
     * The delete account service allows an account to be deleted.<br>This service does not return a response. The HTTP response code is 204 (Success with no content).<br>
     * @summary Delete Account
     * @param {number} accountId accountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public deleteAccount(accountId: number, options?: any) {
        return AccountsApiFp(this.configuration).deleteAccount(accountId, options)(this.fetch, this.basePath);
    }

    /**
     * Use this service to validate the address before adding the real estate account.<br>If the address is valid, the service will return the complete address information.<br>The response will contain multiple addresses if the user-provided input matches with multiple entries in the vendor database.<br>In the case of multiple matches, the user can select the appropriate address from the list and then invoke the add account service with the complete address.<br><br><b>Note:</b> <ul><li>Yodlee recommends to use this service before adding the real estate account to avoid failures.</li></ul>
     * @summary Evaluate Address
     * @param {EvaluateAddressRequest} body addressParam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public evaluateAddress(body: EvaluateAddressRequest, options?: any) {
        return AccountsApiFp(this.configuration).evaluateAddress(body, options)(this.fetch, this.basePath);
    }

    /**
     * The get account details service provides detailed information of an account.<br><br><b>Note:</b><li> fullAccountNumber is deprecated and is replaced with fullAccountNumberList in include parameter and response.</li>
     * @summary Get Account Details
     * @param {number} accountId accountId
     * @param {string} [include] profile, holder, fullAccountNumber, fullAccountNumberList, paymentProfile, autoRefresh&lt;br&gt;&lt;b&gt;Note:&lt;/b&gt;fullAccountNumber is deprecated and is replaced with fullAccountNumberList in include parameter and response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccount(accountId: number, include?: string, options?: any) {
        return AccountsApiFp(this.configuration).getAccount(accountId, include, options)(this.fetch, this.basePath);
    }

    /**
     * <i>This API implementation notes is intended for FastLink 4 users. For FastLink 3 users, additional integration notes related to this endpoint is available <a href=\"https://developer.envestnet.com/resources/yodlee/fastlink-3/docs/api-integrations\">here</a>.</i><br><br>The get accounts service provides information about accounts added by the user.<br>By default, this service returns information for active and to be closed accounts.<br>If requestId is provided, the accounts that are updated in the context of the requestId will be provided in the response.<br><br> This API returns all the accounts that were chosen by the user in both the verification selection screen and the aggregation selection screen. In FastLink 4, we have separate APIs to provide the data for verification product-related data (/verification/verifiedAccounts) and the GET accounts should be utilized with an additional query param (isSelectedForAggregation=true) to retrieve only the aggregation accounts.
     * @summary Get Accounts
     * @param {string} [accountId] Comma separated accountIds.
     * @param {string} [container] bank/creditCard/investment/insurance/loan/reward/realEstate/otherAssets/otherLiabilities
     * @param {string} [include] profile, paymentProfile, autoRefresh&lt;br&gt;&lt;b&gt;Note:&lt;/b&gt;&lt;br&gt;&lt;li&gt;fullAccountNumber is deprecated and is replaced with fullAccountNumberList in include parameter and response.&lt;/li&gt;&lt;br&gt;&lt;li&gt;profile is deprecated, and to retrieve the profile information, call the GET /verification/holderProfile API instead.&lt;/li&gt;
     * @param {string} [providerAccountId] Comma separated providerAccountIds.
     * @param {string} [requestId] The unique identifier that returns contextual data
     * @param {string} [status] ACTIVE,INACTIVE,TO_BE_CLOSED,CLOSED
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAllAccounts(accountId?: string, container?: string, include?: string, providerAccountId?: string, requestId?: string, status?: string, options?: any) {
        return AccountsApiFp(this.configuration).getAllAccounts(accountId, container, include, providerAccountId, requestId, status, options)(this.fetch, this.basePath);
    }

    /**
     * The historical balances service is used to retrieve the historical balances for an account or a user.<br>Historical balances are daily (D), weekly (W), and monthly (M). <br>The interval input should be passed as D, W, and M to retrieve the desired historical balances. The default interval is daily (D). <br>When no account id is provided, historical balances of the accounts that are active, to be closed, and closed are provided in the response. <br>If the fromDate and toDate are not passed, the last 90 days of data will be provided. <br>The fromDate and toDate should be passed in the YYYY-MM-DD format. <br>The date field in the response denotes the date for which the balance is requested.<br>includeCF needs to be sent as true if the customer wants to return carried forward balances for a date when the data is not available. <br>asofDate field in the response denotes the date as of which the balance was updated for that account.<br>When there is no balance available for a requested date and if includeCF is sent as true, the previous date for which the balance is available is provided in the response. <br>When there is no previous balance available, no data will be sent. <br>By default, pagination is available for the historicalBalances entity in this API. The skip and top parameters are used for pagination. In the skip and top parameters, pass the number of records to be skipped and retrieved, respectively. The response header provides the links to retrieve the next and previous set of historical balances.<br> The API will only retrieve a maximum 500 records by default when values for skip and top parameters are not provided.
     * @summary Get Historical Balances
     * @param {string} [accountId] accountId
     * @param {string} [fromDate] from date for balance retrieval (YYYY-MM-DD)
     * @param {boolean} [includeCF] Consider carry forward logic for missing balances
     * @param {string} [interval] D-daily, W-weekly or M-monthly
     * @param {number} [skip] skip (Min 0)
     * @param {string} [toDate] toDate for balance retrieval (YYYY-MM-DD)
     * @param {number} [top] top (Max 500)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getHistoricalBalances(accountId?: string, fromDate?: string, includeCF?: boolean, interval?: string, skip?: number, toDate?: string, top?: number, options?: any) {
        return AccountsApiFp(this.configuration).getHistoricalBalances(accountId, fromDate, includeCF, interval, skip, toDate, top, options)(this.fetch, this.basePath);
    }

    /**
     * The latest balances service provides the latest account balance by initiating a new balance refresh request
     * @summary Get Latest Balances
     * @param {string} accountId Comma separated accountIds.
     * @param {string} providerAccountId providerAccountId.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getLatestBalances(accountId: string, providerAccountId: string, options?: any) {
        return AccountsApiFp(this.configuration).getLatestBalances(accountId, providerAccountId, options)(this.fetch, this.basePath);
    }

    /**
     * The update account service is used to update manual and aggregated accounts.<br>The HTTP response code is 204 (Success without content).<br>Update manual account support is available for bank, card, investment, insurance, loan, otherAssets, otherLiabilities and realEstate containers only.<br><br><b>Note:</b><li> A real estate account update is only supported for SYSTEM and MANUAL valuation type.</li> <li> A real estate account can be linked to a loan account by passing accountId of a loan account in linkedAccountIds .</li> <li> Attribute <b>isEbillEnrolled</b> is deprecated as it is applicable for bill accounts only.</li>
     * @summary Update Account
     * @param {UpdateAccountRequest} body accountRequest
     * @param {number} accountId accountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public updateAccount(body: UpdateAccountRequest, accountId: number, options?: any) {
        return AccountsApiFp(this.configuration).updateAccount(body, accountId, options)(this.fetch, this.basePath);
    }

}
/**
 * AuthApi - fetch parameter creator
 * @export
 */
export const AuthApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint allows an existing API key to be deleted.<br>You can use one of the following authorization methods to access this API:<br><ol><li>cobsession</li><li>JWT token</li></ol> <b>Notes:</b> <li>This service is not available in developer sandbox environment and will be made availablefor testing in your dedicated environment. 
         * @summary Delete API Key
         * @param {string} key key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKey(key: string, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling deleteApiKey.');
            }
            const localVarPath = `/auth/apiKey/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint revokes the token passed in the Authorization header. This service is applicable for JWT-based (and all API key-based) authentication and also client credential (clientId and secret) based authentication. This service does not return a response body. The HTTP response code is 204 (success with no content). <br>Tokens generally have limited lifetime of up to 30 minutes. You will call this service when you finish working with one user, and you want to delete the valid token rather than simply letting it expire.<br><br><b>Note:</b> <li>Revoking an access token (either type, admin or a user token) can take up to 2 minutes, as the tokens are stored on a distributed system.<br/>
         * @summary Delete Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken(options: any = {}): FetchArgs {
            const localVarPath = `/auth/token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Generate Access Token using client credential authentication.</b><br>This service returns access tokens required to access Yodlee 1.1 APIs. These tokens are the simplest and easiest of several alternatives for authenticating with Yodlee servers.<br>The most commonly used services obtain data specific to an end user (your customer). For these services, you need a <b>user access token</b>. These are simply tokens created with the user name parameter (<b>loginName</b>) set to the id of your end user.  <i><br><br><b>Note:</b> You determine this id and you must ensure it's unique among all your customers.</i> <br><br>Each token issued has an associated user. The token passed in the http headers explicitly names the user referenced in that API call.<br><br>Some of the APIs do administrative work, and don't reference an end user. <br/>One example of administrative work is key management. Another example is registering a new user explicitly, with <b>POST /user/register</b> call or subscribe to webhook, with <b>POST /config/notifications/events/{eventName}</b>. <br/>To invoke these, you need an <b>admin access token</b>. Create this by passing in your admin user login name in place of a regular user name.<br><br>This service also allows for simplified registration of new users. Any time you pass in a user name not already in use, the system will automatically implicitly create a new user for you. <br>This user will naturally have very few associated details. You can later provide additional user information by calling the <b>PUT user/register service</b>.<br><br><b>Notes:</b><ul><li>The header <code>Authorization</code> does not apply to this service.</li><li>The content type has to be passed as application/x-www-form-urlencoded.<li>Upgrading to client credential authentication requires infrastructure reconfiguration. <li>Customers wishing to switch from another authentication scheme to client credential authentication, please contact Yodlee Client Services.</li><li>Default expiry time of user access token and admin access token is 30 minutes.</li></ul>
         * @summary Generate Access Token
         * @param {string} [clientId] 
         * @param {string} [secret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateAccessToken(clientId?: string, secret?: string, options: any = {}): FetchArgs {
            const localVarPath = `/auth/token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (clientId !== undefined) {
                localVarFormParams.set('clientId', clientId as any);
            }

            if (secret !== undefined) {
                localVarFormParams.set('secret', secret as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to generate an API key. The RSA public key you provide should be in 2048 bit PKCS#8 encoded format. <br>A public key is a mandatory input for generating the API key.<br/>The public key should be a unique key. The apiKeyId you get in the response is what you should use to generate the JWT token.<br> You can use one of the following authorization methods to access<br/>this API:<br><ol><li>cobsession</li><li>JWT token</li></ol> Alternatively, you can use base 64 encoded cobrandLogin and cobrandPassword in the Authorization header (Format: Authorization: Basic <encoded value of cobrandLogin: cobrandPassword>)<br><br><b>Note:</b><br><li>This service is not available in developer sandbox environment and will be made available for testing in your dedicated environment. The content type has to be passed as application/json for the body parameter.</li>
         * @summary Generate API Key
         * @param {ApiKeyRequest} body apiKeyRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateApiKey(body: ApiKeyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling generateApiKey.');
            }
            const localVarPath = `/auth/apiKey`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ApiKeyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint provides the list of API keys that exist for a customer.<br>You can use one of the following authorization methods to access this API:<br><ol><li>cobsession</li><li>JWT token</li></ol><b>Notes:</b><li>This service is not available in developer sandbox environment and will be made available for testing in your dedicated environment. 
         * @summary Get API Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKeys(options: any = {}): FetchArgs {
            const localVarPath = `/auth/apiKey`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint allows an existing API key to be deleted.<br>You can use one of the following authorization methods to access this API:<br><ol><li>cobsession</li><li>JWT token</li></ol> <b>Notes:</b> <li>This service is not available in developer sandbox environment and will be made availablefor testing in your dedicated environment. 
         * @summary Delete API Key
         * @param {string} key key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKey(key: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).deleteApiKey(key, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint revokes the token passed in the Authorization header. This service is applicable for JWT-based (and all API key-based) authentication and also client credential (clientId and secret) based authentication. This service does not return a response body. The HTTP response code is 204 (success with no content). <br>Tokens generally have limited lifetime of up to 30 minutes. You will call this service when you finish working with one user, and you want to delete the valid token rather than simply letting it expire.<br><br><b>Note:</b> <li>Revoking an access token (either type, admin or a user token) can take up to 2 minutes, as the tokens are stored on a distributed system.<br/>
         * @summary Delete Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).deleteToken(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * <b>Generate Access Token using client credential authentication.</b><br>This service returns access tokens required to access Yodlee 1.1 APIs. These tokens are the simplest and easiest of several alternatives for authenticating with Yodlee servers.<br>The most commonly used services obtain data specific to an end user (your customer). For these services, you need a <b>user access token</b>. These are simply tokens created with the user name parameter (<b>loginName</b>) set to the id of your end user.  <i><br><br><b>Note:</b> You determine this id and you must ensure it's unique among all your customers.</i> <br><br>Each token issued has an associated user. The token passed in the http headers explicitly names the user referenced in that API call.<br><br>Some of the APIs do administrative work, and don't reference an end user. <br/>One example of administrative work is key management. Another example is registering a new user explicitly, with <b>POST /user/register</b> call or subscribe to webhook, with <b>POST /config/notifications/events/{eventName}</b>. <br/>To invoke these, you need an <b>admin access token</b>. Create this by passing in your admin user login name in place of a regular user name.<br><br>This service also allows for simplified registration of new users. Any time you pass in a user name not already in use, the system will automatically implicitly create a new user for you. <br>This user will naturally have very few associated details. You can later provide additional user information by calling the <b>PUT user/register service</b>.<br><br><b>Notes:</b><ul><li>The header <code>Authorization</code> does not apply to this service.</li><li>The content type has to be passed as application/x-www-form-urlencoded.<li>Upgrading to client credential authentication requires infrastructure reconfiguration. <li>Customers wishing to switch from another authentication scheme to client credential authentication, please contact Yodlee Client Services.</li><li>Default expiry time of user access token and admin access token is 30 minutes.</li></ul>
         * @summary Generate Access Token
         * @param {string} [clientId] 
         * @param {string} [secret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateAccessToken(clientId?: string, secret?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ClientCredentialTokenResponse> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).generateAccessToken(clientId, secret, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint is used to generate an API key. The RSA public key you provide should be in 2048 bit PKCS#8 encoded format. <br>A public key is a mandatory input for generating the API key.<br/>The public key should be a unique key. The apiKeyId you get in the response is what you should use to generate the JWT token.<br> You can use one of the following authorization methods to access<br/>this API:<br><ol><li>cobsession</li><li>JWT token</li></ol> Alternatively, you can use base 64 encoded cobrandLogin and cobrandPassword in the Authorization header (Format: Authorization: Basic <encoded value of cobrandLogin: cobrandPassword>)<br><br><b>Note:</b><br><li>This service is not available in developer sandbox environment and will be made available for testing in your dedicated environment. The content type has to be passed as application/json for the body parameter.</li>
         * @summary Generate API Key
         * @param {ApiKeyRequest} body apiKeyRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateApiKey(body: ApiKeyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiKeyResponse> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).generateApiKey(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint provides the list of API keys that exist for a customer.<br>You can use one of the following authorization methods to access this API:<br><ol><li>cobsession</li><li>JWT token</li></ol><b>Notes:</b><li>This service is not available in developer sandbox environment and will be made available for testing in your dedicated environment. 
         * @summary Get API Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKeys(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiKeyResponse> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).getApiKeys(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This endpoint allows an existing API key to be deleted.<br>You can use one of the following authorization methods to access this API:<br><ol><li>cobsession</li><li>JWT token</li></ol> <b>Notes:</b> <li>This service is not available in developer sandbox environment and will be made availablefor testing in your dedicated environment. 
         * @summary Delete API Key
         * @param {string} key key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKey(key: string, options?: any) {
            return AuthApiFp(configuration).deleteApiKey(key, options)(fetch, basePath);
        },
        /**
         * This endpoint revokes the token passed in the Authorization header. This service is applicable for JWT-based (and all API key-based) authentication and also client credential (clientId and secret) based authentication. This service does not return a response body. The HTTP response code is 204 (success with no content). <br>Tokens generally have limited lifetime of up to 30 minutes. You will call this service when you finish working with one user, and you want to delete the valid token rather than simply letting it expire.<br><br><b>Note:</b> <li>Revoking an access token (either type, admin or a user token) can take up to 2 minutes, as the tokens are stored on a distributed system.<br/>
         * @summary Delete Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken(options?: any) {
            return AuthApiFp(configuration).deleteToken(options)(fetch, basePath);
        },
        /**
         * <b>Generate Access Token using client credential authentication.</b><br>This service returns access tokens required to access Yodlee 1.1 APIs. These tokens are the simplest and easiest of several alternatives for authenticating with Yodlee servers.<br>The most commonly used services obtain data specific to an end user (your customer). For these services, you need a <b>user access token</b>. These are simply tokens created with the user name parameter (<b>loginName</b>) set to the id of your end user.  <i><br><br><b>Note:</b> You determine this id and you must ensure it's unique among all your customers.</i> <br><br>Each token issued has an associated user. The token passed in the http headers explicitly names the user referenced in that API call.<br><br>Some of the APIs do administrative work, and don't reference an end user. <br/>One example of administrative work is key management. Another example is registering a new user explicitly, with <b>POST /user/register</b> call or subscribe to webhook, with <b>POST /config/notifications/events/{eventName}</b>. <br/>To invoke these, you need an <b>admin access token</b>. Create this by passing in your admin user login name in place of a regular user name.<br><br>This service also allows for simplified registration of new users. Any time you pass in a user name not already in use, the system will automatically implicitly create a new user for you. <br>This user will naturally have very few associated details. You can later provide additional user information by calling the <b>PUT user/register service</b>.<br><br><b>Notes:</b><ul><li>The header <code>Authorization</code> does not apply to this service.</li><li>The content type has to be passed as application/x-www-form-urlencoded.<li>Upgrading to client credential authentication requires infrastructure reconfiguration. <li>Customers wishing to switch from another authentication scheme to client credential authentication, please contact Yodlee Client Services.</li><li>Default expiry time of user access token and admin access token is 30 minutes.</li></ul>
         * @summary Generate Access Token
         * @param {string} [clientId] 
         * @param {string} [secret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateAccessToken(clientId?: string, secret?: string, options?: any) {
            return AuthApiFp(configuration).generateAccessToken(clientId, secret, options)(fetch, basePath);
        },
        /**
         * This endpoint is used to generate an API key. The RSA public key you provide should be in 2048 bit PKCS#8 encoded format. <br>A public key is a mandatory input for generating the API key.<br/>The public key should be a unique key. The apiKeyId you get in the response is what you should use to generate the JWT token.<br> You can use one of the following authorization methods to access<br/>this API:<br><ol><li>cobsession</li><li>JWT token</li></ol> Alternatively, you can use base 64 encoded cobrandLogin and cobrandPassword in the Authorization header (Format: Authorization: Basic <encoded value of cobrandLogin: cobrandPassword>)<br><br><b>Note:</b><br><li>This service is not available in developer sandbox environment and will be made available for testing in your dedicated environment. The content type has to be passed as application/json for the body parameter.</li>
         * @summary Generate API Key
         * @param {ApiKeyRequest} body apiKeyRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateApiKey(body: ApiKeyRequest, options?: any) {
            return AuthApiFp(configuration).generateApiKey(body, options)(fetch, basePath);
        },
        /**
         * This endpoint provides the list of API keys that exist for a customer.<br>You can use one of the following authorization methods to access this API:<br><ol><li>cobsession</li><li>JWT token</li></ol><b>Notes:</b><li>This service is not available in developer sandbox environment and will be made available for testing in your dedicated environment. 
         * @summary Get API Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKeys(options?: any) {
            return AuthApiFp(configuration).getApiKeys(options)(fetch, basePath);
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * This endpoint allows an existing API key to be deleted.<br>You can use one of the following authorization methods to access this API:<br><ol><li>cobsession</li><li>JWT token</li></ol> <b>Notes:</b> <li>This service is not available in developer sandbox environment and will be made availablefor testing in your dedicated environment. 
     * @summary Delete API Key
     * @param {string} key key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public deleteApiKey(key: string, options?: any) {
        return AuthApiFp(this.configuration).deleteApiKey(key, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint revokes the token passed in the Authorization header. This service is applicable for JWT-based (and all API key-based) authentication and also client credential (clientId and secret) based authentication. This service does not return a response body. The HTTP response code is 204 (success with no content). <br>Tokens generally have limited lifetime of up to 30 minutes. You will call this service when you finish working with one user, and you want to delete the valid token rather than simply letting it expire.<br><br><b>Note:</b> <li>Revoking an access token (either type, admin or a user token) can take up to 2 minutes, as the tokens are stored on a distributed system.<br/>
     * @summary Delete Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public deleteToken(options?: any) {
        return AuthApiFp(this.configuration).deleteToken(options)(this.fetch, this.basePath);
    }

    /**
     * <b>Generate Access Token using client credential authentication.</b><br>This service returns access tokens required to access Yodlee 1.1 APIs. These tokens are the simplest and easiest of several alternatives for authenticating with Yodlee servers.<br>The most commonly used services obtain data specific to an end user (your customer). For these services, you need a <b>user access token</b>. These are simply tokens created with the user name parameter (<b>loginName</b>) set to the id of your end user.  <i><br><br><b>Note:</b> You determine this id and you must ensure it's unique among all your customers.</i> <br><br>Each token issued has an associated user. The token passed in the http headers explicitly names the user referenced in that API call.<br><br>Some of the APIs do administrative work, and don't reference an end user. <br/>One example of administrative work is key management. Another example is registering a new user explicitly, with <b>POST /user/register</b> call or subscribe to webhook, with <b>POST /config/notifications/events/{eventName}</b>. <br/>To invoke these, you need an <b>admin access token</b>. Create this by passing in your admin user login name in place of a regular user name.<br><br>This service also allows for simplified registration of new users. Any time you pass in a user name not already in use, the system will automatically implicitly create a new user for you. <br>This user will naturally have very few associated details. You can later provide additional user information by calling the <b>PUT user/register service</b>.<br><br><b>Notes:</b><ul><li>The header <code>Authorization</code> does not apply to this service.</li><li>The content type has to be passed as application/x-www-form-urlencoded.<li>Upgrading to client credential authentication requires infrastructure reconfiguration. <li>Customers wishing to switch from another authentication scheme to client credential authentication, please contact Yodlee Client Services.</li><li>Default expiry time of user access token and admin access token is 30 minutes.</li></ul>
     * @summary Generate Access Token
     * @param {string} [clientId] 
     * @param {string} [secret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public generateAccessToken(clientId?: string, secret?: string, options?: any) {
        return AuthApiFp(this.configuration).generateAccessToken(clientId, secret, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint is used to generate an API key. The RSA public key you provide should be in 2048 bit PKCS#8 encoded format. <br>A public key is a mandatory input for generating the API key.<br/>The public key should be a unique key. The apiKeyId you get in the response is what you should use to generate the JWT token.<br> You can use one of the following authorization methods to access<br/>this API:<br><ol><li>cobsession</li><li>JWT token</li></ol> Alternatively, you can use base 64 encoded cobrandLogin and cobrandPassword in the Authorization header (Format: Authorization: Basic <encoded value of cobrandLogin: cobrandPassword>)<br><br><b>Note:</b><br><li>This service is not available in developer sandbox environment and will be made available for testing in your dedicated environment. The content type has to be passed as application/json for the body parameter.</li>
     * @summary Generate API Key
     * @param {ApiKeyRequest} body apiKeyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public generateApiKey(body: ApiKeyRequest, options?: any) {
        return AuthApiFp(this.configuration).generateApiKey(body, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint provides the list of API keys that exist for a customer.<br>You can use one of the following authorization methods to access this API:<br><ol><li>cobsession</li><li>JWT token</li></ol><b>Notes:</b><li>This service is not available in developer sandbox environment and will be made available for testing in your dedicated environment. 
     * @summary Get API Keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getApiKeys(options?: any) {
        return AuthApiFp(this.configuration).getApiKeys(options)(this.fetch, this.basePath);
    }

}
/**
 * CobrandApi - fetch parameter creator
 * @export
 */
export const CobrandApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The cobrand login service authenticates a cobrand.<br>Cobrand session in the response includes the cobrand session token (cobSession) <br>which is used in subsequent API calls like registering or signing in the user. <br>The idle timeout for a cobrand session is 2 hours and the absolute timeout is 24 hours. This service can be <br>invoked to create a new cobrand session token. <br><b>Note:</b> This endpoint is deprecated for customers using the API Key-based authentication and is applicable only to customers who use the SAML-based authentication.<br>The content type has to be passed as application/json for the body parameter. <br>
         * @summary Cobrand Login
         * @param {CobrandLoginRequest} body cobrandLoginRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cobrandLogin(body: CobrandLoginRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling cobrandLogin.');
            }
            const localVarPath = `/cobrand/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CobrandLoginRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The cobrand logout service is used to log out the cobrand.<br>This service does not return a response. The HTTP response code is 204 (Success with no content).<br><b>Note:</b> This endpoint is deprecated for customers using the API Key-based authentication and is applicable only to customers who use the SAML-based authentication.<br>
         * @summary Cobrand Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cobrandLogout(options: any = {}): FetchArgs {
            const localVarPath = `/cobrand/logout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Refer POST /configs/notifications/events/{eventName}.</b><br>The subscribe events service is used to subscribe to an event for receiving notifications.<br>The callback URL, where the notification will be posted should be provided to this service.<br>If the callback URL is invalid or inaccessible, the subscription will be unsuccessful, and an error will be thrown.<br>Customers can subscribe to REFRESH,DATA_UPDATES and AUTO_REFRESH_UPDATES event.<br><br><b>Notes</b>:<br>This service is not available in developer sandbox/test environment and will be made available for testing in your dedicated environment, once the contract is signed.<br>The content type has to be passed as application/json for the body parameter.<br>
         * @summary Subscribe Event
         * @param {CreateCobrandNotificationEventRequest} body eventRequest
         * @param {string} eventName eventName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionEvent(body: CreateCobrandNotificationEventRequest, eventName: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createSubscriptionEvent.');
            }
            // verify required parameter 'eventName' is not null or undefined
            if (eventName === null || eventName === undefined) {
                throw new RequiredError('eventName','Required parameter eventName was null or undefined when calling createSubscriptionEvent.');
            }
            const localVarPath = `/cobrand/config/notifications/events/{eventName}`
                .replace(`{${"eventName"}}`, encodeURIComponent(String(eventName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateCobrandNotificationEventRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Refer DELETE /configs/notifications/events/{eventName}.</b><br>The delete events service is used to unsubscribe from an events service.<br>
         * @summary Delete Subscription
         * @param {string} eventName eventName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscribedEvent(eventName: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventName' is not null or undefined
            if (eventName === null || eventName === undefined) {
                throw new RequiredError('eventName','Required parameter eventName was null or undefined when calling deleteSubscribedEvent.');
            }
            const localVarPath = `/cobrand/config/notifications/events/{eventName}`
                .replace(`{${"eventName"}}`, encodeURIComponent(String(eventName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Refer GET /configs/publicKey.</b><br>The get public key service provides the customer the public key that should be used to encrypt the user credentials before sending it to Yodlee.<br>This endpoint is useful only for PKI enabled.<br>
         * @summary Get Public Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKey(options: any = {}): FetchArgs {
            const localVarPath = `/cobrand/publicKey`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Refer GET /configs/notifications/events.</b><br>The get events service provides the list of events for which consumers subscribed <br>to receive notifications. <br>
         * @summary Get Subscribed Events
         * @param {string} [eventName] eventName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribedEvents(eventName?: string, options: any = {}): FetchArgs {
            const localVarPath = `/cobrand/config/notifications/events`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (eventName !== undefined) {
                localVarQueryParameter['eventName'] = eventName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Refer PUT /configs/notifications/events/{eventName}.</b><br>The update events service is used to update the callback URL.<br>If the callback URL is invalid or inaccessible, the subscription will be unsuccessful, and an error will be thrown.<br><b>Note:</b> The content type has to be passed as application/json for the body parameter. <br>
         * @summary Update Subscription
         * @param {UpdateCobrandNotificationEventRequest} body eventRequest
         * @param {string} eventName eventName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscribedEvent(body: UpdateCobrandNotificationEventRequest, eventName: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateSubscribedEvent.');
            }
            // verify required parameter 'eventName' is not null or undefined
            if (eventName === null || eventName === undefined) {
                throw new RequiredError('eventName','Required parameter eventName was null or undefined when calling updateSubscribedEvent.');
            }
            const localVarPath = `/cobrand/config/notifications/events/{eventName}`
                .replace(`{${"eventName"}}`, encodeURIComponent(String(eventName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateCobrandNotificationEventRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CobrandApi - functional programming interface
 * @export
 */
export const CobrandApiFp = function(configuration?: Configuration) {
    return {
        /**
         * The cobrand login service authenticates a cobrand.<br>Cobrand session in the response includes the cobrand session token (cobSession) <br>which is used in subsequent API calls like registering or signing in the user. <br>The idle timeout for a cobrand session is 2 hours and the absolute timeout is 24 hours. This service can be <br>invoked to create a new cobrand session token. <br><b>Note:</b> This endpoint is deprecated for customers using the API Key-based authentication and is applicable only to customers who use the SAML-based authentication.<br>The content type has to be passed as application/json for the body parameter. <br>
         * @summary Cobrand Login
         * @param {CobrandLoginRequest} body cobrandLoginRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cobrandLogin(body: CobrandLoginRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CobrandLoginResponse> {
            const localVarFetchArgs = CobrandApiFetchParamCreator(configuration).cobrandLogin(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The cobrand logout service is used to log out the cobrand.<br>This service does not return a response. The HTTP response code is 204 (Success with no content).<br><b>Note:</b> This endpoint is deprecated for customers using the API Key-based authentication and is applicable only to customers who use the SAML-based authentication.<br>
         * @summary Cobrand Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cobrandLogout(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CobrandApiFetchParamCreator(configuration).cobrandLogout(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * <b>Refer POST /configs/notifications/events/{eventName}.</b><br>The subscribe events service is used to subscribe to an event for receiving notifications.<br>The callback URL, where the notification will be posted should be provided to this service.<br>If the callback URL is invalid or inaccessible, the subscription will be unsuccessful, and an error will be thrown.<br>Customers can subscribe to REFRESH,DATA_UPDATES and AUTO_REFRESH_UPDATES event.<br><br><b>Notes</b>:<br>This service is not available in developer sandbox/test environment and will be made available for testing in your dedicated environment, once the contract is signed.<br>The content type has to be passed as application/json for the body parameter.<br>
         * @summary Subscribe Event
         * @param {CreateCobrandNotificationEventRequest} body eventRequest
         * @param {string} eventName eventName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionEvent(body: CreateCobrandNotificationEventRequest, eventName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CobrandApiFetchParamCreator(configuration).createSubscriptionEvent(body, eventName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * <b>Refer DELETE /configs/notifications/events/{eventName}.</b><br>The delete events service is used to unsubscribe from an events service.<br>
         * @summary Delete Subscription
         * @param {string} eventName eventName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscribedEvent(eventName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CobrandApiFetchParamCreator(configuration).deleteSubscribedEvent(eventName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * <b>Refer GET /configs/publicKey.</b><br>The get public key service provides the customer the public key that should be used to encrypt the user credentials before sending it to Yodlee.<br>This endpoint is useful only for PKI enabled.<br>
         * @summary Get Public Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKey(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CobrandPublicKeyResponse> {
            const localVarFetchArgs = CobrandApiFetchParamCreator(configuration).getPublicKey(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * <b>Refer GET /configs/notifications/events.</b><br>The get events service provides the list of events for which consumers subscribed <br>to receive notifications. <br>
         * @summary Get Subscribed Events
         * @param {string} [eventName] eventName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribedEvents(eventName?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CobrandNotificationResponse> {
            const localVarFetchArgs = CobrandApiFetchParamCreator(configuration).getSubscribedEvents(eventName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * <b>Refer PUT /configs/notifications/events/{eventName}.</b><br>The update events service is used to update the callback URL.<br>If the callback URL is invalid or inaccessible, the subscription will be unsuccessful, and an error will be thrown.<br><b>Note:</b> The content type has to be passed as application/json for the body parameter. <br>
         * @summary Update Subscription
         * @param {UpdateCobrandNotificationEventRequest} body eventRequest
         * @param {string} eventName eventName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscribedEvent(body: UpdateCobrandNotificationEventRequest, eventName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CobrandApiFetchParamCreator(configuration).updateSubscribedEvent(body, eventName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CobrandApi - factory interface
 * @export
 */
export const CobrandApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * The cobrand login service authenticates a cobrand.<br>Cobrand session in the response includes the cobrand session token (cobSession) <br>which is used in subsequent API calls like registering or signing in the user. <br>The idle timeout for a cobrand session is 2 hours and the absolute timeout is 24 hours. This service can be <br>invoked to create a new cobrand session token. <br><b>Note:</b> This endpoint is deprecated for customers using the API Key-based authentication and is applicable only to customers who use the SAML-based authentication.<br>The content type has to be passed as application/json for the body parameter. <br>
         * @summary Cobrand Login
         * @param {CobrandLoginRequest} body cobrandLoginRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cobrandLogin(body: CobrandLoginRequest, options?: any) {
            return CobrandApiFp(configuration).cobrandLogin(body, options)(fetch, basePath);
        },
        /**
         * The cobrand logout service is used to log out the cobrand.<br>This service does not return a response. The HTTP response code is 204 (Success with no content).<br><b>Note:</b> This endpoint is deprecated for customers using the API Key-based authentication and is applicable only to customers who use the SAML-based authentication.<br>
         * @summary Cobrand Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cobrandLogout(options?: any) {
            return CobrandApiFp(configuration).cobrandLogout(options)(fetch, basePath);
        },
        /**
         * <b>Refer POST /configs/notifications/events/{eventName}.</b><br>The subscribe events service is used to subscribe to an event for receiving notifications.<br>The callback URL, where the notification will be posted should be provided to this service.<br>If the callback URL is invalid or inaccessible, the subscription will be unsuccessful, and an error will be thrown.<br>Customers can subscribe to REFRESH,DATA_UPDATES and AUTO_REFRESH_UPDATES event.<br><br><b>Notes</b>:<br>This service is not available in developer sandbox/test environment and will be made available for testing in your dedicated environment, once the contract is signed.<br>The content type has to be passed as application/json for the body parameter.<br>
         * @summary Subscribe Event
         * @param {CreateCobrandNotificationEventRequest} body eventRequest
         * @param {string} eventName eventName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionEvent(body: CreateCobrandNotificationEventRequest, eventName: string, options?: any) {
            return CobrandApiFp(configuration).createSubscriptionEvent(body, eventName, options)(fetch, basePath);
        },
        /**
         * <b>Refer DELETE /configs/notifications/events/{eventName}.</b><br>The delete events service is used to unsubscribe from an events service.<br>
         * @summary Delete Subscription
         * @param {string} eventName eventName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscribedEvent(eventName: string, options?: any) {
            return CobrandApiFp(configuration).deleteSubscribedEvent(eventName, options)(fetch, basePath);
        },
        /**
         * <b>Refer GET /configs/publicKey.</b><br>The get public key service provides the customer the public key that should be used to encrypt the user credentials before sending it to Yodlee.<br>This endpoint is useful only for PKI enabled.<br>
         * @summary Get Public Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKey(options?: any) {
            return CobrandApiFp(configuration).getPublicKey(options)(fetch, basePath);
        },
        /**
         * <b>Refer GET /configs/notifications/events.</b><br>The get events service provides the list of events for which consumers subscribed <br>to receive notifications. <br>
         * @summary Get Subscribed Events
         * @param {string} [eventName] eventName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribedEvents(eventName?: string, options?: any) {
            return CobrandApiFp(configuration).getSubscribedEvents(eventName, options)(fetch, basePath);
        },
        /**
         * <b>Refer PUT /configs/notifications/events/{eventName}.</b><br>The update events service is used to update the callback URL.<br>If the callback URL is invalid or inaccessible, the subscription will be unsuccessful, and an error will be thrown.<br><b>Note:</b> The content type has to be passed as application/json for the body parameter. <br>
         * @summary Update Subscription
         * @param {UpdateCobrandNotificationEventRequest} body eventRequest
         * @param {string} eventName eventName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscribedEvent(body: UpdateCobrandNotificationEventRequest, eventName: string, options?: any) {
            return CobrandApiFp(configuration).updateSubscribedEvent(body, eventName, options)(fetch, basePath);
        },
    };
};

/**
 * CobrandApi - object-oriented interface
 * @export
 * @class CobrandApi
 * @extends {BaseAPI}
 */
export class CobrandApi extends BaseAPI {
    /**
     * The cobrand login service authenticates a cobrand.<br>Cobrand session in the response includes the cobrand session token (cobSession) <br>which is used in subsequent API calls like registering or signing in the user. <br>The idle timeout for a cobrand session is 2 hours and the absolute timeout is 24 hours. This service can be <br>invoked to create a new cobrand session token. <br><b>Note:</b> This endpoint is deprecated for customers using the API Key-based authentication and is applicable only to customers who use the SAML-based authentication.<br>The content type has to be passed as application/json for the body parameter. <br>
     * @summary Cobrand Login
     * @param {CobrandLoginRequest} body cobrandLoginRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CobrandApi
     */
    public cobrandLogin(body: CobrandLoginRequest, options?: any) {
        return CobrandApiFp(this.configuration).cobrandLogin(body, options)(this.fetch, this.basePath);
    }

    /**
     * The cobrand logout service is used to log out the cobrand.<br>This service does not return a response. The HTTP response code is 204 (Success with no content).<br><b>Note:</b> This endpoint is deprecated for customers using the API Key-based authentication and is applicable only to customers who use the SAML-based authentication.<br>
     * @summary Cobrand Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CobrandApi
     */
    public cobrandLogout(options?: any) {
        return CobrandApiFp(this.configuration).cobrandLogout(options)(this.fetch, this.basePath);
    }

    /**
     * <b>Refer POST /configs/notifications/events/{eventName}.</b><br>The subscribe events service is used to subscribe to an event for receiving notifications.<br>The callback URL, where the notification will be posted should be provided to this service.<br>If the callback URL is invalid or inaccessible, the subscription will be unsuccessful, and an error will be thrown.<br>Customers can subscribe to REFRESH,DATA_UPDATES and AUTO_REFRESH_UPDATES event.<br><br><b>Notes</b>:<br>This service is not available in developer sandbox/test environment and will be made available for testing in your dedicated environment, once the contract is signed.<br>The content type has to be passed as application/json for the body parameter.<br>
     * @summary Subscribe Event
     * @param {CreateCobrandNotificationEventRequest} body eventRequest
     * @param {string} eventName eventName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CobrandApi
     */
    public createSubscriptionEvent(body: CreateCobrandNotificationEventRequest, eventName: string, options?: any) {
        return CobrandApiFp(this.configuration).createSubscriptionEvent(body, eventName, options)(this.fetch, this.basePath);
    }

    /**
     * <b>Refer DELETE /configs/notifications/events/{eventName}.</b><br>The delete events service is used to unsubscribe from an events service.<br>
     * @summary Delete Subscription
     * @param {string} eventName eventName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CobrandApi
     */
    public deleteSubscribedEvent(eventName: string, options?: any) {
        return CobrandApiFp(this.configuration).deleteSubscribedEvent(eventName, options)(this.fetch, this.basePath);
    }

    /**
     * <b>Refer GET /configs/publicKey.</b><br>The get public key service provides the customer the public key that should be used to encrypt the user credentials before sending it to Yodlee.<br>This endpoint is useful only for PKI enabled.<br>
     * @summary Get Public Key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CobrandApi
     */
    public getPublicKey(options?: any) {
        return CobrandApiFp(this.configuration).getPublicKey(options)(this.fetch, this.basePath);
    }

    /**
     * <b>Refer GET /configs/notifications/events.</b><br>The get events service provides the list of events for which consumers subscribed <br>to receive notifications. <br>
     * @summary Get Subscribed Events
     * @param {string} [eventName] eventName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CobrandApi
     */
    public getSubscribedEvents(eventName?: string, options?: any) {
        return CobrandApiFp(this.configuration).getSubscribedEvents(eventName, options)(this.fetch, this.basePath);
    }

    /**
     * <b>Refer PUT /configs/notifications/events/{eventName}.</b><br>The update events service is used to update the callback URL.<br>If the callback URL is invalid or inaccessible, the subscription will be unsuccessful, and an error will be thrown.<br><b>Note:</b> The content type has to be passed as application/json for the body parameter. <br>
     * @summary Update Subscription
     * @param {UpdateCobrandNotificationEventRequest} body eventRequest
     * @param {string} eventName eventName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CobrandApi
     */
    public updateSubscribedEvent(body: UpdateCobrandNotificationEventRequest, eventName: string, options?: any) {
        return CobrandApiFp(this.configuration).updateSubscribedEvent(body, eventName, options)(this.fetch, this.basePath);
    }

}
/**
 * ConfigsApi - fetch parameter creator
 * @export
 */
export const ConfigsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The subscribe events service is used to subscribe to an event for receiving notifications.<br>The callback URL, where the notification will be posted should be provided to this service.<br>If the callback URL is invalid or inaccessible, the subscription will be unsuccessful, and an error will be thrown.<br>Customers can subscribe to REFRESH,DATA_UPDATES,AUTO_REFRESH_UPDATES and LATEST_BALANCE_UPDATES event.<br><br><b>Notes:</b><li>This service is not available in developer sandbox/test environment and will be made available for testing in your dedicated environment, once the contract is signed.<li>The content type has to be passed as application/json for the body parameter.</li>
         * @summary Subscribe For Notification Event
         * @param {CreateConfigsNotificationEventRequest} body eventRequest
         * @param {string} eventName eventName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionNotificationEvent(body: CreateConfigsNotificationEventRequest, eventName: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createSubscriptionNotificationEvent.');
            }
            // verify required parameter 'eventName' is not null or undefined
            if (eventName === null || eventName === undefined) {
                throw new RequiredError('eventName','Required parameter eventName was null or undefined when calling createSubscriptionNotificationEvent.');
            }
            const localVarPath = `/configs/notifications/events/{eventName}`
                .replace(`{${"eventName"}}`, encodeURIComponent(String(eventName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateConfigsNotificationEventRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The delete events service is used to unsubscribe from an events service.<br>
         * @summary Delete Notification Subscription
         * @param {string} eventName eventName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscribedNotificationEvent(eventName: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventName' is not null or undefined
            if (eventName === null || eventName === undefined) {
                throw new RequiredError('eventName','Required parameter eventName was null or undefined when calling deleteSubscribedNotificationEvent.');
            }
            const localVarPath = `/configs/notifications/events/{eventName}`
                .replace(`{${"eventName"}}`, encodeURIComponent(String(eventName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The get events service provides the list of events for which consumers subscribed to receive notifications. <br>
         * @summary Get Subscribed Notification Events
         * @param {string} [eventName] eventName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribedNotificationEvents(eventName?: string, options: any = {}): FetchArgs {
            const localVarPath = `/configs/notifications/events`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (eventName !== undefined) {
                localVarQueryParameter['eventName'] = eventName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The update events service is used to update the callback URL.<br>If the callback URL is invalid or inaccessible, the subscription will be unsuccessful, and an error will be thrown.<br><br><b>Note:</b> <li>The content type has to be passed as application/json for the body parameter. <br>
         * @summary Update Notification Subscription
         * @param {UpdateConfigsNotificationEventRequest} body eventRequest
         * @param {string} eventName eventName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscribedNotificationEvent(body: UpdateConfigsNotificationEventRequest, eventName: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateSubscribedNotificationEvent.');
            }
            // verify required parameter 'eventName' is not null or undefined
            if (eventName === null || eventName === undefined) {
                throw new RequiredError('eventName','Required parameter eventName was null or undefined when calling updateSubscribedNotificationEvent.');
            }
            const localVarPath = `/configs/notifications/events/{eventName}`
                .replace(`{${"eventName"}}`, encodeURIComponent(String(eventName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateConfigsNotificationEventRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigsApi - functional programming interface
 * @export
 */
export const ConfigsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * The subscribe events service is used to subscribe to an event for receiving notifications.<br>The callback URL, where the notification will be posted should be provided to this service.<br>If the callback URL is invalid or inaccessible, the subscription will be unsuccessful, and an error will be thrown.<br>Customers can subscribe to REFRESH,DATA_UPDATES,AUTO_REFRESH_UPDATES and LATEST_BALANCE_UPDATES event.<br><br><b>Notes:</b><li>This service is not available in developer sandbox/test environment and will be made available for testing in your dedicated environment, once the contract is signed.<li>The content type has to be passed as application/json for the body parameter.</li>
         * @summary Subscribe For Notification Event
         * @param {CreateConfigsNotificationEventRequest} body eventRequest
         * @param {string} eventName eventName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionNotificationEvent(body: CreateConfigsNotificationEventRequest, eventName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ConfigsApiFetchParamCreator(configuration).createSubscriptionNotificationEvent(body, eventName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The delete events service is used to unsubscribe from an events service.<br>
         * @summary Delete Notification Subscription
         * @param {string} eventName eventName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscribedNotificationEvent(eventName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ConfigsApiFetchParamCreator(configuration).deleteSubscribedNotificationEvent(eventName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The get events service provides the list of events for which consumers subscribed to receive notifications. <br>
         * @summary Get Subscribed Notification Events
         * @param {string} [eventName] eventName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribedNotificationEvents(eventName?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ConfigsNotificationResponse> {
            const localVarFetchArgs = ConfigsApiFetchParamCreator(configuration).getSubscribedNotificationEvents(eventName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The update events service is used to update the callback URL.<br>If the callback URL is invalid or inaccessible, the subscription will be unsuccessful, and an error will be thrown.<br><br><b>Note:</b> <li>The content type has to be passed as application/json for the body parameter. <br>
         * @summary Update Notification Subscription
         * @param {UpdateConfigsNotificationEventRequest} body eventRequest
         * @param {string} eventName eventName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscribedNotificationEvent(body: UpdateConfigsNotificationEventRequest, eventName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ConfigsApiFetchParamCreator(configuration).updateSubscribedNotificationEvent(body, eventName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ConfigsApi - factory interface
 * @export
 */
export const ConfigsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * The subscribe events service is used to subscribe to an event for receiving notifications.<br>The callback URL, where the notification will be posted should be provided to this service.<br>If the callback URL is invalid or inaccessible, the subscription will be unsuccessful, and an error will be thrown.<br>Customers can subscribe to REFRESH,DATA_UPDATES,AUTO_REFRESH_UPDATES and LATEST_BALANCE_UPDATES event.<br><br><b>Notes:</b><li>This service is not available in developer sandbox/test environment and will be made available for testing in your dedicated environment, once the contract is signed.<li>The content type has to be passed as application/json for the body parameter.</li>
         * @summary Subscribe For Notification Event
         * @param {CreateConfigsNotificationEventRequest} body eventRequest
         * @param {string} eventName eventName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionNotificationEvent(body: CreateConfigsNotificationEventRequest, eventName: string, options?: any) {
            return ConfigsApiFp(configuration).createSubscriptionNotificationEvent(body, eventName, options)(fetch, basePath);
        },
        /**
         * The delete events service is used to unsubscribe from an events service.<br>
         * @summary Delete Notification Subscription
         * @param {string} eventName eventName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscribedNotificationEvent(eventName: string, options?: any) {
            return ConfigsApiFp(configuration).deleteSubscribedNotificationEvent(eventName, options)(fetch, basePath);
        },
        /**
         * The get events service provides the list of events for which consumers subscribed to receive notifications. <br>
         * @summary Get Subscribed Notification Events
         * @param {string} [eventName] eventName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribedNotificationEvents(eventName?: string, options?: any) {
            return ConfigsApiFp(configuration).getSubscribedNotificationEvents(eventName, options)(fetch, basePath);
        },
        /**
         * The update events service is used to update the callback URL.<br>If the callback URL is invalid or inaccessible, the subscription will be unsuccessful, and an error will be thrown.<br><br><b>Note:</b> <li>The content type has to be passed as application/json for the body parameter. <br>
         * @summary Update Notification Subscription
         * @param {UpdateConfigsNotificationEventRequest} body eventRequest
         * @param {string} eventName eventName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscribedNotificationEvent(body: UpdateConfigsNotificationEventRequest, eventName: string, options?: any) {
            return ConfigsApiFp(configuration).updateSubscribedNotificationEvent(body, eventName, options)(fetch, basePath);
        },
    };
};

/**
 * ConfigsApi - object-oriented interface
 * @export
 * @class ConfigsApi
 * @extends {BaseAPI}
 */
export class ConfigsApi extends BaseAPI {
    /**
     * The subscribe events service is used to subscribe to an event for receiving notifications.<br>The callback URL, where the notification will be posted should be provided to this service.<br>If the callback URL is invalid or inaccessible, the subscription will be unsuccessful, and an error will be thrown.<br>Customers can subscribe to REFRESH,DATA_UPDATES,AUTO_REFRESH_UPDATES and LATEST_BALANCE_UPDATES event.<br><br><b>Notes:</b><li>This service is not available in developer sandbox/test environment and will be made available for testing in your dedicated environment, once the contract is signed.<li>The content type has to be passed as application/json for the body parameter.</li>
     * @summary Subscribe For Notification Event
     * @param {CreateConfigsNotificationEventRequest} body eventRequest
     * @param {string} eventName eventName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigsApi
     */
    public createSubscriptionNotificationEvent(body: CreateConfigsNotificationEventRequest, eventName: string, options?: any) {
        return ConfigsApiFp(this.configuration).createSubscriptionNotificationEvent(body, eventName, options)(this.fetch, this.basePath);
    }

    /**
     * The delete events service is used to unsubscribe from an events service.<br>
     * @summary Delete Notification Subscription
     * @param {string} eventName eventName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigsApi
     */
    public deleteSubscribedNotificationEvent(eventName: string, options?: any) {
        return ConfigsApiFp(this.configuration).deleteSubscribedNotificationEvent(eventName, options)(this.fetch, this.basePath);
    }

    /**
     * The get events service provides the list of events for which consumers subscribed to receive notifications. <br>
     * @summary Get Subscribed Notification Events
     * @param {string} [eventName] eventName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigsApi
     */
    public getSubscribedNotificationEvents(eventName?: string, options?: any) {
        return ConfigsApiFp(this.configuration).getSubscribedNotificationEvents(eventName, options)(this.fetch, this.basePath);
    }

    /**
     * The update events service is used to update the callback URL.<br>If the callback URL is invalid or inaccessible, the subscription will be unsuccessful, and an error will be thrown.<br><br><b>Note:</b> <li>The content type has to be passed as application/json for the body parameter. <br>
     * @summary Update Notification Subscription
     * @param {UpdateConfigsNotificationEventRequest} body eventRequest
     * @param {string} eventName eventName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigsApi
     */
    public updateSubscribedNotificationEvent(body: UpdateConfigsNotificationEventRequest, eventName: string, options?: any) {
        return ConfigsApiFp(this.configuration).updateSubscribedNotificationEvent(body, eventName, options)(this.fetch, this.basePath);
    }

}
/**
 * DataExtractsApi - fetch parameter creator
 * @export
 */
export const DataExtractsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The get extracts events service is used to learn about occurrences of data extract related events. This service currently supports only the DATA_UPDATES event.<br>Passing the event name as DATA_UPDATES provides information about users for whom data has been modified in the system for the specified time range. For more information, refer to the <a href=\"https://developer.envestnet.com/resources/yodlee/data-extracts/docs/overview\">Data Extracts</a> page.<br>You can retrieve data in increments of no more than 60 minutes over the period of the last 7 days from today's date.<br>This service is only invoked with either admin access token or a cobrand session.<br>
         * @summary Get Events
         * @param {string} eventName Event Name
         * @param {string} fromDate From DateTime (YYYY-MM-DDThh:mm:ssZ)
         * @param {string} toDate To DateTime (YYYY-MM-DDThh:mm:ssZ)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataExtractsEvents(eventName: string, fromDate: string, toDate: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventName' is not null or undefined
            if (eventName === null || eventName === undefined) {
                throw new RequiredError('eventName','Required parameter eventName was null or undefined when calling getDataExtractsEvents.');
            }
            // verify required parameter 'fromDate' is not null or undefined
            if (fromDate === null || fromDate === undefined) {
                throw new RequiredError('fromDate','Required parameter fromDate was null or undefined when calling getDataExtractsEvents.');
            }
            // verify required parameter 'toDate' is not null or undefined
            if (toDate === null || toDate === undefined) {
                throw new RequiredError('toDate','Required parameter toDate was null or undefined when calling getDataExtractsEvents.');
            }
            const localVarPath = `/dataExtracts/events`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (eventName !== undefined) {
                localVarQueryParameter['eventName'] = eventName;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The get user data service is used to get a user's modified data for a particular period of time for accounts, transactions, holdings, and provider account information.<br>The time difference between fromDate and toDate fields cannot be more than 60 minutes.<br>By default, pagination is available for the transaction entity in this API. In the first response, the API will retrieve 500 transactions along with other data. The response header will provide a link to retrieve the next set of transactions.<br>In the response body of the first API response, totalTransactionsCount indicates the total number of transactions the API will retrieve for the user.<br>This service is only invoked with either admin access token or a cobrand session.<br/>For more information, refer to the <a href=\"https://developer.envestnet.com/resources/yodlee/data-extracts/docs/overview\">Data Extracts</a> page.<br><br><b>Note:</b><li>This service supports the localization feature and accepts locale as a header parameter.</li>
         * @summary Get userData
         * @param {string} fromDate From DateTime (YYYY-MM-DDThh:mm:ssZ)
         * @param {string} loginName Login Name
         * @param {string} toDate To DateTime (YYYY-MM-DDThh:mm:ssZ)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataExtractsUserData(fromDate: string, loginName: string, toDate: string, options: any = {}): FetchArgs {
            // verify required parameter 'fromDate' is not null or undefined
            if (fromDate === null || fromDate === undefined) {
                throw new RequiredError('fromDate','Required parameter fromDate was null or undefined when calling getDataExtractsUserData.');
            }
            // verify required parameter 'loginName' is not null or undefined
            if (loginName === null || loginName === undefined) {
                throw new RequiredError('loginName','Required parameter loginName was null or undefined when calling getDataExtractsUserData.');
            }
            // verify required parameter 'toDate' is not null or undefined
            if (toDate === null || toDate === undefined) {
                throw new RequiredError('toDate','Required parameter toDate was null or undefined when calling getDataExtractsUserData.');
            }
            const localVarPath = `/dataExtracts/userData`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (loginName !== undefined) {
                localVarQueryParameter['loginName'] = loginName;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataExtractsApi - functional programming interface
 * @export
 */
export const DataExtractsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * The get extracts events service is used to learn about occurrences of data extract related events. This service currently supports only the DATA_UPDATES event.<br>Passing the event name as DATA_UPDATES provides information about users for whom data has been modified in the system for the specified time range. For more information, refer to the <a href=\"https://developer.envestnet.com/resources/yodlee/data-extracts/docs/overview\">Data Extracts</a> page.<br>You can retrieve data in increments of no more than 60 minutes over the period of the last 7 days from today's date.<br>This service is only invoked with either admin access token or a cobrand session.<br>
         * @summary Get Events
         * @param {string} eventName Event Name
         * @param {string} fromDate From DateTime (YYYY-MM-DDThh:mm:ssZ)
         * @param {string} toDate To DateTime (YYYY-MM-DDThh:mm:ssZ)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataExtractsEvents(eventName: string, fromDate: string, toDate: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DataExtractsEventResponse> {
            const localVarFetchArgs = DataExtractsApiFetchParamCreator(configuration).getDataExtractsEvents(eventName, fromDate, toDate, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The get user data service is used to get a user's modified data for a particular period of time for accounts, transactions, holdings, and provider account information.<br>The time difference between fromDate and toDate fields cannot be more than 60 minutes.<br>By default, pagination is available for the transaction entity in this API. In the first response, the API will retrieve 500 transactions along with other data. The response header will provide a link to retrieve the next set of transactions.<br>In the response body of the first API response, totalTransactionsCount indicates the total number of transactions the API will retrieve for the user.<br>This service is only invoked with either admin access token or a cobrand session.<br/>For more information, refer to the <a href=\"https://developer.envestnet.com/resources/yodlee/data-extracts/docs/overview\">Data Extracts</a> page.<br><br><b>Note:</b><li>This service supports the localization feature and accepts locale as a header parameter.</li>
         * @summary Get userData
         * @param {string} fromDate From DateTime (YYYY-MM-DDThh:mm:ssZ)
         * @param {string} loginName Login Name
         * @param {string} toDate To DateTime (YYYY-MM-DDThh:mm:ssZ)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataExtractsUserData(fromDate: string, loginName: string, toDate: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DataExtractsUserDataResponse> {
            const localVarFetchArgs = DataExtractsApiFetchParamCreator(configuration).getDataExtractsUserData(fromDate, loginName, toDate, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DataExtractsApi - factory interface
 * @export
 */
export const DataExtractsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * The get extracts events service is used to learn about occurrences of data extract related events. This service currently supports only the DATA_UPDATES event.<br>Passing the event name as DATA_UPDATES provides information about users for whom data has been modified in the system for the specified time range. For more information, refer to the <a href=\"https://developer.envestnet.com/resources/yodlee/data-extracts/docs/overview\">Data Extracts</a> page.<br>You can retrieve data in increments of no more than 60 minutes over the period of the last 7 days from today's date.<br>This service is only invoked with either admin access token or a cobrand session.<br>
         * @summary Get Events
         * @param {string} eventName Event Name
         * @param {string} fromDate From DateTime (YYYY-MM-DDThh:mm:ssZ)
         * @param {string} toDate To DateTime (YYYY-MM-DDThh:mm:ssZ)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataExtractsEvents(eventName: string, fromDate: string, toDate: string, options?: any) {
            return DataExtractsApiFp(configuration).getDataExtractsEvents(eventName, fromDate, toDate, options)(fetch, basePath);
        },
        /**
         * The get user data service is used to get a user's modified data for a particular period of time for accounts, transactions, holdings, and provider account information.<br>The time difference between fromDate and toDate fields cannot be more than 60 minutes.<br>By default, pagination is available for the transaction entity in this API. In the first response, the API will retrieve 500 transactions along with other data. The response header will provide a link to retrieve the next set of transactions.<br>In the response body of the first API response, totalTransactionsCount indicates the total number of transactions the API will retrieve for the user.<br>This service is only invoked with either admin access token or a cobrand session.<br/>For more information, refer to the <a href=\"https://developer.envestnet.com/resources/yodlee/data-extracts/docs/overview\">Data Extracts</a> page.<br><br><b>Note:</b><li>This service supports the localization feature and accepts locale as a header parameter.</li>
         * @summary Get userData
         * @param {string} fromDate From DateTime (YYYY-MM-DDThh:mm:ssZ)
         * @param {string} loginName Login Name
         * @param {string} toDate To DateTime (YYYY-MM-DDThh:mm:ssZ)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataExtractsUserData(fromDate: string, loginName: string, toDate: string, options?: any) {
            return DataExtractsApiFp(configuration).getDataExtractsUserData(fromDate, loginName, toDate, options)(fetch, basePath);
        },
    };
};

/**
 * DataExtractsApi - object-oriented interface
 * @export
 * @class DataExtractsApi
 * @extends {BaseAPI}
 */
export class DataExtractsApi extends BaseAPI {
    /**
     * The get extracts events service is used to learn about occurrences of data extract related events. This service currently supports only the DATA_UPDATES event.<br>Passing the event name as DATA_UPDATES provides information about users for whom data has been modified in the system for the specified time range. For more information, refer to the <a href=\"https://developer.envestnet.com/resources/yodlee/data-extracts/docs/overview\">Data Extracts</a> page.<br>You can retrieve data in increments of no more than 60 minutes over the period of the last 7 days from today's date.<br>This service is only invoked with either admin access token or a cobrand session.<br>
     * @summary Get Events
     * @param {string} eventName Event Name
     * @param {string} fromDate From DateTime (YYYY-MM-DDThh:mm:ssZ)
     * @param {string} toDate To DateTime (YYYY-MM-DDThh:mm:ssZ)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataExtractsApi
     */
    public getDataExtractsEvents(eventName: string, fromDate: string, toDate: string, options?: any) {
        return DataExtractsApiFp(this.configuration).getDataExtractsEvents(eventName, fromDate, toDate, options)(this.fetch, this.basePath);
    }

    /**
     * The get user data service is used to get a user's modified data for a particular period of time for accounts, transactions, holdings, and provider account information.<br>The time difference between fromDate and toDate fields cannot be more than 60 minutes.<br>By default, pagination is available for the transaction entity in this API. In the first response, the API will retrieve 500 transactions along with other data. The response header will provide a link to retrieve the next set of transactions.<br>In the response body of the first API response, totalTransactionsCount indicates the total number of transactions the API will retrieve for the user.<br>This service is only invoked with either admin access token or a cobrand session.<br/>For more information, refer to the <a href=\"https://developer.envestnet.com/resources/yodlee/data-extracts/docs/overview\">Data Extracts</a> page.<br><br><b>Note:</b><li>This service supports the localization feature and accepts locale as a header parameter.</li>
     * @summary Get userData
     * @param {string} fromDate From DateTime (YYYY-MM-DDThh:mm:ssZ)
     * @param {string} loginName Login Name
     * @param {string} toDate To DateTime (YYYY-MM-DDThh:mm:ssZ)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataExtractsApi
     */
    public getDataExtractsUserData(fromDate: string, loginName: string, toDate: string, options?: any) {
        return DataExtractsApiFp(this.configuration).getDataExtractsUserData(fromDate, loginName, toDate, options)(this.fetch, this.basePath);
    }

}
/**
 * DerivedApi - fetch parameter creator
 * @export
 */
export const DerivedApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The get holding summary service is used to get the summary of asset classifications for the user.<br>By default, accounts with status as ACTIVE and TO BE CLOSED will be considered.<br>If the include parameter value is passed as details then a summary with holdings and account information is returned.<br>
         * @summary Get Holding Summary
         * @param {string} [accountIds] Comma separated accountIds
         * @param {string} [classificationType] e.g. Country, Sector, etc.
         * @param {string} [include] details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHoldingSummary(accountIds?: string, classificationType?: string, include?: string, options: any = {}): FetchArgs {
            const localVarPath = `/derived/holdingSummary`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountIds !== undefined) {
                localVarQueryParameter['accountIds'] = accountIds;
            }

            if (classificationType !== undefined) {
                localVarQueryParameter['classificationType'] = classificationType;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The get networth service is used to get the networth for the user.<br>If the include parameter value is passed as details then networth with historical balances is returned. <br>
         * @summary Get Networth Summary
         * @param {string} [accountIds] comma separated accountIds
         * @param {string} [container] bank/creditCard/investment/insurance/loan/realEstate/otherAssets/otherLiabilities
         * @param {string} [fromDate] from date for balance retrieval (YYYY-MM-DD)
         * @param {string} [include] details
         * @param {string} [interval] D-daily, W-weekly or M-monthly
         * @param {number} [skip] skip (Min 0)
         * @param {string} [toDate] toDate for balance retrieval (YYYY-MM-DD)
         * @param {number} [top] top (Max 500)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworth(accountIds?: string, container?: string, fromDate?: string, include?: string, interval?: string, skip?: number, toDate?: string, top?: number, options: any = {}): FetchArgs {
            const localVarPath = `/derived/networth`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountIds !== undefined) {
                localVarQueryParameter['accountIds'] = accountIds;
            }

            if (container !== undefined) {
                localVarQueryParameter['container'] = container;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }

            if (top !== undefined) {
                localVarQueryParameter['top'] = top;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The transaction summary service provides the summary values of transactions for the given date range by category type, high-level categories, or system-defined categories.<br><br>Yodlee has the transaction data stored for a day, month, year and week per category as per the availability of user's data. If the include parameter value is passed as details, then summary details will be returned depending on the interval passed-monthly is the default.<br><br><b>Notes:</b><ol> <li> Details can be requested for only one system-defined category<li>Passing categoryType is mandatory except when the groupBy value is CATEGORY_TYPE<li>Dates will not be respected for monthly, yearly, and weekly details<li>When monthly details are requested, only the fromDate and toDate month will be respected<li>When yearly details are requested, only the fromDate and toDate year will be respected<li>For weekly data points, details will be provided for every Sunday date available within the fromDate and toDate<li>This service supports the localization feature and accepts locale as a header parameter</li></ol>
         * @summary Get Transaction Summary
         * @param {string} groupBy CATEGORY_TYPE, HIGH_LEVEL_CATEGORY or CATEGORY
         * @param {string} [accountId] comma separated account Ids
         * @param {string} [categoryId] comma separated categoryIds
         * @param {string} [categoryType] INCOME, EXPENSE, TRANSFER, UNCATEGORIZE or DEFERRED_COMPENSATION
         * @param {string} [fromDate] YYYY-MM-DD format
         * @param {string} [include] details
         * @param {boolean} [includeUserCategory] TRUE/FALSE
         * @param {string} [interval] D-daily, W-weekly, M-mothly or Y-yearly
         * @param {string} [toDate] YYYY-MM-DD format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionSummary(groupBy: string, accountId?: string, categoryId?: string, categoryType?: string, fromDate?: string, include?: string, includeUserCategory?: boolean, interval?: string, toDate?: string, options: any = {}): FetchArgs {
            // verify required parameter 'groupBy' is not null or undefined
            if (groupBy === null || groupBy === undefined) {
                throw new RequiredError('groupBy','Required parameter groupBy was null or undefined when calling getTransactionSummary.');
            }
            const localVarPath = `/derived/transactionSummary`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }

            if (categoryType !== undefined) {
                localVarQueryParameter['categoryType'] = categoryType;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['groupBy'] = groupBy;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            if (includeUserCategory !== undefined) {
                localVarQueryParameter['includeUserCategory'] = includeUserCategory;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DerivedApi - functional programming interface
 * @export
 */
export const DerivedApiFp = function(configuration?: Configuration) {
    return {
        /**
         * The get holding summary service is used to get the summary of asset classifications for the user.<br>By default, accounts with status as ACTIVE and TO BE CLOSED will be considered.<br>If the include parameter value is passed as details then a summary with holdings and account information is returned.<br>
         * @summary Get Holding Summary
         * @param {string} [accountIds] Comma separated accountIds
         * @param {string} [classificationType] e.g. Country, Sector, etc.
         * @param {string} [include] details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHoldingSummary(accountIds?: string, classificationType?: string, include?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DerivedHoldingSummaryResponse> {
            const localVarFetchArgs = DerivedApiFetchParamCreator(configuration).getHoldingSummary(accountIds, classificationType, include, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The get networth service is used to get the networth for the user.<br>If the include parameter value is passed as details then networth with historical balances is returned. <br>
         * @summary Get Networth Summary
         * @param {string} [accountIds] comma separated accountIds
         * @param {string} [container] bank/creditCard/investment/insurance/loan/realEstate/otherAssets/otherLiabilities
         * @param {string} [fromDate] from date for balance retrieval (YYYY-MM-DD)
         * @param {string} [include] details
         * @param {string} [interval] D-daily, W-weekly or M-monthly
         * @param {number} [skip] skip (Min 0)
         * @param {string} [toDate] toDate for balance retrieval (YYYY-MM-DD)
         * @param {number} [top] top (Max 500)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworth(accountIds?: string, container?: string, fromDate?: string, include?: string, interval?: string, skip?: number, toDate?: string, top?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DerivedNetworthResponse> {
            const localVarFetchArgs = DerivedApiFetchParamCreator(configuration).getNetworth(accountIds, container, fromDate, include, interval, skip, toDate, top, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The transaction summary service provides the summary values of transactions for the given date range by category type, high-level categories, or system-defined categories.<br><br>Yodlee has the transaction data stored for a day, month, year and week per category as per the availability of user's data. If the include parameter value is passed as details, then summary details will be returned depending on the interval passed-monthly is the default.<br><br><b>Notes:</b><ol> <li> Details can be requested for only one system-defined category<li>Passing categoryType is mandatory except when the groupBy value is CATEGORY_TYPE<li>Dates will not be respected for monthly, yearly, and weekly details<li>When monthly details are requested, only the fromDate and toDate month will be respected<li>When yearly details are requested, only the fromDate and toDate year will be respected<li>For weekly data points, details will be provided for every Sunday date available within the fromDate and toDate<li>This service supports the localization feature and accepts locale as a header parameter</li></ol>
         * @summary Get Transaction Summary
         * @param {string} groupBy CATEGORY_TYPE, HIGH_LEVEL_CATEGORY or CATEGORY
         * @param {string} [accountId] comma separated account Ids
         * @param {string} [categoryId] comma separated categoryIds
         * @param {string} [categoryType] INCOME, EXPENSE, TRANSFER, UNCATEGORIZE or DEFERRED_COMPENSATION
         * @param {string} [fromDate] YYYY-MM-DD format
         * @param {string} [include] details
         * @param {boolean} [includeUserCategory] TRUE/FALSE
         * @param {string} [interval] D-daily, W-weekly, M-mothly or Y-yearly
         * @param {string} [toDate] YYYY-MM-DD format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionSummary(groupBy: string, accountId?: string, categoryId?: string, categoryType?: string, fromDate?: string, include?: string, includeUserCategory?: boolean, interval?: string, toDate?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DerivedTransactionSummaryResponse> {
            const localVarFetchArgs = DerivedApiFetchParamCreator(configuration).getTransactionSummary(groupBy, accountId, categoryId, categoryType, fromDate, include, includeUserCategory, interval, toDate, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DerivedApi - factory interface
 * @export
 */
export const DerivedApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * The get holding summary service is used to get the summary of asset classifications for the user.<br>By default, accounts with status as ACTIVE and TO BE CLOSED will be considered.<br>If the include parameter value is passed as details then a summary with holdings and account information is returned.<br>
         * @summary Get Holding Summary
         * @param {string} [accountIds] Comma separated accountIds
         * @param {string} [classificationType] e.g. Country, Sector, etc.
         * @param {string} [include] details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHoldingSummary(accountIds?: string, classificationType?: string, include?: string, options?: any) {
            return DerivedApiFp(configuration).getHoldingSummary(accountIds, classificationType, include, options)(fetch, basePath);
        },
        /**
         * The get networth service is used to get the networth for the user.<br>If the include parameter value is passed as details then networth with historical balances is returned. <br>
         * @summary Get Networth Summary
         * @param {string} [accountIds] comma separated accountIds
         * @param {string} [container] bank/creditCard/investment/insurance/loan/realEstate/otherAssets/otherLiabilities
         * @param {string} [fromDate] from date for balance retrieval (YYYY-MM-DD)
         * @param {string} [include] details
         * @param {string} [interval] D-daily, W-weekly or M-monthly
         * @param {number} [skip] skip (Min 0)
         * @param {string} [toDate] toDate for balance retrieval (YYYY-MM-DD)
         * @param {number} [top] top (Max 500)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworth(accountIds?: string, container?: string, fromDate?: string, include?: string, interval?: string, skip?: number, toDate?: string, top?: number, options?: any) {
            return DerivedApiFp(configuration).getNetworth(accountIds, container, fromDate, include, interval, skip, toDate, top, options)(fetch, basePath);
        },
        /**
         * The transaction summary service provides the summary values of transactions for the given date range by category type, high-level categories, or system-defined categories.<br><br>Yodlee has the transaction data stored for a day, month, year and week per category as per the availability of user's data. If the include parameter value is passed as details, then summary details will be returned depending on the interval passed-monthly is the default.<br><br><b>Notes:</b><ol> <li> Details can be requested for only one system-defined category<li>Passing categoryType is mandatory except when the groupBy value is CATEGORY_TYPE<li>Dates will not be respected for monthly, yearly, and weekly details<li>When monthly details are requested, only the fromDate and toDate month will be respected<li>When yearly details are requested, only the fromDate and toDate year will be respected<li>For weekly data points, details will be provided for every Sunday date available within the fromDate and toDate<li>This service supports the localization feature and accepts locale as a header parameter</li></ol>
         * @summary Get Transaction Summary
         * @param {string} groupBy CATEGORY_TYPE, HIGH_LEVEL_CATEGORY or CATEGORY
         * @param {string} [accountId] comma separated account Ids
         * @param {string} [categoryId] comma separated categoryIds
         * @param {string} [categoryType] INCOME, EXPENSE, TRANSFER, UNCATEGORIZE or DEFERRED_COMPENSATION
         * @param {string} [fromDate] YYYY-MM-DD format
         * @param {string} [include] details
         * @param {boolean} [includeUserCategory] TRUE/FALSE
         * @param {string} [interval] D-daily, W-weekly, M-mothly or Y-yearly
         * @param {string} [toDate] YYYY-MM-DD format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionSummary(groupBy: string, accountId?: string, categoryId?: string, categoryType?: string, fromDate?: string, include?: string, includeUserCategory?: boolean, interval?: string, toDate?: string, options?: any) {
            return DerivedApiFp(configuration).getTransactionSummary(groupBy, accountId, categoryId, categoryType, fromDate, include, includeUserCategory, interval, toDate, options)(fetch, basePath);
        },
    };
};

/**
 * DerivedApi - object-oriented interface
 * @export
 * @class DerivedApi
 * @extends {BaseAPI}
 */
export class DerivedApi extends BaseAPI {
    /**
     * The get holding summary service is used to get the summary of asset classifications for the user.<br>By default, accounts with status as ACTIVE and TO BE CLOSED will be considered.<br>If the include parameter value is passed as details then a summary with holdings and account information is returned.<br>
     * @summary Get Holding Summary
     * @param {string} [accountIds] Comma separated accountIds
     * @param {string} [classificationType] e.g. Country, Sector, etc.
     * @param {string} [include] details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DerivedApi
     */
    public getHoldingSummary(accountIds?: string, classificationType?: string, include?: string, options?: any) {
        return DerivedApiFp(this.configuration).getHoldingSummary(accountIds, classificationType, include, options)(this.fetch, this.basePath);
    }

    /**
     * The get networth service is used to get the networth for the user.<br>If the include parameter value is passed as details then networth with historical balances is returned. <br>
     * @summary Get Networth Summary
     * @param {string} [accountIds] comma separated accountIds
     * @param {string} [container] bank/creditCard/investment/insurance/loan/realEstate/otherAssets/otherLiabilities
     * @param {string} [fromDate] from date for balance retrieval (YYYY-MM-DD)
     * @param {string} [include] details
     * @param {string} [interval] D-daily, W-weekly or M-monthly
     * @param {number} [skip] skip (Min 0)
     * @param {string} [toDate] toDate for balance retrieval (YYYY-MM-DD)
     * @param {number} [top] top (Max 500)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DerivedApi
     */
    public getNetworth(accountIds?: string, container?: string, fromDate?: string, include?: string, interval?: string, skip?: number, toDate?: string, top?: number, options?: any) {
        return DerivedApiFp(this.configuration).getNetworth(accountIds, container, fromDate, include, interval, skip, toDate, top, options)(this.fetch, this.basePath);
    }

    /**
     * The transaction summary service provides the summary values of transactions for the given date range by category type, high-level categories, or system-defined categories.<br><br>Yodlee has the transaction data stored for a day, month, year and week per category as per the availability of user's data. If the include parameter value is passed as details, then summary details will be returned depending on the interval passed-monthly is the default.<br><br><b>Notes:</b><ol> <li> Details can be requested for only one system-defined category<li>Passing categoryType is mandatory except when the groupBy value is CATEGORY_TYPE<li>Dates will not be respected for monthly, yearly, and weekly details<li>When monthly details are requested, only the fromDate and toDate month will be respected<li>When yearly details are requested, only the fromDate and toDate year will be respected<li>For weekly data points, details will be provided for every Sunday date available within the fromDate and toDate<li>This service supports the localization feature and accepts locale as a header parameter</li></ol>
     * @summary Get Transaction Summary
     * @param {string} groupBy CATEGORY_TYPE, HIGH_LEVEL_CATEGORY or CATEGORY
     * @param {string} [accountId] comma separated account Ids
     * @param {string} [categoryId] comma separated categoryIds
     * @param {string} [categoryType] INCOME, EXPENSE, TRANSFER, UNCATEGORIZE or DEFERRED_COMPENSATION
     * @param {string} [fromDate] YYYY-MM-DD format
     * @param {string} [include] details
     * @param {boolean} [includeUserCategory] TRUE/FALSE
     * @param {string} [interval] D-daily, W-weekly, M-mothly or Y-yearly
     * @param {string} [toDate] YYYY-MM-DD format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DerivedApi
     */
    public getTransactionSummary(groupBy: string, accountId?: string, categoryId?: string, categoryType?: string, fromDate?: string, include?: string, includeUserCategory?: boolean, interval?: string, toDate?: string, options?: any) {
        return DerivedApiFp(this.configuration).getTransactionSummary(groupBy, accountId, categoryId, categoryType, fromDate, include, includeUserCategory, interval, toDate, options)(this.fetch, this.basePath);
    }

}
/**
 * DocumentsApi - fetch parameter creator
 * @export
 */
export const DocumentsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The delete document service allows the consumer to delete a document. The deleted document will not be returned in the get documents API. The HTTP response code is 204 (success without content).<br>Documents can be deleted only if the document related dataset attributes are subscribed.<br>
         * @summary Delete Document
         * @param {string} documentId documentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocument(documentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'documentId' is not null or undefined
            if (documentId === null || documentId === undefined) {
                throw new RequiredError('documentId','Required parameter documentId was null or undefined when calling deleteDocument.');
            }
            const localVarPath = `/documents/{documentId}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The get document details service allows consumers to download a document. The document is provided in base64.<br>This API is a premium service which requires subscription in advance to use.  Please contact Yodlee Client Services for more information. <br>
         * @summary Download a Document
         * @param {string} documentId documentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocument(documentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'documentId' is not null or undefined
            if (documentId === null || documentId === undefined) {
                throw new RequiredError('documentId','Required parameter documentId was null or undefined when calling downloadDocument.');
            }
            const localVarPath = `/documents/{documentId}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The get documents service allows customers to search or retrieve metadata related to documents. <br>The API returns the document as per the input parameters passed. If no date range is provided then all downloaded documents will be retrieved. Details of deleted documents or documents associated to closed providerAccount will not be returned. <br>This API is a premium service which requires subscription in advance to use.  Please contact Yodlee Client Services for more information. <br>
         * @summary Get Documents
         * @param {string} [keyword] The string used to search a document by its name.
         * @param {string} [accountId] The unique identifier of an account. Retrieve documents for a given accountId.
         * @param {string} [docType] Accepts only one of the following valid document types: STMT, TAX, and EBILL.
         * @param {string} [fromDate] The date from which documents have to be retrieved.
         * @param {string} [toDate] The date to which documents have to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocuments(keyword?: string, accountId?: string, docType?: string, fromDate?: string, toDate?: string, options: any = {}): FetchArgs {
            const localVarPath = `/documents`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keyword !== undefined) {
                localVarQueryParameter['Keyword'] = keyword;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (docType !== undefined) {
                localVarQueryParameter['docType'] = docType;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentsApi - functional programming interface
 * @export
 */
export const DocumentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * The delete document service allows the consumer to delete a document. The deleted document will not be returned in the get documents API. The HTTP response code is 204 (success without content).<br>Documents can be deleted only if the document related dataset attributes are subscribed.<br>
         * @summary Delete Document
         * @param {string} documentId documentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocument(documentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).deleteDocument(documentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The get document details service allows consumers to download a document. The document is provided in base64.<br>This API is a premium service which requires subscription in advance to use.  Please contact Yodlee Client Services for more information. <br>
         * @summary Download a Document
         * @param {string} documentId documentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocument(documentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DocumentDownloadResponse> {
            const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).downloadDocument(documentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The get documents service allows customers to search or retrieve metadata related to documents. <br>The API returns the document as per the input parameters passed. If no date range is provided then all downloaded documents will be retrieved. Details of deleted documents or documents associated to closed providerAccount will not be returned. <br>This API is a premium service which requires subscription in advance to use.  Please contact Yodlee Client Services for more information. <br>
         * @summary Get Documents
         * @param {string} [keyword] The string used to search a document by its name.
         * @param {string} [accountId] The unique identifier of an account. Retrieve documents for a given accountId.
         * @param {string} [docType] Accepts only one of the following valid document types: STMT, TAX, and EBILL.
         * @param {string} [fromDate] The date from which documents have to be retrieved.
         * @param {string} [toDate] The date to which documents have to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocuments(keyword?: string, accountId?: string, docType?: string, fromDate?: string, toDate?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DocumentResponse> {
            const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).getDocuments(keyword, accountId, docType, fromDate, toDate, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DocumentsApi - factory interface
 * @export
 */
export const DocumentsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * The delete document service allows the consumer to delete a document. The deleted document will not be returned in the get documents API. The HTTP response code is 204 (success without content).<br>Documents can be deleted only if the document related dataset attributes are subscribed.<br>
         * @summary Delete Document
         * @param {string} documentId documentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocument(documentId: string, options?: any) {
            return DocumentsApiFp(configuration).deleteDocument(documentId, options)(fetch, basePath);
        },
        /**
         * The get document details service allows consumers to download a document. The document is provided in base64.<br>This API is a premium service which requires subscription in advance to use.  Please contact Yodlee Client Services for more information. <br>
         * @summary Download a Document
         * @param {string} documentId documentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocument(documentId: string, options?: any) {
            return DocumentsApiFp(configuration).downloadDocument(documentId, options)(fetch, basePath);
        },
        /**
         * The get documents service allows customers to search or retrieve metadata related to documents. <br>The API returns the document as per the input parameters passed. If no date range is provided then all downloaded documents will be retrieved. Details of deleted documents or documents associated to closed providerAccount will not be returned. <br>This API is a premium service which requires subscription in advance to use.  Please contact Yodlee Client Services for more information. <br>
         * @summary Get Documents
         * @param {string} [keyword] The string used to search a document by its name.
         * @param {string} [accountId] The unique identifier of an account. Retrieve documents for a given accountId.
         * @param {string} [docType] Accepts only one of the following valid document types: STMT, TAX, and EBILL.
         * @param {string} [fromDate] The date from which documents have to be retrieved.
         * @param {string} [toDate] The date to which documents have to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocuments(keyword?: string, accountId?: string, docType?: string, fromDate?: string, toDate?: string, options?: any) {
            return DocumentsApiFp(configuration).getDocuments(keyword, accountId, docType, fromDate, toDate, options)(fetch, basePath);
        },
    };
};

/**
 * DocumentsApi - object-oriented interface
 * @export
 * @class DocumentsApi
 * @extends {BaseAPI}
 */
export class DocumentsApi extends BaseAPI {
    /**
     * The delete document service allows the consumer to delete a document. The deleted document will not be returned in the get documents API. The HTTP response code is 204 (success without content).<br>Documents can be deleted only if the document related dataset attributes are subscribed.<br>
     * @summary Delete Document
     * @param {string} documentId documentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public deleteDocument(documentId: string, options?: any) {
        return DocumentsApiFp(this.configuration).deleteDocument(documentId, options)(this.fetch, this.basePath);
    }

    /**
     * The get document details service allows consumers to download a document. The document is provided in base64.<br>This API is a premium service which requires subscription in advance to use.  Please contact Yodlee Client Services for more information. <br>
     * @summary Download a Document
     * @param {string} documentId documentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public downloadDocument(documentId: string, options?: any) {
        return DocumentsApiFp(this.configuration).downloadDocument(documentId, options)(this.fetch, this.basePath);
    }

    /**
     * The get documents service allows customers to search or retrieve metadata related to documents. <br>The API returns the document as per the input parameters passed. If no date range is provided then all downloaded documents will be retrieved. Details of deleted documents or documents associated to closed providerAccount will not be returned. <br>This API is a premium service which requires subscription in advance to use.  Please contact Yodlee Client Services for more information. <br>
     * @summary Get Documents
     * @param {string} [keyword] The string used to search a document by its name.
     * @param {string} [accountId] The unique identifier of an account. Retrieve documents for a given accountId.
     * @param {string} [docType] Accepts only one of the following valid document types: STMT, TAX, and EBILL.
     * @param {string} [fromDate] The date from which documents have to be retrieved.
     * @param {string} [toDate] The date to which documents have to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public getDocuments(keyword?: string, accountId?: string, docType?: string, fromDate?: string, toDate?: string, options?: any) {
        return DocumentsApiFp(this.configuration).getDocuments(keyword, accountId, docType, fromDate, toDate, options)(this.fetch, this.basePath);
    }

}
/**
 * HoldingsApi - fetch parameter creator
 * @export
 */
export const HoldingsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The get asset classifications list service is used to get the supported asset classifications. <br>The response includes different classification types like assetClass, country, sector, style, etc. and the values corresponding to each type.<br>
         * @summary Get Asset Classification List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetClassificationList(options: any = {}): FetchArgs {
            const localVarPath = `/holdings/assetClassificationList`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The get holding types list service is used to get the supported holding types.<br>The response includes different holding types such as future, moneyMarketFund, stock, etc. and it returns the supported holding types <br>
         * @summary Get Holding Type List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHoldingTypeList(options: any = {}): FetchArgs {
            const localVarPath = `/holdings/holdingTypeList`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The get holdings service is used to get the list of holdings of a user.<br>Supported holding types can be employeeStockOption, moneyMarketFund, bond, etc. and is obtained using get holding type list service. <br>Asset classifications for the holdings need to be requested through the \"include\" parameter.<br>Asset classification information for holdings are not available by default, as it is a premium feature.<br>
         * @summary Get Holdings
         * @param {string} [accountId] Comma separated accountId
         * @param {string} [assetClassificationClassificationType] e.g. Country, Sector, etc.
         * @param {string} [classificationValue] e.g. US
         * @param {string} [include] assetClassification
         * @param {string} [providerAccountId] providerAccountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHoldings(accountId?: string, assetClassificationClassificationType?: string, classificationValue?: string, include?: string, providerAccountId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/holdings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (assetClassificationClassificationType !== undefined) {
                localVarQueryParameter['assetClassification.classificationType'] = assetClassificationClassificationType;
            }

            if (classificationValue !== undefined) {
                localVarQueryParameter['classificationValue'] = classificationValue;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            if (providerAccountId !== undefined) {
                localVarQueryParameter['providerAccountId'] = providerAccountId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The get security details service is used to get all the security information for the holdings<br>
         * @summary Get Security Details
         * @param {string} [holdingId] Comma separated holdingId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecurities(holdingId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/holdings/securities`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (holdingId !== undefined) {
                localVarQueryParameter['holdingId'] = holdingId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HoldingsApi - functional programming interface
 * @export
 */
export const HoldingsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * The get asset classifications list service is used to get the supported asset classifications. <br>The response includes different classification types like assetClass, country, sector, style, etc. and the values corresponding to each type.<br>
         * @summary Get Asset Classification List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetClassificationList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HoldingAssetClassificationListResponse> {
            const localVarFetchArgs = HoldingsApiFetchParamCreator(configuration).getAssetClassificationList(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The get holding types list service is used to get the supported holding types.<br>The response includes different holding types such as future, moneyMarketFund, stock, etc. and it returns the supported holding types <br>
         * @summary Get Holding Type List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHoldingTypeList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HoldingTypeListResponse> {
            const localVarFetchArgs = HoldingsApiFetchParamCreator(configuration).getHoldingTypeList(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The get holdings service is used to get the list of holdings of a user.<br>Supported holding types can be employeeStockOption, moneyMarketFund, bond, etc. and is obtained using get holding type list service. <br>Asset classifications for the holdings need to be requested through the \"include\" parameter.<br>Asset classification information for holdings are not available by default, as it is a premium feature.<br>
         * @summary Get Holdings
         * @param {string} [accountId] Comma separated accountId
         * @param {string} [assetClassificationClassificationType] e.g. Country, Sector, etc.
         * @param {string} [classificationValue] e.g. US
         * @param {string} [include] assetClassification
         * @param {string} [providerAccountId] providerAccountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHoldings(accountId?: string, assetClassificationClassificationType?: string, classificationValue?: string, include?: string, providerAccountId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HoldingResponse> {
            const localVarFetchArgs = HoldingsApiFetchParamCreator(configuration).getHoldings(accountId, assetClassificationClassificationType, classificationValue, include, providerAccountId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The get security details service is used to get all the security information for the holdings<br>
         * @summary Get Security Details
         * @param {string} [holdingId] Comma separated holdingId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecurities(holdingId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HoldingSecuritiesResponse> {
            const localVarFetchArgs = HoldingsApiFetchParamCreator(configuration).getSecurities(holdingId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * HoldingsApi - factory interface
 * @export
 */
export const HoldingsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * The get asset classifications list service is used to get the supported asset classifications. <br>The response includes different classification types like assetClass, country, sector, style, etc. and the values corresponding to each type.<br>
         * @summary Get Asset Classification List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetClassificationList(options?: any) {
            return HoldingsApiFp(configuration).getAssetClassificationList(options)(fetch, basePath);
        },
        /**
         * The get holding types list service is used to get the supported holding types.<br>The response includes different holding types such as future, moneyMarketFund, stock, etc. and it returns the supported holding types <br>
         * @summary Get Holding Type List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHoldingTypeList(options?: any) {
            return HoldingsApiFp(configuration).getHoldingTypeList(options)(fetch, basePath);
        },
        /**
         * The get holdings service is used to get the list of holdings of a user.<br>Supported holding types can be employeeStockOption, moneyMarketFund, bond, etc. and is obtained using get holding type list service. <br>Asset classifications for the holdings need to be requested through the \"include\" parameter.<br>Asset classification information for holdings are not available by default, as it is a premium feature.<br>
         * @summary Get Holdings
         * @param {string} [accountId] Comma separated accountId
         * @param {string} [assetClassificationClassificationType] e.g. Country, Sector, etc.
         * @param {string} [classificationValue] e.g. US
         * @param {string} [include] assetClassification
         * @param {string} [providerAccountId] providerAccountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHoldings(accountId?: string, assetClassificationClassificationType?: string, classificationValue?: string, include?: string, providerAccountId?: string, options?: any) {
            return HoldingsApiFp(configuration).getHoldings(accountId, assetClassificationClassificationType, classificationValue, include, providerAccountId, options)(fetch, basePath);
        },
        /**
         * The get security details service is used to get all the security information for the holdings<br>
         * @summary Get Security Details
         * @param {string} [holdingId] Comma separated holdingId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecurities(holdingId?: string, options?: any) {
            return HoldingsApiFp(configuration).getSecurities(holdingId, options)(fetch, basePath);
        },
    };
};

/**
 * HoldingsApi - object-oriented interface
 * @export
 * @class HoldingsApi
 * @extends {BaseAPI}
 */
export class HoldingsApi extends BaseAPI {
    /**
     * The get asset classifications list service is used to get the supported asset classifications. <br>The response includes different classification types like assetClass, country, sector, style, etc. and the values corresponding to each type.<br>
     * @summary Get Asset Classification List
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HoldingsApi
     */
    public getAssetClassificationList(options?: any) {
        return HoldingsApiFp(this.configuration).getAssetClassificationList(options)(this.fetch, this.basePath);
    }

    /**
     * The get holding types list service is used to get the supported holding types.<br>The response includes different holding types such as future, moneyMarketFund, stock, etc. and it returns the supported holding types <br>
     * @summary Get Holding Type List
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HoldingsApi
     */
    public getHoldingTypeList(options?: any) {
        return HoldingsApiFp(this.configuration).getHoldingTypeList(options)(this.fetch, this.basePath);
    }

    /**
     * The get holdings service is used to get the list of holdings of a user.<br>Supported holding types can be employeeStockOption, moneyMarketFund, bond, etc. and is obtained using get holding type list service. <br>Asset classifications for the holdings need to be requested through the \"include\" parameter.<br>Asset classification information for holdings are not available by default, as it is a premium feature.<br>
     * @summary Get Holdings
     * @param {string} [accountId] Comma separated accountId
     * @param {string} [assetClassificationClassificationType] e.g. Country, Sector, etc.
     * @param {string} [classificationValue] e.g. US
     * @param {string} [include] assetClassification
     * @param {string} [providerAccountId] providerAccountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HoldingsApi
     */
    public getHoldings(accountId?: string, assetClassificationClassificationType?: string, classificationValue?: string, include?: string, providerAccountId?: string, options?: any) {
        return HoldingsApiFp(this.configuration).getHoldings(accountId, assetClassificationClassificationType, classificationValue, include, providerAccountId, options)(this.fetch, this.basePath);
    }

    /**
     * The get security details service is used to get all the security information for the holdings<br>
     * @summary Get Security Details
     * @param {string} [holdingId] Comma separated holdingId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HoldingsApi
     */
    public getSecurities(holdingId?: string, options?: any) {
        return HoldingsApiFp(this.configuration).getSecurities(holdingId, options)(this.fetch, this.basePath);
    }

}
/**
 * ProviderAccountsApi - fetch parameter creator
 * @export
 */
export const ProviderAccountsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The delete provider account service is used to delete a provider account from the Yodlee system. This service also deletes the accounts that are created in the Yodlee system for that provider account. <br>This service does not return a response. The HTTP response code is 204 (Success with no content).<br>
         * @summary Delete Provider Account
         * @param {number} providerAccountId providerAccountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProviderAccount(providerAccountId: number, options: any = {}): FetchArgs {
            // verify required parameter 'providerAccountId' is not null or undefined
            if (providerAccountId === null || providerAccountId === undefined) {
                throw new RequiredError('providerAccountId','Required parameter providerAccountId was null or undefined when calling deleteProviderAccount.');
            }
            const localVarPath = `/providerAccounts/{providerAccountId}`
                .replace(`{${"providerAccountId"}}`, encodeURIComponent(String(providerAccountId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <i>This API implementation notes is intended for FastLink 4 users. For FastLink 3 users, additional integration notes related to this endpoint is available <a href=\"https://developer.envestnet.com/resources/yodlee/fastlink-3/docs/api-integrations\">here</a>.</i><br><br>The update account API is used to:<br> <ul><li>Retrieve the latest information of all the eligible accounts that belong to the user.<li>Check the status of the providerAccount before invoking this API. Do not call this API to trigger any action on a providerAccount when an action is already in progress for the providerAccount.<li>If the customer has subscribed to the REFRESH event notification and invoked this API, relevant notifications will be sent to the customer.<li>Check all the dataset additional statuses returned in the response because the provider account status is drawn from the dataset additional statuses.<li>Updating preferences using this API will trigger refreshes.<li> The content type has to be passed as application/json for the body parameter.</ul><br>-----------------------------------------------------------------------------------------------------------------------------------------<br><br><b>Update All Eligible Accounts - Notes:</b><br><ul><li>This API will trigger a refresh for all the eligible provider accounts(both OB and credential-based accounts).<li>This API will not refresh closed, inactive, or UAR accounts, or accounts with refreshes in-progress or recently refreshed non-OB accounts.<li>No parameters should be passed to this API to trigger this action.<li>Do not call this API often. Our recommendation is to call this only at the time the user logs in to your app because it can hamper other API calls performance.<li>The response only contains information for accounts that were refreshed. If no accounts are eligible for refresh, no response is returned.</ul>
         * @summary Update Account
         * @param {string} providerAccountIds comma separated providerAccountIds
         * @param {ProviderAccountRequest} [body] loginForm or field entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editCredentialsOrRefreshProviderAccount(providerAccountIds: string, body?: ProviderAccountRequest, options: any = {}): FetchArgs {
            // verify required parameter 'providerAccountIds' is not null or undefined
            if (providerAccountIds === null || providerAccountIds === undefined) {
                throw new RequiredError('providerAccountIds','Required parameter providerAccountIds was null or undefined when calling editCredentialsOrRefreshProviderAccount.');
            }
            const localVarPath = `/providerAccounts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (providerAccountIds !== undefined) {
                localVarQueryParameter['providerAccountIds'] = providerAccountIds;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProviderAccountRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The get provider accounts service is used to return all the provider accounts added by the user. <br>This includes the failed and successfully added provider accounts.<br>
         * @summary Get Provider Accounts
         * @param {string} [include] include
         * @param {string} [providerIds] Comma separated providerIds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProviderAccounts(include?: string, providerIds?: string, options: any = {}): FetchArgs {
            const localVarPath = `/providerAccounts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            if (providerIds !== undefined) {
                localVarQueryParameter['providerIds'] = providerIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The get provider account details service is used to learn the status of adding accounts and updating accounts.<br>This service has to be called continuously to know the progress level of the triggered process. This service also provides the MFA information requested by the provider site.<br>When <i>include = credentials</i>, questions is passed as input, the service returns the credentials (non-password values) and questions stored in the Yodlee system for that provider account. <br><br><b>Note:</b> <li>The password and answer fields are not returned in the response.</li>
         * @summary Get Provider Account Details
         * @param {number} providerAccountId providerAccountId
         * @param {string} [include] include credentials,questions
         * @param {string} [requestId] The unique identifier for the request that returns contextual data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviderAccount(providerAccountId: number, include?: string, requestId?: string, options: any = {}): FetchArgs {
            // verify required parameter 'providerAccountId' is not null or undefined
            if (providerAccountId === null || providerAccountId === undefined) {
                throw new RequiredError('providerAccountId','Required parameter providerAccountId was null or undefined when calling getProviderAccount.');
            }
            const localVarPath = `/providerAccounts/{providerAccountId}`
                .replace(`{${"providerAccountId"}}`, encodeURIComponent(String(providerAccountId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            if (requestId !== undefined) {
                localVarQueryParameter['requestId'] = requestId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Refer GET /verification/holderProfile</b><br>The get provider accounts profile service is used to return the user profile details that are associated to the provider account. <br>
         * @summary Get User Profile Details
         * @param {string} [providerAccountId] Comma separated providerAccountIds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviderAccountProfiles(providerAccountId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/providerAccounts/profile`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (providerAccountId !== undefined) {
                localVarQueryParameter['providerAccountId'] = providerAccountId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This api service will allow you to refresh the Non-MFA provider accounts against a configName, i.e refresh will respect the configurations of the configName while refreshing the account.<br>Note: this service will only work with FastLink 4 users.<br>
         * @summary Refresh Provider Account
         * @param {ProviderAccountRefreshRequest} body refreshRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshProviderAccount(body: ProviderAccountRefreshRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling refreshProviderAccount.');
            }
            const localVarPath = `/providerAccounts/refresh`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProviderAccountRefreshRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to update preferences like data extracts and auto refreshes without triggering refresh for the providerAccount.<br>Setting isDataExtractsEnabled to false will not trigger data extracts notification and dataExtracts/events will not reflect any data change that is happening for the providerAccount.<br>Modified data will not be provided in the dataExtracts/userData endpoint.<br>Setting isAutoRefreshEnabled to false will not trigger auto refreshes for the provider account.<br>
         * @summary Update Preferences
         * @param {ProviderAccountPreferencesRequest} body preferences
         * @param {number} providerAccountId providerAccountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePreferences(body: ProviderAccountPreferencesRequest, providerAccountId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updatePreferences.');
            }
            // verify required parameter 'providerAccountId' is not null or undefined
            if (providerAccountId === null || providerAccountId === undefined) {
                throw new RequiredError('providerAccountId','Required parameter providerAccountId was null or undefined when calling updatePreferences.');
            }
            const localVarPath = `/providerAccounts/{providerAccountId}/preferences`
                .replace(`{${"providerAccountId"}}`, encodeURIComponent(String(providerAccountId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProviderAccountPreferencesRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProviderAccountsApi - functional programming interface
 * @export
 */
export const ProviderAccountsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * The delete provider account service is used to delete a provider account from the Yodlee system. This service also deletes the accounts that are created in the Yodlee system for that provider account. <br>This service does not return a response. The HTTP response code is 204 (Success with no content).<br>
         * @summary Delete Provider Account
         * @param {number} providerAccountId providerAccountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProviderAccount(providerAccountId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProviderAccountsApiFetchParamCreator(configuration).deleteProviderAccount(providerAccountId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * <i>This API implementation notes is intended for FastLink 4 users. For FastLink 3 users, additional integration notes related to this endpoint is available <a href=\"https://developer.envestnet.com/resources/yodlee/fastlink-3/docs/api-integrations\">here</a>.</i><br><br>The update account API is used to:<br> <ul><li>Retrieve the latest information of all the eligible accounts that belong to the user.<li>Check the status of the providerAccount before invoking this API. Do not call this API to trigger any action on a providerAccount when an action is already in progress for the providerAccount.<li>If the customer has subscribed to the REFRESH event notification and invoked this API, relevant notifications will be sent to the customer.<li>Check all the dataset additional statuses returned in the response because the provider account status is drawn from the dataset additional statuses.<li>Updating preferences using this API will trigger refreshes.<li> The content type has to be passed as application/json for the body parameter.</ul><br>-----------------------------------------------------------------------------------------------------------------------------------------<br><br><b>Update All Eligible Accounts - Notes:</b><br><ul><li>This API will trigger a refresh for all the eligible provider accounts(both OB and credential-based accounts).<li>This API will not refresh closed, inactive, or UAR accounts, or accounts with refreshes in-progress or recently refreshed non-OB accounts.<li>No parameters should be passed to this API to trigger this action.<li>Do not call this API often. Our recommendation is to call this only at the time the user logs in to your app because it can hamper other API calls performance.<li>The response only contains information for accounts that were refreshed. If no accounts are eligible for refresh, no response is returned.</ul>
         * @summary Update Account
         * @param {string} providerAccountIds comma separated providerAccountIds
         * @param {ProviderAccountRequest} [body] loginForm or field entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editCredentialsOrRefreshProviderAccount(providerAccountIds: string, body?: ProviderAccountRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UpdatedProviderAccountResponse> {
            const localVarFetchArgs = ProviderAccountsApiFetchParamCreator(configuration).editCredentialsOrRefreshProviderAccount(providerAccountIds, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The get provider accounts service is used to return all the provider accounts added by the user. <br>This includes the failed and successfully added provider accounts.<br>
         * @summary Get Provider Accounts
         * @param {string} [include] include
         * @param {string} [providerIds] Comma separated providerIds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProviderAccounts(include?: string, providerIds?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProviderAccountResponse> {
            const localVarFetchArgs = ProviderAccountsApiFetchParamCreator(configuration).getAllProviderAccounts(include, providerIds, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The get provider account details service is used to learn the status of adding accounts and updating accounts.<br>This service has to be called continuously to know the progress level of the triggered process. This service also provides the MFA information requested by the provider site.<br>When <i>include = credentials</i>, questions is passed as input, the service returns the credentials (non-password values) and questions stored in the Yodlee system for that provider account. <br><br><b>Note:</b> <li>The password and answer fields are not returned in the response.</li>
         * @summary Get Provider Account Details
         * @param {number} providerAccountId providerAccountId
         * @param {string} [include] include credentials,questions
         * @param {string} [requestId] The unique identifier for the request that returns contextual data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviderAccount(providerAccountId: number, include?: string, requestId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProviderAccountDetailResponse> {
            const localVarFetchArgs = ProviderAccountsApiFetchParamCreator(configuration).getProviderAccount(providerAccountId, include, requestId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * <b>Refer GET /verification/holderProfile</b><br>The get provider accounts profile service is used to return the user profile details that are associated to the provider account. <br>
         * @summary Get User Profile Details
         * @param {string} [providerAccountId] Comma separated providerAccountIds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviderAccountProfiles(providerAccountId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProviderAccountUserProfileResponse> {
            const localVarFetchArgs = ProviderAccountsApiFetchParamCreator(configuration).getProviderAccountProfiles(providerAccountId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This api service will allow you to refresh the Non-MFA provider accounts against a configName, i.e refresh will respect the configurations of the configName while refreshing the account.<br>Note: this service will only work with FastLink 4 users.<br>
         * @summary Refresh Provider Account
         * @param {ProviderAccountRefreshRequest} body refreshRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshProviderAccount(body: ProviderAccountRefreshRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RefreshProviderAccountResponse> {
            const localVarFetchArgs = ProviderAccountsApiFetchParamCreator(configuration).refreshProviderAccount(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint is used to update preferences like data extracts and auto refreshes without triggering refresh for the providerAccount.<br>Setting isDataExtractsEnabled to false will not trigger data extracts notification and dataExtracts/events will not reflect any data change that is happening for the providerAccount.<br>Modified data will not be provided in the dataExtracts/userData endpoint.<br>Setting isAutoRefreshEnabled to false will not trigger auto refreshes for the provider account.<br>
         * @summary Update Preferences
         * @param {ProviderAccountPreferencesRequest} body preferences
         * @param {number} providerAccountId providerAccountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePreferences(body: ProviderAccountPreferencesRequest, providerAccountId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProviderAccountsApiFetchParamCreator(configuration).updatePreferences(body, providerAccountId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProviderAccountsApi - factory interface
 * @export
 */
export const ProviderAccountsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * The delete provider account service is used to delete a provider account from the Yodlee system. This service also deletes the accounts that are created in the Yodlee system for that provider account. <br>This service does not return a response. The HTTP response code is 204 (Success with no content).<br>
         * @summary Delete Provider Account
         * @param {number} providerAccountId providerAccountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProviderAccount(providerAccountId: number, options?: any) {
            return ProviderAccountsApiFp(configuration).deleteProviderAccount(providerAccountId, options)(fetch, basePath);
        },
        /**
         * <i>This API implementation notes is intended for FastLink 4 users. For FastLink 3 users, additional integration notes related to this endpoint is available <a href=\"https://developer.envestnet.com/resources/yodlee/fastlink-3/docs/api-integrations\">here</a>.</i><br><br>The update account API is used to:<br> <ul><li>Retrieve the latest information of all the eligible accounts that belong to the user.<li>Check the status of the providerAccount before invoking this API. Do not call this API to trigger any action on a providerAccount when an action is already in progress for the providerAccount.<li>If the customer has subscribed to the REFRESH event notification and invoked this API, relevant notifications will be sent to the customer.<li>Check all the dataset additional statuses returned in the response because the provider account status is drawn from the dataset additional statuses.<li>Updating preferences using this API will trigger refreshes.<li> The content type has to be passed as application/json for the body parameter.</ul><br>-----------------------------------------------------------------------------------------------------------------------------------------<br><br><b>Update All Eligible Accounts - Notes:</b><br><ul><li>This API will trigger a refresh for all the eligible provider accounts(both OB and credential-based accounts).<li>This API will not refresh closed, inactive, or UAR accounts, or accounts with refreshes in-progress or recently refreshed non-OB accounts.<li>No parameters should be passed to this API to trigger this action.<li>Do not call this API often. Our recommendation is to call this only at the time the user logs in to your app because it can hamper other API calls performance.<li>The response only contains information for accounts that were refreshed. If no accounts are eligible for refresh, no response is returned.</ul>
         * @summary Update Account
         * @param {string} providerAccountIds comma separated providerAccountIds
         * @param {ProviderAccountRequest} [body] loginForm or field entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editCredentialsOrRefreshProviderAccount(providerAccountIds: string, body?: ProviderAccountRequest, options?: any) {
            return ProviderAccountsApiFp(configuration).editCredentialsOrRefreshProviderAccount(providerAccountIds, body, options)(fetch, basePath);
        },
        /**
         * The get provider accounts service is used to return all the provider accounts added by the user. <br>This includes the failed and successfully added provider accounts.<br>
         * @summary Get Provider Accounts
         * @param {string} [include] include
         * @param {string} [providerIds] Comma separated providerIds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProviderAccounts(include?: string, providerIds?: string, options?: any) {
            return ProviderAccountsApiFp(configuration).getAllProviderAccounts(include, providerIds, options)(fetch, basePath);
        },
        /**
         * The get provider account details service is used to learn the status of adding accounts and updating accounts.<br>This service has to be called continuously to know the progress level of the triggered process. This service also provides the MFA information requested by the provider site.<br>When <i>include = credentials</i>, questions is passed as input, the service returns the credentials (non-password values) and questions stored in the Yodlee system for that provider account. <br><br><b>Note:</b> <li>The password and answer fields are not returned in the response.</li>
         * @summary Get Provider Account Details
         * @param {number} providerAccountId providerAccountId
         * @param {string} [include] include credentials,questions
         * @param {string} [requestId] The unique identifier for the request that returns contextual data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviderAccount(providerAccountId: number, include?: string, requestId?: string, options?: any) {
            return ProviderAccountsApiFp(configuration).getProviderAccount(providerAccountId, include, requestId, options)(fetch, basePath);
        },
        /**
         * <b>Refer GET /verification/holderProfile</b><br>The get provider accounts profile service is used to return the user profile details that are associated to the provider account. <br>
         * @summary Get User Profile Details
         * @param {string} [providerAccountId] Comma separated providerAccountIds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviderAccountProfiles(providerAccountId?: string, options?: any) {
            return ProviderAccountsApiFp(configuration).getProviderAccountProfiles(providerAccountId, options)(fetch, basePath);
        },
        /**
         * This api service will allow you to refresh the Non-MFA provider accounts against a configName, i.e refresh will respect the configurations of the configName while refreshing the account.<br>Note: this service will only work with FastLink 4 users.<br>
         * @summary Refresh Provider Account
         * @param {ProviderAccountRefreshRequest} body refreshRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshProviderAccount(body: ProviderAccountRefreshRequest, options?: any) {
            return ProviderAccountsApiFp(configuration).refreshProviderAccount(body, options)(fetch, basePath);
        },
        /**
         * This endpoint is used to update preferences like data extracts and auto refreshes without triggering refresh for the providerAccount.<br>Setting isDataExtractsEnabled to false will not trigger data extracts notification and dataExtracts/events will not reflect any data change that is happening for the providerAccount.<br>Modified data will not be provided in the dataExtracts/userData endpoint.<br>Setting isAutoRefreshEnabled to false will not trigger auto refreshes for the provider account.<br>
         * @summary Update Preferences
         * @param {ProviderAccountPreferencesRequest} body preferences
         * @param {number} providerAccountId providerAccountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePreferences(body: ProviderAccountPreferencesRequest, providerAccountId: number, options?: any) {
            return ProviderAccountsApiFp(configuration).updatePreferences(body, providerAccountId, options)(fetch, basePath);
        },
    };
};

/**
 * ProviderAccountsApi - object-oriented interface
 * @export
 * @class ProviderAccountsApi
 * @extends {BaseAPI}
 */
export class ProviderAccountsApi extends BaseAPI {
    /**
     * The delete provider account service is used to delete a provider account from the Yodlee system. This service also deletes the accounts that are created in the Yodlee system for that provider account. <br>This service does not return a response. The HTTP response code is 204 (Success with no content).<br>
     * @summary Delete Provider Account
     * @param {number} providerAccountId providerAccountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderAccountsApi
     */
    public deleteProviderAccount(providerAccountId: number, options?: any) {
        return ProviderAccountsApiFp(this.configuration).deleteProviderAccount(providerAccountId, options)(this.fetch, this.basePath);
    }

    /**
     * <i>This API implementation notes is intended for FastLink 4 users. For FastLink 3 users, additional integration notes related to this endpoint is available <a href=\"https://developer.envestnet.com/resources/yodlee/fastlink-3/docs/api-integrations\">here</a>.</i><br><br>The update account API is used to:<br> <ul><li>Retrieve the latest information of all the eligible accounts that belong to the user.<li>Check the status of the providerAccount before invoking this API. Do not call this API to trigger any action on a providerAccount when an action is already in progress for the providerAccount.<li>If the customer has subscribed to the REFRESH event notification and invoked this API, relevant notifications will be sent to the customer.<li>Check all the dataset additional statuses returned in the response because the provider account status is drawn from the dataset additional statuses.<li>Updating preferences using this API will trigger refreshes.<li> The content type has to be passed as application/json for the body parameter.</ul><br>-----------------------------------------------------------------------------------------------------------------------------------------<br><br><b>Update All Eligible Accounts - Notes:</b><br><ul><li>This API will trigger a refresh for all the eligible provider accounts(both OB and credential-based accounts).<li>This API will not refresh closed, inactive, or UAR accounts, or accounts with refreshes in-progress or recently refreshed non-OB accounts.<li>No parameters should be passed to this API to trigger this action.<li>Do not call this API often. Our recommendation is to call this only at the time the user logs in to your app because it can hamper other API calls performance.<li>The response only contains information for accounts that were refreshed. If no accounts are eligible for refresh, no response is returned.</ul>
     * @summary Update Account
     * @param {string} providerAccountIds comma separated providerAccountIds
     * @param {ProviderAccountRequest} [body] loginForm or field entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderAccountsApi
     */
    public editCredentialsOrRefreshProviderAccount(providerAccountIds: string, body?: ProviderAccountRequest, options?: any) {
        return ProviderAccountsApiFp(this.configuration).editCredentialsOrRefreshProviderAccount(providerAccountIds, body, options)(this.fetch, this.basePath);
    }

    /**
     * The get provider accounts service is used to return all the provider accounts added by the user. <br>This includes the failed and successfully added provider accounts.<br>
     * @summary Get Provider Accounts
     * @param {string} [include] include
     * @param {string} [providerIds] Comma separated providerIds.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderAccountsApi
     */
    public getAllProviderAccounts(include?: string, providerIds?: string, options?: any) {
        return ProviderAccountsApiFp(this.configuration).getAllProviderAccounts(include, providerIds, options)(this.fetch, this.basePath);
    }

    /**
     * The get provider account details service is used to learn the status of adding accounts and updating accounts.<br>This service has to be called continuously to know the progress level of the triggered process. This service also provides the MFA information requested by the provider site.<br>When <i>include = credentials</i>, questions is passed as input, the service returns the credentials (non-password values) and questions stored in the Yodlee system for that provider account. <br><br><b>Note:</b> <li>The password and answer fields are not returned in the response.</li>
     * @summary Get Provider Account Details
     * @param {number} providerAccountId providerAccountId
     * @param {string} [include] include credentials,questions
     * @param {string} [requestId] The unique identifier for the request that returns contextual data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderAccountsApi
     */
    public getProviderAccount(providerAccountId: number, include?: string, requestId?: string, options?: any) {
        return ProviderAccountsApiFp(this.configuration).getProviderAccount(providerAccountId, include, requestId, options)(this.fetch, this.basePath);
    }

    /**
     * <b>Refer GET /verification/holderProfile</b><br>The get provider accounts profile service is used to return the user profile details that are associated to the provider account. <br>
     * @summary Get User Profile Details
     * @param {string} [providerAccountId] Comma separated providerAccountIds.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderAccountsApi
     */
    public getProviderAccountProfiles(providerAccountId?: string, options?: any) {
        return ProviderAccountsApiFp(this.configuration).getProviderAccountProfiles(providerAccountId, options)(this.fetch, this.basePath);
    }

    /**
     * This api service will allow you to refresh the Non-MFA provider accounts against a configName, i.e refresh will respect the configurations of the configName while refreshing the account.<br>Note: this service will only work with FastLink 4 users.<br>
     * @summary Refresh Provider Account
     * @param {ProviderAccountRefreshRequest} body refreshRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderAccountsApi
     */
    public refreshProviderAccount(body: ProviderAccountRefreshRequest, options?: any) {
        return ProviderAccountsApiFp(this.configuration).refreshProviderAccount(body, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint is used to update preferences like data extracts and auto refreshes without triggering refresh for the providerAccount.<br>Setting isDataExtractsEnabled to false will not trigger data extracts notification and dataExtracts/events will not reflect any data change that is happening for the providerAccount.<br>Modified data will not be provided in the dataExtracts/userData endpoint.<br>Setting isAutoRefreshEnabled to false will not trigger auto refreshes for the provider account.<br>
     * @summary Update Preferences
     * @param {ProviderAccountPreferencesRequest} body preferences
     * @param {number} providerAccountId providerAccountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderAccountsApi
     */
    public updatePreferences(body: ProviderAccountPreferencesRequest, providerAccountId: number, options?: any) {
        return ProviderAccountsApiFp(this.configuration).updatePreferences(body, providerAccountId, options)(this.fetch, this.basePath);
    }

}
/**
 * ProvidersApi - fetch parameter creator
 * @export
 */
export const ProvidersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <i>This API implementation notes is intended for FastLink 4 users. For FastLink 3 users, additional integration notes related to this endpoint is available <a href=\"https://developer.envestnet.com/resources/yodlee/fastlink-3/docs/api-integrations\">here</a>.</i><br><br>The get provider service is used to get all the providers that are enabled, search a provider service by name or routing number and get popular sites of a region.<br><br>Searching for a provider using a routing number is applicable only to the USA and Canada regions.<br> The valid values for priority are: <br><ol><li> cobrand: Returns providers enabled for the cobrand (Default priority)</li><li>popular: Returns providers popular among users of the customer.</li></ol><br>The skip and top parameters are used for pagination. In the skip and top parameters, pass the number of records to be skipped and retrieved, respectively.The response header provides the links to retrieve the next and previous set of transactions.<br><br> Providers accept the configName as the input to the API and return the providers list based on the configurations of each configName.  For verification, the providers will accept the configName with which has the verification product and the attributes that are chosen in the configName which returns the list of providers that match the criteria.  ***For an example,  /ysl/providers?configName=aggregationAndVerification*** <br><br>Note:</b> <ol><li>In a product flow involving user interaction, Yodlee recommends invoking this service with filters.<li>Without filters, the service may perform slowly as it takes a few minutes to return data in the response.<li>The AuthParameter appears in the response only in case of token-based aggregation sites.<li>The pagination feature only applies when the priority parameter is set as cobrand. If no values are provided in the skip and top parameters, the API will only return the first 500 records.<li>This service supports the localization feature and accepts locale as a header parameter.<li>The capability has been deprecated in query parameter and response. </li></ol>
         * @summary Get Providers
         * @param {string} [capability] CHALLENGE_DEPOSIT_VERIFICATION - capability search is deprecated
         * @param {number} [institutionId] Institution Id for Single site selection
         * @param {string} [name] Name in minimum 1 character or routing number.
         * @param {string} [priority] Search priority
         * @param {string} [providerId] Max 5 Comma seperated Provider Ids
         * @param {number} [skip] skip (Min 0) - This is not applicable along with &#x27;name&#x27; parameter.
         * @param {number} [top] top (Max 500) - This is not applicable along with &#x27;name&#x27; parameter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProviders(capability?: string, institutionId?: number, name?: string, priority?: string, providerId?: string, skip?: number, top?: number, options: any = {}): FetchArgs {
            const localVarPath = `/providers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (capability !== undefined) {
                localVarQueryParameter['capability'] = capability;
            }

            if (institutionId !== undefined) {
                localVarQueryParameter['institutionId'] = institutionId;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (priority !== undefined) {
                localVarQueryParameter['priority'] = priority;
            }

            if (providerId !== undefined) {
                localVarQueryParameter['providerId'] = providerId;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (top !== undefined) {
                localVarQueryParameter['top'] = top;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The get provider detail service is used to get detailed information including the login form for a provider.<br>The response is a provider object that includes information such as name of the provider, <br>provider's base URL, a list of containers supported by the provider, the login form details of the provider, etc.<br>Only enabled datasets, attributes and containers gets returned in the response.<br><br><b>Note:</b><li>This service supports the localization feature and accepts locale as a header parameter.<li>The capability has been deprecated in the response.
         * @summary Get Provider Details
         * @param {number} providerId providerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvider(providerId: number, options: any = {}): FetchArgs {
            // verify required parameter 'providerId' is not null or undefined
            if (providerId === null || providerId === undefined) {
                throw new RequiredError('providerId','Required parameter providerId was null or undefined when calling getProvider.');
            }
            const localVarPath = `/providers/{providerId}`
                .replace(`{${"providerId"}}`, encodeURIComponent(String(providerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <i>This API implementation notes is intended for FastLink 4 users. For FastLink 3 users, additional integration notes related to this endpoint is available <a href=\"https://developer.envestnet.com/resources/yodlee/fastlink-3/docs/api-integrations\">here</a>.</i><br><br>The count service provides the total number of providers that get returned in the GET /providers depending on the input parameters passed.<br>If you are implementing pagination for providers, call this endpoint before calling GET /providers to know the number of providers that are returned for the input parameters passed.<br>The functionality of the input parameters remains the same as that of the GET /providers endpoint<br><br><b>Note:</b> <li>The capability has been deprecated in the query parameter.</li>
         * @summary Get Providers Count
         * @param {string} [capability] CHALLENGE_DEPOSIT_VERIFICATION - capability search is deprecated
         * @param {string} [name] Name in minimum 1 character or routing number.
         * @param {string} [priority] Search priority
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvidersCount(capability?: string, name?: string, priority?: string, options: any = {}): FetchArgs {
            const localVarPath = `/providers/count`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (capability !== undefined) {
                localVarQueryParameter['capability'] = capability;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (priority !== undefined) {
                localVarQueryParameter['priority'] = priority;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProvidersApi - functional programming interface
 * @export
 */
export const ProvidersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * <i>This API implementation notes is intended for FastLink 4 users. For FastLink 3 users, additional integration notes related to this endpoint is available <a href=\"https://developer.envestnet.com/resources/yodlee/fastlink-3/docs/api-integrations\">here</a>.</i><br><br>The get provider service is used to get all the providers that are enabled, search a provider service by name or routing number and get popular sites of a region.<br><br>Searching for a provider using a routing number is applicable only to the USA and Canada regions.<br> The valid values for priority are: <br><ol><li> cobrand: Returns providers enabled for the cobrand (Default priority)</li><li>popular: Returns providers popular among users of the customer.</li></ol><br>The skip and top parameters are used for pagination. In the skip and top parameters, pass the number of records to be skipped and retrieved, respectively.The response header provides the links to retrieve the next and previous set of transactions.<br><br> Providers accept the configName as the input to the API and return the providers list based on the configurations of each configName.  For verification, the providers will accept the configName with which has the verification product and the attributes that are chosen in the configName which returns the list of providers that match the criteria.  ***For an example,  /ysl/providers?configName=aggregationAndVerification*** <br><br>Note:</b> <ol><li>In a product flow involving user interaction, Yodlee recommends invoking this service with filters.<li>Without filters, the service may perform slowly as it takes a few minutes to return data in the response.<li>The AuthParameter appears in the response only in case of token-based aggregation sites.<li>The pagination feature only applies when the priority parameter is set as cobrand. If no values are provided in the skip and top parameters, the API will only return the first 500 records.<li>This service supports the localization feature and accepts locale as a header parameter.<li>The capability has been deprecated in query parameter and response. </li></ol>
         * @summary Get Providers
         * @param {string} [capability] CHALLENGE_DEPOSIT_VERIFICATION - capability search is deprecated
         * @param {number} [institutionId] Institution Id for Single site selection
         * @param {string} [name] Name in minimum 1 character or routing number.
         * @param {string} [priority] Search priority
         * @param {string} [providerId] Max 5 Comma seperated Provider Ids
         * @param {number} [skip] skip (Min 0) - This is not applicable along with &#x27;name&#x27; parameter.
         * @param {number} [top] top (Max 500) - This is not applicable along with &#x27;name&#x27; parameter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProviders(capability?: string, institutionId?: number, name?: string, priority?: string, providerId?: string, skip?: number, top?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProviderResponse> {
            const localVarFetchArgs = ProvidersApiFetchParamCreator(configuration).getAllProviders(capability, institutionId, name, priority, providerId, skip, top, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The get provider detail service is used to get detailed information including the login form for a provider.<br>The response is a provider object that includes information such as name of the provider, <br>provider's base URL, a list of containers supported by the provider, the login form details of the provider, etc.<br>Only enabled datasets, attributes and containers gets returned in the response.<br><br><b>Note:</b><li>This service supports the localization feature and accepts locale as a header parameter.<li>The capability has been deprecated in the response.
         * @summary Get Provider Details
         * @param {number} providerId providerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvider(providerId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProviderDetailResponse> {
            const localVarFetchArgs = ProvidersApiFetchParamCreator(configuration).getProvider(providerId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * <i>This API implementation notes is intended for FastLink 4 users. For FastLink 3 users, additional integration notes related to this endpoint is available <a href=\"https://developer.envestnet.com/resources/yodlee/fastlink-3/docs/api-integrations\">here</a>.</i><br><br>The count service provides the total number of providers that get returned in the GET /providers depending on the input parameters passed.<br>If you are implementing pagination for providers, call this endpoint before calling GET /providers to know the number of providers that are returned for the input parameters passed.<br>The functionality of the input parameters remains the same as that of the GET /providers endpoint<br><br><b>Note:</b> <li>The capability has been deprecated in the query parameter.</li>
         * @summary Get Providers Count
         * @param {string} [capability] CHALLENGE_DEPOSIT_VERIFICATION - capability search is deprecated
         * @param {string} [name] Name in minimum 1 character or routing number.
         * @param {string} [priority] Search priority
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvidersCount(capability?: string, name?: string, priority?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProvidersCountResponse> {
            const localVarFetchArgs = ProvidersApiFetchParamCreator(configuration).getProvidersCount(capability, name, priority, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProvidersApi - factory interface
 * @export
 */
export const ProvidersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <i>This API implementation notes is intended for FastLink 4 users. For FastLink 3 users, additional integration notes related to this endpoint is available <a href=\"https://developer.envestnet.com/resources/yodlee/fastlink-3/docs/api-integrations\">here</a>.</i><br><br>The get provider service is used to get all the providers that are enabled, search a provider service by name or routing number and get popular sites of a region.<br><br>Searching for a provider using a routing number is applicable only to the USA and Canada regions.<br> The valid values for priority are: <br><ol><li> cobrand: Returns providers enabled for the cobrand (Default priority)</li><li>popular: Returns providers popular among users of the customer.</li></ol><br>The skip and top parameters are used for pagination. In the skip and top parameters, pass the number of records to be skipped and retrieved, respectively.The response header provides the links to retrieve the next and previous set of transactions.<br><br> Providers accept the configName as the input to the API and return the providers list based on the configurations of each configName.  For verification, the providers will accept the configName with which has the verification product and the attributes that are chosen in the configName which returns the list of providers that match the criteria.  ***For an example,  /ysl/providers?configName=aggregationAndVerification*** <br><br>Note:</b> <ol><li>In a product flow involving user interaction, Yodlee recommends invoking this service with filters.<li>Without filters, the service may perform slowly as it takes a few minutes to return data in the response.<li>The AuthParameter appears in the response only in case of token-based aggregation sites.<li>The pagination feature only applies when the priority parameter is set as cobrand. If no values are provided in the skip and top parameters, the API will only return the first 500 records.<li>This service supports the localization feature and accepts locale as a header parameter.<li>The capability has been deprecated in query parameter and response. </li></ol>
         * @summary Get Providers
         * @param {string} [capability] CHALLENGE_DEPOSIT_VERIFICATION - capability search is deprecated
         * @param {number} [institutionId] Institution Id for Single site selection
         * @param {string} [name] Name in minimum 1 character or routing number.
         * @param {string} [priority] Search priority
         * @param {string} [providerId] Max 5 Comma seperated Provider Ids
         * @param {number} [skip] skip (Min 0) - This is not applicable along with &#x27;name&#x27; parameter.
         * @param {number} [top] top (Max 500) - This is not applicable along with &#x27;name&#x27; parameter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProviders(capability?: string, institutionId?: number, name?: string, priority?: string, providerId?: string, skip?: number, top?: number, options?: any) {
            return ProvidersApiFp(configuration).getAllProviders(capability, institutionId, name, priority, providerId, skip, top, options)(fetch, basePath);
        },
        /**
         * The get provider detail service is used to get detailed information including the login form for a provider.<br>The response is a provider object that includes information such as name of the provider, <br>provider's base URL, a list of containers supported by the provider, the login form details of the provider, etc.<br>Only enabled datasets, attributes and containers gets returned in the response.<br><br><b>Note:</b><li>This service supports the localization feature and accepts locale as a header parameter.<li>The capability has been deprecated in the response.
         * @summary Get Provider Details
         * @param {number} providerId providerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvider(providerId: number, options?: any) {
            return ProvidersApiFp(configuration).getProvider(providerId, options)(fetch, basePath);
        },
        /**
         * <i>This API implementation notes is intended for FastLink 4 users. For FastLink 3 users, additional integration notes related to this endpoint is available <a href=\"https://developer.envestnet.com/resources/yodlee/fastlink-3/docs/api-integrations\">here</a>.</i><br><br>The count service provides the total number of providers that get returned in the GET /providers depending on the input parameters passed.<br>If you are implementing pagination for providers, call this endpoint before calling GET /providers to know the number of providers that are returned for the input parameters passed.<br>The functionality of the input parameters remains the same as that of the GET /providers endpoint<br><br><b>Note:</b> <li>The capability has been deprecated in the query parameter.</li>
         * @summary Get Providers Count
         * @param {string} [capability] CHALLENGE_DEPOSIT_VERIFICATION - capability search is deprecated
         * @param {string} [name] Name in minimum 1 character or routing number.
         * @param {string} [priority] Search priority
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvidersCount(capability?: string, name?: string, priority?: string, options?: any) {
            return ProvidersApiFp(configuration).getProvidersCount(capability, name, priority, options)(fetch, basePath);
        },
    };
};

/**
 * ProvidersApi - object-oriented interface
 * @export
 * @class ProvidersApi
 * @extends {BaseAPI}
 */
export class ProvidersApi extends BaseAPI {
    /**
     * <i>This API implementation notes is intended for FastLink 4 users. For FastLink 3 users, additional integration notes related to this endpoint is available <a href=\"https://developer.envestnet.com/resources/yodlee/fastlink-3/docs/api-integrations\">here</a>.</i><br><br>The get provider service is used to get all the providers that are enabled, search a provider service by name or routing number and get popular sites of a region.<br><br>Searching for a provider using a routing number is applicable only to the USA and Canada regions.<br> The valid values for priority are: <br><ol><li> cobrand: Returns providers enabled for the cobrand (Default priority)</li><li>popular: Returns providers popular among users of the customer.</li></ol><br>The skip and top parameters are used for pagination. In the skip and top parameters, pass the number of records to be skipped and retrieved, respectively.The response header provides the links to retrieve the next and previous set of transactions.<br><br> Providers accept the configName as the input to the API and return the providers list based on the configurations of each configName.  For verification, the providers will accept the configName with which has the verification product and the attributes that are chosen in the configName which returns the list of providers that match the criteria.  ***For an example,  /ysl/providers?configName=aggregationAndVerification*** <br><br>Note:</b> <ol><li>In a product flow involving user interaction, Yodlee recommends invoking this service with filters.<li>Without filters, the service may perform slowly as it takes a few minutes to return data in the response.<li>The AuthParameter appears in the response only in case of token-based aggregation sites.<li>The pagination feature only applies when the priority parameter is set as cobrand. If no values are provided in the skip and top parameters, the API will only return the first 500 records.<li>This service supports the localization feature and accepts locale as a header parameter.<li>The capability has been deprecated in query parameter and response. </li></ol>
     * @summary Get Providers
     * @param {string} [capability] CHALLENGE_DEPOSIT_VERIFICATION - capability search is deprecated
     * @param {number} [institutionId] Institution Id for Single site selection
     * @param {string} [name] Name in minimum 1 character or routing number.
     * @param {string} [priority] Search priority
     * @param {string} [providerId] Max 5 Comma seperated Provider Ids
     * @param {number} [skip] skip (Min 0) - This is not applicable along with &#x27;name&#x27; parameter.
     * @param {number} [top] top (Max 500) - This is not applicable along with &#x27;name&#x27; parameter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvidersApi
     */
    public getAllProviders(capability?: string, institutionId?: number, name?: string, priority?: string, providerId?: string, skip?: number, top?: number, options?: any) {
        return ProvidersApiFp(this.configuration).getAllProviders(capability, institutionId, name, priority, providerId, skip, top, options)(this.fetch, this.basePath);
    }

    /**
     * The get provider detail service is used to get detailed information including the login form for a provider.<br>The response is a provider object that includes information such as name of the provider, <br>provider's base URL, a list of containers supported by the provider, the login form details of the provider, etc.<br>Only enabled datasets, attributes and containers gets returned in the response.<br><br><b>Note:</b><li>This service supports the localization feature and accepts locale as a header parameter.<li>The capability has been deprecated in the response.
     * @summary Get Provider Details
     * @param {number} providerId providerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvidersApi
     */
    public getProvider(providerId: number, options?: any) {
        return ProvidersApiFp(this.configuration).getProvider(providerId, options)(this.fetch, this.basePath);
    }

    /**
     * <i>This API implementation notes is intended for FastLink 4 users. For FastLink 3 users, additional integration notes related to this endpoint is available <a href=\"https://developer.envestnet.com/resources/yodlee/fastlink-3/docs/api-integrations\">here</a>.</i><br><br>The count service provides the total number of providers that get returned in the GET /providers depending on the input parameters passed.<br>If you are implementing pagination for providers, call this endpoint before calling GET /providers to know the number of providers that are returned for the input parameters passed.<br>The functionality of the input parameters remains the same as that of the GET /providers endpoint<br><br><b>Note:</b> <li>The capability has been deprecated in the query parameter.</li>
     * @summary Get Providers Count
     * @param {string} [capability] CHALLENGE_DEPOSIT_VERIFICATION - capability search is deprecated
     * @param {string} [name] Name in minimum 1 character or routing number.
     * @param {string} [priority] Search priority
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvidersApi
     */
    public getProvidersCount(capability?: string, name?: string, priority?: string, options?: any) {
        return ProvidersApiFp(this.configuration).getProvidersCount(capability, name, priority, options)(this.fetch, this.basePath);
    }

}
/**
 * StatementsApi - fetch parameter creator
 * @export
 */
export const StatementsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The statements service is used to get the list of statement related information. <br>By default, all the latest statements of active and to be closed accounts are retrieved for the user. <br>Certain sites do not have both a statement date and a due date. When a fromDate is passed as an input, all the statements that have the due date on or after the passed date are retrieved. <br>For sites that do not have the due date, statements that have the statement date on or after the passed date are retrieved. <br>The default value of \"isLatest\" is true. To retrieve historical statements isLatest needs to be set to false.<br>
         * @summary Get Statements
         * @param {string} [accountId] accountId
         * @param {string} [container] creditCard/loan/insurance
         * @param {string} [fromDate] from date for statement retrieval (YYYY-MM-DD)
         * @param {string} [isLatest] isLatest (true/false)
         * @param {string} [status] ACTIVE,TO_BE_CLOSED,CLOSED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatements(accountId?: string, container?: string, fromDate?: string, isLatest?: string, status?: string, options: any = {}): FetchArgs {
            const localVarPath = `/statements`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (container !== undefined) {
                localVarQueryParameter['container'] = container;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (isLatest !== undefined) {
                localVarQueryParameter['isLatest'] = isLatest;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatementsApi - functional programming interface
 * @export
 */
export const StatementsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * The statements service is used to get the list of statement related information. <br>By default, all the latest statements of active and to be closed accounts are retrieved for the user. <br>Certain sites do not have both a statement date and a due date. When a fromDate is passed as an input, all the statements that have the due date on or after the passed date are retrieved. <br>For sites that do not have the due date, statements that have the statement date on or after the passed date are retrieved. <br>The default value of \"isLatest\" is true. To retrieve historical statements isLatest needs to be set to false.<br>
         * @summary Get Statements
         * @param {string} [accountId] accountId
         * @param {string} [container] creditCard/loan/insurance
         * @param {string} [fromDate] from date for statement retrieval (YYYY-MM-DD)
         * @param {string} [isLatest] isLatest (true/false)
         * @param {string} [status] ACTIVE,TO_BE_CLOSED,CLOSED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatements(accountId?: string, container?: string, fromDate?: string, isLatest?: string, status?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StatementResponse> {
            const localVarFetchArgs = StatementsApiFetchParamCreator(configuration).getStatements(accountId, container, fromDate, isLatest, status, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StatementsApi - factory interface
 * @export
 */
export const StatementsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * The statements service is used to get the list of statement related information. <br>By default, all the latest statements of active and to be closed accounts are retrieved for the user. <br>Certain sites do not have both a statement date and a due date. When a fromDate is passed as an input, all the statements that have the due date on or after the passed date are retrieved. <br>For sites that do not have the due date, statements that have the statement date on or after the passed date are retrieved. <br>The default value of \"isLatest\" is true. To retrieve historical statements isLatest needs to be set to false.<br>
         * @summary Get Statements
         * @param {string} [accountId] accountId
         * @param {string} [container] creditCard/loan/insurance
         * @param {string} [fromDate] from date for statement retrieval (YYYY-MM-DD)
         * @param {string} [isLatest] isLatest (true/false)
         * @param {string} [status] ACTIVE,TO_BE_CLOSED,CLOSED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatements(accountId?: string, container?: string, fromDate?: string, isLatest?: string, status?: string, options?: any) {
            return StatementsApiFp(configuration).getStatements(accountId, container, fromDate, isLatest, status, options)(fetch, basePath);
        },
    };
};

/**
 * StatementsApi - object-oriented interface
 * @export
 * @class StatementsApi
 * @extends {BaseAPI}
 */
export class StatementsApi extends BaseAPI {
    /**
     * The statements service is used to get the list of statement related information. <br>By default, all the latest statements of active and to be closed accounts are retrieved for the user. <br>Certain sites do not have both a statement date and a due date. When a fromDate is passed as an input, all the statements that have the due date on or after the passed date are retrieved. <br>For sites that do not have the due date, statements that have the statement date on or after the passed date are retrieved. <br>The default value of \"isLatest\" is true. To retrieve historical statements isLatest needs to be set to false.<br>
     * @summary Get Statements
     * @param {string} [accountId] accountId
     * @param {string} [container] creditCard/loan/insurance
     * @param {string} [fromDate] from date for statement retrieval (YYYY-MM-DD)
     * @param {string} [isLatest] isLatest (true/false)
     * @param {string} [status] ACTIVE,TO_BE_CLOSED,CLOSED
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatementsApi
     */
    public getStatements(accountId?: string, container?: string, fromDate?: string, isLatest?: string, status?: string, options?: any) {
        return StatementsApiFp(this.configuration).getStatements(accountId, container, fromDate, isLatest, status, options)(this.fetch, this.basePath);
    }

}
/**
 * TransactionsApi - fetch parameter creator
 * @export
 */
export const TransactionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The Create or Run Transaction Categorization Rule endpoint is used to: <br>Create transaction categorization rules for both system and user-defined categories.<br>Run all the transaction categorization rules to categorize transactions by calling the endpoint with action=run as the query parameter. <br><br>The input body parameters to create transaction categorization rules follow:<br>     categoryId - This field is mandatory and numeric<br>     priority - This field is optional and numeric. Priority decides the order in which the rule gets applied on transactions.<br>     ruleClause - This field is mandatory and should contain at least one rule<br>     field - The value can be description or amount<br><br>       If the field value is description then,<br>         1. operation - value can be stringEquals or stringContains<br>         2. value - value should be min of 3 and max of 50 characters<br><br>       If the field value is amount then, <br>         1. operation - value can be numberEquals, numberLessThan, numberLessThanEquals, numberGreaterThan or numberGreaterThanEquals<br>         2. value - min value 0 and a max value of 99999999999.99 is allowed<br>The HTTP response code is 201 (Created Successfully).
         * @summary Create or Run Transaction Categorization Rule
         * @param {string} [action] To run rules, pass action&#x3D;run. Only value run is supported
         * @param {string} [ruleParam] rules(JSON format) to categorize the transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrRunTransactionCategorizationRules(action?: string, ruleParam?: string, options: any = {}): FetchArgs {
            const localVarPath = `/transactions/categories/rules`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            if (ruleParam !== undefined) {
                localVarQueryParameter['ruleParam'] = ruleParam;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The create transaction categories service is used to create user-defined categories for a system-defined category.<br>The parentCategoryId is the system-defined category id.This can be retrieved using get transaction categories service.<br>The categoryName can accept minimum of 1, maximum of 50 alphanumeric or special characters.<br>The HTTP response code is 201 (Created successfully).<br>
         * @summary Create Category
         * @param {TransactionCategoryRequest} body User Transaction Category in JSON format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionCategory(body: TransactionCategoryRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createTransactionCategory.');
            }
            const localVarPath = `/transactions/categories`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TransactionCategoryRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The delete transaction categorization rule service is used to delete the given user-defined transaction categorization rule for both system-defined category as well as user-defined category.<br>This will delete all the corresponding rule clauses associated with the rule.<br>The HTTP response code is 204 (Success without content).<br>
         * @summary Delete Transaction Categorization Rule
         * @param {number} ruleId ruleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionCategorizationRule(ruleId: number, options: any = {}): FetchArgs {
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new RequiredError('ruleId','Required parameter ruleId was null or undefined when calling deleteTransactionCategorizationRule.');
            }
            const localVarPath = `/transactions/categories/rules/{ruleId}`
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The delete transaction categories service is used to delete the given user-defined category.<br>The HTTP response code is 204 (Success without content).<br>
         * @summary Delete Category
         * @param {number} categoryId categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionCategory(categoryId: number, options: any = {}): FetchArgs {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling deleteTransactionCategory.');
            }
            const localVarPath = `/transactions/categories/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The categories service returns the list of available transaction categories.<br>High level category is returned in the response only if it is opted by the customer.<br>When invoked by passing the cobrand session or admin access token, this service returns the supported transaction categories at the cobrand level. <br>When invoked by passing the cobrand session and the user session or user access token, this service returns the transaction categories <br>along with user-defined categories.<br>Double quotes in the user-defined category name will be prefixed by backslashes (&#92;) in the response, <br>e.g. Toys \"R\" Us.<br/>Source and id are the primary attributes of the category entity.<br><br><b>Note:</b><li>This service supports the localization feature and accepts locale as a header parameter.</li>
         * @summary Get Transaction Category List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionCategories(options: any = {}): FetchArgs {
            const localVarPath = `/transactions/categories`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The get transaction categorization rule service is used to get all the categorization rules.<br>
         * @summary Get Transaction Categorization Rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionCategorizationRules(options: any = {}): FetchArgs {
            const localVarPath = `/transactions/categories/txnRules`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The get transaction categorization rule service is used to get all the categorization rules.<br>
         * @summary Get Transaction Categorization Rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionCategorizationRulesDeprecated(options: any = {}): FetchArgs {
            const localVarPath = `/transactions/categories/rules`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The Transaction service is used to get a list of transactions for a user.<br>By default, this service returns the last 30 days of transactions from today's date.<br>The keyword parameter performs a contains search on the original, consumer, and simple description attributes, replace the special characters #, &, and + with percent-encoding values %23, %26, and %2B respectively. Eg: for -Debit# , pass the input as -Debit%23.<br>Values for categoryId parameter can be fetched from get transaction category list service.<br> The categoryId is used to filter transactions based on system-defined category as well as user-defined category.<br>User-defined categoryIds should be provided in the filter with the prefix ''U''. E.g. U10002<br>The skip and top parameters are used for pagination. In the skip and top parameters pass the number of records to be skipped and retrieved, respectively. The response header provides the links to retrieve the next and previous set of transactions.<br>Double quotes in the merchant name will be prefixed by backslashes (&#92;) in the response, e.g. Toys \"R\" Us. <br>sourceId is a unique ID that the provider site has assigned to the transaction. The source ID is only available for the pre-populated accounts. Pre-populated accounts are the accounts that the FI customers shares with Yodlee, so that the user does not have to add or aggregate those accounts.<br><br><b>Note</b><ul><li><a href=\"https://developer.envestnet.com/resources/yodlee/transaction-data-enrichment/docs\">Transaction Data Enrichment (TDE)</a> is made available for bank and card accounts. The address field in the response is available only when the TDE key is turned on.</li><li>The pagination feature is available by default. If no values are passed in the skip and top parameters, the API will only return the first 500 transactions.</li><li>This service supports the localization feature and accepts locale as a header parameter.</li></ul>
         * @summary Get Transactions
         * @param {string} [accountId] Comma separated accountIds
         * @param {string} [baseType] DEBIT/CREDIT
         * @param {string} [categoryId] Comma separated categoryIds
         * @param {string} [categoryType] Transaction Category Type(UNCATEGORIZE, INCOME, TRANSFER, EXPENSE or DEFERRED_COMPENSATION)
         * @param {string} [container] bank/creditCard/investment/insurance/loan
         * @param {string} [detailCategoryId] Comma separated detailCategoryIds
         * @param {string} [fromDate] Transaction from date(YYYY-MM-DD)
         * @param {string} [highLevelCategoryId] Comma separated highLevelCategoryIds
         * @param {string} [keyword] Transaction search text
         * @param {number} [skip] skip (Min 0)
         * @param {string} [toDate] Transaction end date (YYYY-MM-DD)
         * @param {number} [top] top (Max 500)
         * @param {string} [type] Transaction Type(SELL,SWEEP, etc.) for bank/creditCard/investment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions(accountId?: string, baseType?: string, categoryId?: string, categoryType?: string, container?: string, detailCategoryId?: string, fromDate?: string, highLevelCategoryId?: string, keyword?: string, skip?: number, toDate?: string, top?: number, type?: string, options: any = {}): FetchArgs {
            const localVarPath = `/transactions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (baseType !== undefined) {
                localVarQueryParameter['baseType'] = baseType;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }

            if (categoryType !== undefined) {
                localVarQueryParameter['categoryType'] = categoryType;
            }

            if (container !== undefined) {
                localVarQueryParameter['container'] = container;
            }

            if (detailCategoryId !== undefined) {
                localVarQueryParameter['detailCategoryId'] = detailCategoryId;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (highLevelCategoryId !== undefined) {
                localVarQueryParameter['highLevelCategoryId'] = highLevelCategoryId;
            }

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }

            if (top !== undefined) {
                localVarQueryParameter['top'] = top;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The count service provides the total number of transactions for a specific user depending on the input parameters passed.<br>If you are implementing pagination for transactions, call this endpoint before calling GET /transactions to know the number of transactions that are returned for the input parameters passed.<br>The functionality of the input parameters remains the same as that of the GET /transactions endpoint.<br>
         * @summary Get Transactions Count
         * @param {string} [accountId] Comma separated accountIds 
         * @param {string} [baseType] DEBIT/CREDIT
         * @param {string} [categoryId] Comma separated categoryIds
         * @param {string} [categoryType] Transaction Category Type(UNCATEGORIZE, INCOME, TRANSFER, EXPENSE or DEFERRED_COMPENSATION)
         * @param {string} [container] bank/creditCard/investment/insurance/loan
         * @param {string} [detailCategoryId] Comma separated detailCategoryIds
         * @param {string} [fromDate] Transaction from date(YYYY-MM-DD)
         * @param {string} [highLevelCategoryId] Comma separated highLevelCategoryIds
         * @param {string} [keyword] Transaction search text 
         * @param {string} [toDate] Transaction end date (YYYY-MM-DD)
         * @param {string} [type] Transaction Type(SELL,SWEEP, etc.)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsCount(accountId?: string, baseType?: string, categoryId?: string, categoryType?: string, container?: string, detailCategoryId?: string, fromDate?: string, highLevelCategoryId?: string, keyword?: string, toDate?: string, type?: string, options: any = {}): FetchArgs {
            const localVarPath = `/transactions/count`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (baseType !== undefined) {
                localVarQueryParameter['baseType'] = baseType;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }

            if (categoryType !== undefined) {
                localVarQueryParameter['categoryType'] = categoryType;
            }

            if (container !== undefined) {
                localVarQueryParameter['container'] = container;
            }

            if (detailCategoryId !== undefined) {
                localVarQueryParameter['detailCategoryId'] = detailCategoryId;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (highLevelCategoryId !== undefined) {
                localVarQueryParameter['highLevelCategoryId'] = highLevelCategoryId;
            }

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The run transaction categorization rule service is used to run a rule on transactions, to categorize the transactions.<br>The HTTP response code is 204 (Success with no content).<br>
         * @summary Run Transaction Categorization Rule
         * @param {string} action 
         * @param {number} ruleId Unique id of the categorization rule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runTransactionCategorizationRule(action: string, ruleId: number, options: any = {}): FetchArgs {
            // verify required parameter 'action' is not null or undefined
            if (action === null || action === undefined) {
                throw new RequiredError('action','Required parameter action was null or undefined when calling runTransactionCategorizationRule.');
            }
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new RequiredError('ruleId','Required parameter ruleId was null or undefined when calling runTransactionCategorizationRule.');
            }
            const localVarPath = `/transactions/categories/rules/{ruleId}`
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The update transaction service is used to update the category,consumer description, memo, isPhysical, merchantType, detailCategory for a transaction.<br>The HTTP response code is 204 (Success without content).<br>
         * @summary Update Transaction
         * @param {TransactionRequest} body transactionRequest
         * @param {number} transactionId transactionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction(body: TransactionRequest, transactionId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateTransaction.');
            }
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId','Required parameter transactionId was null or undefined when calling updateTransaction.');
            }
            const localVarPath = `/transactions/{transactionId}`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TransactionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The update transaction categorization rule service is used to update a categorization rule for both system-defined category as well as user-defined category.<br>ruleParam JSON input should be as explained in the create transaction categorization rule service.<br>The HTTP response code is 204 (Success without content).<br>
         * @summary Update Transaction Categorization Rule
         * @param {TransactionCategorizationRuleRequest} body transactionCategoriesRuleRequest
         * @param {number} ruleId ruleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransactionCategorizationRule(body: TransactionCategorizationRuleRequest, ruleId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateTransactionCategorizationRule.');
            }
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new RequiredError('ruleId','Required parameter ruleId was null or undefined when calling updateTransactionCategorizationRule.');
            }
            const localVarPath = `/transactions/categories/rules/{ruleId}`
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TransactionCategorizationRuleRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The update transaction categories service is used to update the transaction category name<br>for a high level category, a system-defined category and a user-defined category.<br>The renamed category can be set back to the original name by passing an empty string for categoryName.<br>The categoryName can accept minimum of 1, maximum of 50 alphanumeric or special characters.<br>The HTTP response code is 204 (Success without content).<br>
         * @summary Update Category
         * @param {UpdateCategoryRequest} body updateCategoryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransactionCategory(body: UpdateCategoryRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateTransactionCategory.');
            }
            const localVarPath = `/transactions/categories`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateCategoryRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * The Create or Run Transaction Categorization Rule endpoint is used to: <br>Create transaction categorization rules for both system and user-defined categories.<br>Run all the transaction categorization rules to categorize transactions by calling the endpoint with action=run as the query parameter. <br><br>The input body parameters to create transaction categorization rules follow:<br>     categoryId - This field is mandatory and numeric<br>     priority - This field is optional and numeric. Priority decides the order in which the rule gets applied on transactions.<br>     ruleClause - This field is mandatory and should contain at least one rule<br>     field - The value can be description or amount<br><br>       If the field value is description then,<br>         1. operation - value can be stringEquals or stringContains<br>         2. value - value should be min of 3 and max of 50 characters<br><br>       If the field value is amount then, <br>         1. operation - value can be numberEquals, numberLessThan, numberLessThanEquals, numberGreaterThan or numberGreaterThanEquals<br>         2. value - min value 0 and a max value of 99999999999.99 is allowed<br>The HTTP response code is 201 (Created Successfully).
         * @summary Create or Run Transaction Categorization Rule
         * @param {string} [action] To run rules, pass action&#x3D;run. Only value run is supported
         * @param {string} [ruleParam] rules(JSON format) to categorize the transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrRunTransactionCategorizationRules(action?: string, ruleParam?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).createOrRunTransactionCategorizationRules(action, ruleParam, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The create transaction categories service is used to create user-defined categories for a system-defined category.<br>The parentCategoryId is the system-defined category id.This can be retrieved using get transaction categories service.<br>The categoryName can accept minimum of 1, maximum of 50 alphanumeric or special characters.<br>The HTTP response code is 201 (Created successfully).<br>
         * @summary Create Category
         * @param {TransactionCategoryRequest} body User Transaction Category in JSON format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionCategory(body: TransactionCategoryRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).createTransactionCategory(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The delete transaction categorization rule service is used to delete the given user-defined transaction categorization rule for both system-defined category as well as user-defined category.<br>This will delete all the corresponding rule clauses associated with the rule.<br>The HTTP response code is 204 (Success without content).<br>
         * @summary Delete Transaction Categorization Rule
         * @param {number} ruleId ruleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionCategorizationRule(ruleId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).deleteTransactionCategorizationRule(ruleId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The delete transaction categories service is used to delete the given user-defined category.<br>The HTTP response code is 204 (Success without content).<br>
         * @summary Delete Category
         * @param {number} categoryId categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionCategory(categoryId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).deleteTransactionCategory(categoryId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The categories service returns the list of available transaction categories.<br>High level category is returned in the response only if it is opted by the customer.<br>When invoked by passing the cobrand session or admin access token, this service returns the supported transaction categories at the cobrand level. <br>When invoked by passing the cobrand session and the user session or user access token, this service returns the transaction categories <br>along with user-defined categories.<br>Double quotes in the user-defined category name will be prefixed by backslashes (&#92;) in the response, <br>e.g. Toys \"R\" Us.<br/>Source and id are the primary attributes of the category entity.<br><br><b>Note:</b><li>This service supports the localization feature and accepts locale as a header parameter.</li>
         * @summary Get Transaction Category List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionCategories(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransactionCategoryResponse> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).getTransactionCategories(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The get transaction categorization rule service is used to get all the categorization rules.<br>
         * @summary Get Transaction Categorization Rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionCategorizationRules(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransactionCategorizationRuleResponse> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).getTransactionCategorizationRules(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The get transaction categorization rule service is used to get all the categorization rules.<br>
         * @summary Get Transaction Categorization Rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionCategorizationRulesDeprecated(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TransactionCategorizationRule>> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).getTransactionCategorizationRulesDeprecated(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The Transaction service is used to get a list of transactions for a user.<br>By default, this service returns the last 30 days of transactions from today's date.<br>The keyword parameter performs a contains search on the original, consumer, and simple description attributes, replace the special characters #, &, and + with percent-encoding values %23, %26, and %2B respectively. Eg: for -Debit# , pass the input as -Debit%23.<br>Values for categoryId parameter can be fetched from get transaction category list service.<br> The categoryId is used to filter transactions based on system-defined category as well as user-defined category.<br>User-defined categoryIds should be provided in the filter with the prefix ''U''. E.g. U10002<br>The skip and top parameters are used for pagination. In the skip and top parameters pass the number of records to be skipped and retrieved, respectively. The response header provides the links to retrieve the next and previous set of transactions.<br>Double quotes in the merchant name will be prefixed by backslashes (&#92;) in the response, e.g. Toys \"R\" Us. <br>sourceId is a unique ID that the provider site has assigned to the transaction. The source ID is only available for the pre-populated accounts. Pre-populated accounts are the accounts that the FI customers shares with Yodlee, so that the user does not have to add or aggregate those accounts.<br><br><b>Note</b><ul><li><a href=\"https://developer.envestnet.com/resources/yodlee/transaction-data-enrichment/docs\">Transaction Data Enrichment (TDE)</a> is made available for bank and card accounts. The address field in the response is available only when the TDE key is turned on.</li><li>The pagination feature is available by default. If no values are passed in the skip and top parameters, the API will only return the first 500 transactions.</li><li>This service supports the localization feature and accepts locale as a header parameter.</li></ul>
         * @summary Get Transactions
         * @param {string} [accountId] Comma separated accountIds
         * @param {string} [baseType] DEBIT/CREDIT
         * @param {string} [categoryId] Comma separated categoryIds
         * @param {string} [categoryType] Transaction Category Type(UNCATEGORIZE, INCOME, TRANSFER, EXPENSE or DEFERRED_COMPENSATION)
         * @param {string} [container] bank/creditCard/investment/insurance/loan
         * @param {string} [detailCategoryId] Comma separated detailCategoryIds
         * @param {string} [fromDate] Transaction from date(YYYY-MM-DD)
         * @param {string} [highLevelCategoryId] Comma separated highLevelCategoryIds
         * @param {string} [keyword] Transaction search text
         * @param {number} [skip] skip (Min 0)
         * @param {string} [toDate] Transaction end date (YYYY-MM-DD)
         * @param {number} [top] top (Max 500)
         * @param {string} [type] Transaction Type(SELL,SWEEP, etc.) for bank/creditCard/investment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions(accountId?: string, baseType?: string, categoryId?: string, categoryType?: string, container?: string, detailCategoryId?: string, fromDate?: string, highLevelCategoryId?: string, keyword?: string, skip?: number, toDate?: string, top?: number, type?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransactionResponse> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).getTransactions(accountId, baseType, categoryId, categoryType, container, detailCategoryId, fromDate, highLevelCategoryId, keyword, skip, toDate, top, type, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The count service provides the total number of transactions for a specific user depending on the input parameters passed.<br>If you are implementing pagination for transactions, call this endpoint before calling GET /transactions to know the number of transactions that are returned for the input parameters passed.<br>The functionality of the input parameters remains the same as that of the GET /transactions endpoint.<br>
         * @summary Get Transactions Count
         * @param {string} [accountId] Comma separated accountIds 
         * @param {string} [baseType] DEBIT/CREDIT
         * @param {string} [categoryId] Comma separated categoryIds
         * @param {string} [categoryType] Transaction Category Type(UNCATEGORIZE, INCOME, TRANSFER, EXPENSE or DEFERRED_COMPENSATION)
         * @param {string} [container] bank/creditCard/investment/insurance/loan
         * @param {string} [detailCategoryId] Comma separated detailCategoryIds
         * @param {string} [fromDate] Transaction from date(YYYY-MM-DD)
         * @param {string} [highLevelCategoryId] Comma separated highLevelCategoryIds
         * @param {string} [keyword] Transaction search text 
         * @param {string} [toDate] Transaction end date (YYYY-MM-DD)
         * @param {string} [type] Transaction Type(SELL,SWEEP, etc.)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsCount(accountId?: string, baseType?: string, categoryId?: string, categoryType?: string, container?: string, detailCategoryId?: string, fromDate?: string, highLevelCategoryId?: string, keyword?: string, toDate?: string, type?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransactionCountResponse> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).getTransactionsCount(accountId, baseType, categoryId, categoryType, container, detailCategoryId, fromDate, highLevelCategoryId, keyword, toDate, type, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The run transaction categorization rule service is used to run a rule on transactions, to categorize the transactions.<br>The HTTP response code is 204 (Success with no content).<br>
         * @summary Run Transaction Categorization Rule
         * @param {string} action 
         * @param {number} ruleId Unique id of the categorization rule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runTransactionCategorizationRule(action: string, ruleId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).runTransactionCategorizationRule(action, ruleId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The update transaction service is used to update the category,consumer description, memo, isPhysical, merchantType, detailCategory for a transaction.<br>The HTTP response code is 204 (Success without content).<br>
         * @summary Update Transaction
         * @param {TransactionRequest} body transactionRequest
         * @param {number} transactionId transactionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction(body: TransactionRequest, transactionId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).updateTransaction(body, transactionId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The update transaction categorization rule service is used to update a categorization rule for both system-defined category as well as user-defined category.<br>ruleParam JSON input should be as explained in the create transaction categorization rule service.<br>The HTTP response code is 204 (Success without content).<br>
         * @summary Update Transaction Categorization Rule
         * @param {TransactionCategorizationRuleRequest} body transactionCategoriesRuleRequest
         * @param {number} ruleId ruleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransactionCategorizationRule(body: TransactionCategorizationRuleRequest, ruleId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).updateTransactionCategorizationRule(body, ruleId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The update transaction categories service is used to update the transaction category name<br>for a high level category, a system-defined category and a user-defined category.<br>The renamed category can be set back to the original name by passing an empty string for categoryName.<br>The categoryName can accept minimum of 1, maximum of 50 alphanumeric or special characters.<br>The HTTP response code is 204 (Success without content).<br>
         * @summary Update Category
         * @param {UpdateCategoryRequest} body updateCategoryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransactionCategory(body: UpdateCategoryRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).updateTransactionCategory(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * The Create or Run Transaction Categorization Rule endpoint is used to: <br>Create transaction categorization rules for both system and user-defined categories.<br>Run all the transaction categorization rules to categorize transactions by calling the endpoint with action=run as the query parameter. <br><br>The input body parameters to create transaction categorization rules follow:<br>     categoryId - This field is mandatory and numeric<br>     priority - This field is optional and numeric. Priority decides the order in which the rule gets applied on transactions.<br>     ruleClause - This field is mandatory and should contain at least one rule<br>     field - The value can be description or amount<br><br>       If the field value is description then,<br>         1. operation - value can be stringEquals or stringContains<br>         2. value - value should be min of 3 and max of 50 characters<br><br>       If the field value is amount then, <br>         1. operation - value can be numberEquals, numberLessThan, numberLessThanEquals, numberGreaterThan or numberGreaterThanEquals<br>         2. value - min value 0 and a max value of 99999999999.99 is allowed<br>The HTTP response code is 201 (Created Successfully).
         * @summary Create or Run Transaction Categorization Rule
         * @param {string} [action] To run rules, pass action&#x3D;run. Only value run is supported
         * @param {string} [ruleParam] rules(JSON format) to categorize the transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrRunTransactionCategorizationRules(action?: string, ruleParam?: string, options?: any) {
            return TransactionsApiFp(configuration).createOrRunTransactionCategorizationRules(action, ruleParam, options)(fetch, basePath);
        },
        /**
         * The create transaction categories service is used to create user-defined categories for a system-defined category.<br>The parentCategoryId is the system-defined category id.This can be retrieved using get transaction categories service.<br>The categoryName can accept minimum of 1, maximum of 50 alphanumeric or special characters.<br>The HTTP response code is 201 (Created successfully).<br>
         * @summary Create Category
         * @param {TransactionCategoryRequest} body User Transaction Category in JSON format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionCategory(body: TransactionCategoryRequest, options?: any) {
            return TransactionsApiFp(configuration).createTransactionCategory(body, options)(fetch, basePath);
        },
        /**
         * The delete transaction categorization rule service is used to delete the given user-defined transaction categorization rule for both system-defined category as well as user-defined category.<br>This will delete all the corresponding rule clauses associated with the rule.<br>The HTTP response code is 204 (Success without content).<br>
         * @summary Delete Transaction Categorization Rule
         * @param {number} ruleId ruleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionCategorizationRule(ruleId: number, options?: any) {
            return TransactionsApiFp(configuration).deleteTransactionCategorizationRule(ruleId, options)(fetch, basePath);
        },
        /**
         * The delete transaction categories service is used to delete the given user-defined category.<br>The HTTP response code is 204 (Success without content).<br>
         * @summary Delete Category
         * @param {number} categoryId categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionCategory(categoryId: number, options?: any) {
            return TransactionsApiFp(configuration).deleteTransactionCategory(categoryId, options)(fetch, basePath);
        },
        /**
         * The categories service returns the list of available transaction categories.<br>High level category is returned in the response only if it is opted by the customer.<br>When invoked by passing the cobrand session or admin access token, this service returns the supported transaction categories at the cobrand level. <br>When invoked by passing the cobrand session and the user session or user access token, this service returns the transaction categories <br>along with user-defined categories.<br>Double quotes in the user-defined category name will be prefixed by backslashes (&#92;) in the response, <br>e.g. Toys \"R\" Us.<br/>Source and id are the primary attributes of the category entity.<br><br><b>Note:</b><li>This service supports the localization feature and accepts locale as a header parameter.</li>
         * @summary Get Transaction Category List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionCategories(options?: any) {
            return TransactionsApiFp(configuration).getTransactionCategories(options)(fetch, basePath);
        },
        /**
         * The get transaction categorization rule service is used to get all the categorization rules.<br>
         * @summary Get Transaction Categorization Rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionCategorizationRules(options?: any) {
            return TransactionsApiFp(configuration).getTransactionCategorizationRules(options)(fetch, basePath);
        },
        /**
         * The get transaction categorization rule service is used to get all the categorization rules.<br>
         * @summary Get Transaction Categorization Rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionCategorizationRulesDeprecated(options?: any) {
            return TransactionsApiFp(configuration).getTransactionCategorizationRulesDeprecated(options)(fetch, basePath);
        },
        /**
         * The Transaction service is used to get a list of transactions for a user.<br>By default, this service returns the last 30 days of transactions from today's date.<br>The keyword parameter performs a contains search on the original, consumer, and simple description attributes, replace the special characters #, &, and + with percent-encoding values %23, %26, and %2B respectively. Eg: for -Debit# , pass the input as -Debit%23.<br>Values for categoryId parameter can be fetched from get transaction category list service.<br> The categoryId is used to filter transactions based on system-defined category as well as user-defined category.<br>User-defined categoryIds should be provided in the filter with the prefix ''U''. E.g. U10002<br>The skip and top parameters are used for pagination. In the skip and top parameters pass the number of records to be skipped and retrieved, respectively. The response header provides the links to retrieve the next and previous set of transactions.<br>Double quotes in the merchant name will be prefixed by backslashes (&#92;) in the response, e.g. Toys \"R\" Us. <br>sourceId is a unique ID that the provider site has assigned to the transaction. The source ID is only available for the pre-populated accounts. Pre-populated accounts are the accounts that the FI customers shares with Yodlee, so that the user does not have to add or aggregate those accounts.<br><br><b>Note</b><ul><li><a href=\"https://developer.envestnet.com/resources/yodlee/transaction-data-enrichment/docs\">Transaction Data Enrichment (TDE)</a> is made available for bank and card accounts. The address field in the response is available only when the TDE key is turned on.</li><li>The pagination feature is available by default. If no values are passed in the skip and top parameters, the API will only return the first 500 transactions.</li><li>This service supports the localization feature and accepts locale as a header parameter.</li></ul>
         * @summary Get Transactions
         * @param {string} [accountId] Comma separated accountIds
         * @param {string} [baseType] DEBIT/CREDIT
         * @param {string} [categoryId] Comma separated categoryIds
         * @param {string} [categoryType] Transaction Category Type(UNCATEGORIZE, INCOME, TRANSFER, EXPENSE or DEFERRED_COMPENSATION)
         * @param {string} [container] bank/creditCard/investment/insurance/loan
         * @param {string} [detailCategoryId] Comma separated detailCategoryIds
         * @param {string} [fromDate] Transaction from date(YYYY-MM-DD)
         * @param {string} [highLevelCategoryId] Comma separated highLevelCategoryIds
         * @param {string} [keyword] Transaction search text
         * @param {number} [skip] skip (Min 0)
         * @param {string} [toDate] Transaction end date (YYYY-MM-DD)
         * @param {number} [top] top (Max 500)
         * @param {string} [type] Transaction Type(SELL,SWEEP, etc.) for bank/creditCard/investment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions(accountId?: string, baseType?: string, categoryId?: string, categoryType?: string, container?: string, detailCategoryId?: string, fromDate?: string, highLevelCategoryId?: string, keyword?: string, skip?: number, toDate?: string, top?: number, type?: string, options?: any) {
            return TransactionsApiFp(configuration).getTransactions(accountId, baseType, categoryId, categoryType, container, detailCategoryId, fromDate, highLevelCategoryId, keyword, skip, toDate, top, type, options)(fetch, basePath);
        },
        /**
         * The count service provides the total number of transactions for a specific user depending on the input parameters passed.<br>If you are implementing pagination for transactions, call this endpoint before calling GET /transactions to know the number of transactions that are returned for the input parameters passed.<br>The functionality of the input parameters remains the same as that of the GET /transactions endpoint.<br>
         * @summary Get Transactions Count
         * @param {string} [accountId] Comma separated accountIds 
         * @param {string} [baseType] DEBIT/CREDIT
         * @param {string} [categoryId] Comma separated categoryIds
         * @param {string} [categoryType] Transaction Category Type(UNCATEGORIZE, INCOME, TRANSFER, EXPENSE or DEFERRED_COMPENSATION)
         * @param {string} [container] bank/creditCard/investment/insurance/loan
         * @param {string} [detailCategoryId] Comma separated detailCategoryIds
         * @param {string} [fromDate] Transaction from date(YYYY-MM-DD)
         * @param {string} [highLevelCategoryId] Comma separated highLevelCategoryIds
         * @param {string} [keyword] Transaction search text 
         * @param {string} [toDate] Transaction end date (YYYY-MM-DD)
         * @param {string} [type] Transaction Type(SELL,SWEEP, etc.)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsCount(accountId?: string, baseType?: string, categoryId?: string, categoryType?: string, container?: string, detailCategoryId?: string, fromDate?: string, highLevelCategoryId?: string, keyword?: string, toDate?: string, type?: string, options?: any) {
            return TransactionsApiFp(configuration).getTransactionsCount(accountId, baseType, categoryId, categoryType, container, detailCategoryId, fromDate, highLevelCategoryId, keyword, toDate, type, options)(fetch, basePath);
        },
        /**
         * The run transaction categorization rule service is used to run a rule on transactions, to categorize the transactions.<br>The HTTP response code is 204 (Success with no content).<br>
         * @summary Run Transaction Categorization Rule
         * @param {string} action 
         * @param {number} ruleId Unique id of the categorization rule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runTransactionCategorizationRule(action: string, ruleId: number, options?: any) {
            return TransactionsApiFp(configuration).runTransactionCategorizationRule(action, ruleId, options)(fetch, basePath);
        },
        /**
         * The update transaction service is used to update the category,consumer description, memo, isPhysical, merchantType, detailCategory for a transaction.<br>The HTTP response code is 204 (Success without content).<br>
         * @summary Update Transaction
         * @param {TransactionRequest} body transactionRequest
         * @param {number} transactionId transactionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction(body: TransactionRequest, transactionId: number, options?: any) {
            return TransactionsApiFp(configuration).updateTransaction(body, transactionId, options)(fetch, basePath);
        },
        /**
         * The update transaction categorization rule service is used to update a categorization rule for both system-defined category as well as user-defined category.<br>ruleParam JSON input should be as explained in the create transaction categorization rule service.<br>The HTTP response code is 204 (Success without content).<br>
         * @summary Update Transaction Categorization Rule
         * @param {TransactionCategorizationRuleRequest} body transactionCategoriesRuleRequest
         * @param {number} ruleId ruleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransactionCategorizationRule(body: TransactionCategorizationRuleRequest, ruleId: number, options?: any) {
            return TransactionsApiFp(configuration).updateTransactionCategorizationRule(body, ruleId, options)(fetch, basePath);
        },
        /**
         * The update transaction categories service is used to update the transaction category name<br>for a high level category, a system-defined category and a user-defined category.<br>The renamed category can be set back to the original name by passing an empty string for categoryName.<br>The categoryName can accept minimum of 1, maximum of 50 alphanumeric or special characters.<br>The HTTP response code is 204 (Success without content).<br>
         * @summary Update Category
         * @param {UpdateCategoryRequest} body updateCategoryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransactionCategory(body: UpdateCategoryRequest, options?: any) {
            return TransactionsApiFp(configuration).updateTransactionCategory(body, options)(fetch, basePath);
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * The Create or Run Transaction Categorization Rule endpoint is used to: <br>Create transaction categorization rules for both system and user-defined categories.<br>Run all the transaction categorization rules to categorize transactions by calling the endpoint with action=run as the query parameter. <br><br>The input body parameters to create transaction categorization rules follow:<br>     categoryId - This field is mandatory and numeric<br>     priority - This field is optional and numeric. Priority decides the order in which the rule gets applied on transactions.<br>     ruleClause - This field is mandatory and should contain at least one rule<br>     field - The value can be description or amount<br><br>       If the field value is description then,<br>         1. operation - value can be stringEquals or stringContains<br>         2. value - value should be min of 3 and max of 50 characters<br><br>       If the field value is amount then, <br>         1. operation - value can be numberEquals, numberLessThan, numberLessThanEquals, numberGreaterThan or numberGreaterThanEquals<br>         2. value - min value 0 and a max value of 99999999999.99 is allowed<br>The HTTP response code is 201 (Created Successfully).
     * @summary Create or Run Transaction Categorization Rule
     * @param {string} [action] To run rules, pass action&#x3D;run. Only value run is supported
     * @param {string} [ruleParam] rules(JSON format) to categorize the transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public createOrRunTransactionCategorizationRules(action?: string, ruleParam?: string, options?: any) {
        return TransactionsApiFp(this.configuration).createOrRunTransactionCategorizationRules(action, ruleParam, options)(this.fetch, this.basePath);
    }

    /**
     * The create transaction categories service is used to create user-defined categories for a system-defined category.<br>The parentCategoryId is the system-defined category id.This can be retrieved using get transaction categories service.<br>The categoryName can accept minimum of 1, maximum of 50 alphanumeric or special characters.<br>The HTTP response code is 201 (Created successfully).<br>
     * @summary Create Category
     * @param {TransactionCategoryRequest} body User Transaction Category in JSON format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public createTransactionCategory(body: TransactionCategoryRequest, options?: any) {
        return TransactionsApiFp(this.configuration).createTransactionCategory(body, options)(this.fetch, this.basePath);
    }

    /**
     * The delete transaction categorization rule service is used to delete the given user-defined transaction categorization rule for both system-defined category as well as user-defined category.<br>This will delete all the corresponding rule clauses associated with the rule.<br>The HTTP response code is 204 (Success without content).<br>
     * @summary Delete Transaction Categorization Rule
     * @param {number} ruleId ruleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public deleteTransactionCategorizationRule(ruleId: number, options?: any) {
        return TransactionsApiFp(this.configuration).deleteTransactionCategorizationRule(ruleId, options)(this.fetch, this.basePath);
    }

    /**
     * The delete transaction categories service is used to delete the given user-defined category.<br>The HTTP response code is 204 (Success without content).<br>
     * @summary Delete Category
     * @param {number} categoryId categoryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public deleteTransactionCategory(categoryId: number, options?: any) {
        return TransactionsApiFp(this.configuration).deleteTransactionCategory(categoryId, options)(this.fetch, this.basePath);
    }

    /**
     * The categories service returns the list of available transaction categories.<br>High level category is returned in the response only if it is opted by the customer.<br>When invoked by passing the cobrand session or admin access token, this service returns the supported transaction categories at the cobrand level. <br>When invoked by passing the cobrand session and the user session or user access token, this service returns the transaction categories <br>along with user-defined categories.<br>Double quotes in the user-defined category name will be prefixed by backslashes (&#92;) in the response, <br>e.g. Toys \"R\" Us.<br/>Source and id are the primary attributes of the category entity.<br><br><b>Note:</b><li>This service supports the localization feature and accepts locale as a header parameter.</li>
     * @summary Get Transaction Category List
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactionCategories(options?: any) {
        return TransactionsApiFp(this.configuration).getTransactionCategories(options)(this.fetch, this.basePath);
    }

    /**
     * The get transaction categorization rule service is used to get all the categorization rules.<br>
     * @summary Get Transaction Categorization Rules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactionCategorizationRules(options?: any) {
        return TransactionsApiFp(this.configuration).getTransactionCategorizationRules(options)(this.fetch, this.basePath);
    }

    /**
     * The get transaction categorization rule service is used to get all the categorization rules.<br>
     * @summary Get Transaction Categorization Rules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactionCategorizationRulesDeprecated(options?: any) {
        return TransactionsApiFp(this.configuration).getTransactionCategorizationRulesDeprecated(options)(this.fetch, this.basePath);
    }

    /**
     * The Transaction service is used to get a list of transactions for a user.<br>By default, this service returns the last 30 days of transactions from today's date.<br>The keyword parameter performs a contains search on the original, consumer, and simple description attributes, replace the special characters #, &, and + with percent-encoding values %23, %26, and %2B respectively. Eg: for -Debit# , pass the input as -Debit%23.<br>Values for categoryId parameter can be fetched from get transaction category list service.<br> The categoryId is used to filter transactions based on system-defined category as well as user-defined category.<br>User-defined categoryIds should be provided in the filter with the prefix ''U''. E.g. U10002<br>The skip and top parameters are used for pagination. In the skip and top parameters pass the number of records to be skipped and retrieved, respectively. The response header provides the links to retrieve the next and previous set of transactions.<br>Double quotes in the merchant name will be prefixed by backslashes (&#92;) in the response, e.g. Toys \"R\" Us. <br>sourceId is a unique ID that the provider site has assigned to the transaction. The source ID is only available for the pre-populated accounts. Pre-populated accounts are the accounts that the FI customers shares with Yodlee, so that the user does not have to add or aggregate those accounts.<br><br><b>Note</b><ul><li><a href=\"https://developer.envestnet.com/resources/yodlee/transaction-data-enrichment/docs\">Transaction Data Enrichment (TDE)</a> is made available for bank and card accounts. The address field in the response is available only when the TDE key is turned on.</li><li>The pagination feature is available by default. If no values are passed in the skip and top parameters, the API will only return the first 500 transactions.</li><li>This service supports the localization feature and accepts locale as a header parameter.</li></ul>
     * @summary Get Transactions
     * @param {string} [accountId] Comma separated accountIds
     * @param {string} [baseType] DEBIT/CREDIT
     * @param {string} [categoryId] Comma separated categoryIds
     * @param {string} [categoryType] Transaction Category Type(UNCATEGORIZE, INCOME, TRANSFER, EXPENSE or DEFERRED_COMPENSATION)
     * @param {string} [container] bank/creditCard/investment/insurance/loan
     * @param {string} [detailCategoryId] Comma separated detailCategoryIds
     * @param {string} [fromDate] Transaction from date(YYYY-MM-DD)
     * @param {string} [highLevelCategoryId] Comma separated highLevelCategoryIds
     * @param {string} [keyword] Transaction search text
     * @param {number} [skip] skip (Min 0)
     * @param {string} [toDate] Transaction end date (YYYY-MM-DD)
     * @param {number} [top] top (Max 500)
     * @param {string} [type] Transaction Type(SELL,SWEEP, etc.) for bank/creditCard/investment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactions(accountId?: string, baseType?: string, categoryId?: string, categoryType?: string, container?: string, detailCategoryId?: string, fromDate?: string, highLevelCategoryId?: string, keyword?: string, skip?: number, toDate?: string, top?: number, type?: string, options?: any) {
        return TransactionsApiFp(this.configuration).getTransactions(accountId, baseType, categoryId, categoryType, container, detailCategoryId, fromDate, highLevelCategoryId, keyword, skip, toDate, top, type, options)(this.fetch, this.basePath);
    }

    /**
     * The count service provides the total number of transactions for a specific user depending on the input parameters passed.<br>If you are implementing pagination for transactions, call this endpoint before calling GET /transactions to know the number of transactions that are returned for the input parameters passed.<br>The functionality of the input parameters remains the same as that of the GET /transactions endpoint.<br>
     * @summary Get Transactions Count
     * @param {string} [accountId] Comma separated accountIds 
     * @param {string} [baseType] DEBIT/CREDIT
     * @param {string} [categoryId] Comma separated categoryIds
     * @param {string} [categoryType] Transaction Category Type(UNCATEGORIZE, INCOME, TRANSFER, EXPENSE or DEFERRED_COMPENSATION)
     * @param {string} [container] bank/creditCard/investment/insurance/loan
     * @param {string} [detailCategoryId] Comma separated detailCategoryIds
     * @param {string} [fromDate] Transaction from date(YYYY-MM-DD)
     * @param {string} [highLevelCategoryId] Comma separated highLevelCategoryIds
     * @param {string} [keyword] Transaction search text 
     * @param {string} [toDate] Transaction end date (YYYY-MM-DD)
     * @param {string} [type] Transaction Type(SELL,SWEEP, etc.)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactionsCount(accountId?: string, baseType?: string, categoryId?: string, categoryType?: string, container?: string, detailCategoryId?: string, fromDate?: string, highLevelCategoryId?: string, keyword?: string, toDate?: string, type?: string, options?: any) {
        return TransactionsApiFp(this.configuration).getTransactionsCount(accountId, baseType, categoryId, categoryType, container, detailCategoryId, fromDate, highLevelCategoryId, keyword, toDate, type, options)(this.fetch, this.basePath);
    }

    /**
     * The run transaction categorization rule service is used to run a rule on transactions, to categorize the transactions.<br>The HTTP response code is 204 (Success with no content).<br>
     * @summary Run Transaction Categorization Rule
     * @param {string} action 
     * @param {number} ruleId Unique id of the categorization rule
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public runTransactionCategorizationRule(action: string, ruleId: number, options?: any) {
        return TransactionsApiFp(this.configuration).runTransactionCategorizationRule(action, ruleId, options)(this.fetch, this.basePath);
    }

    /**
     * The update transaction service is used to update the category,consumer description, memo, isPhysical, merchantType, detailCategory for a transaction.<br>The HTTP response code is 204 (Success without content).<br>
     * @summary Update Transaction
     * @param {TransactionRequest} body transactionRequest
     * @param {number} transactionId transactionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public updateTransaction(body: TransactionRequest, transactionId: number, options?: any) {
        return TransactionsApiFp(this.configuration).updateTransaction(body, transactionId, options)(this.fetch, this.basePath);
    }

    /**
     * The update transaction categorization rule service is used to update a categorization rule for both system-defined category as well as user-defined category.<br>ruleParam JSON input should be as explained in the create transaction categorization rule service.<br>The HTTP response code is 204 (Success without content).<br>
     * @summary Update Transaction Categorization Rule
     * @param {TransactionCategorizationRuleRequest} body transactionCategoriesRuleRequest
     * @param {number} ruleId ruleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public updateTransactionCategorizationRule(body: TransactionCategorizationRuleRequest, ruleId: number, options?: any) {
        return TransactionsApiFp(this.configuration).updateTransactionCategorizationRule(body, ruleId, options)(this.fetch, this.basePath);
    }

    /**
     * The update transaction categories service is used to update the transaction category name<br>for a high level category, a system-defined category and a user-defined category.<br>The renamed category can be set back to the original name by passing an empty string for categoryName.<br>The categoryName can accept minimum of 1, maximum of 50 alphanumeric or special characters.<br>The HTTP response code is 204 (Success without content).<br>
     * @summary Update Category
     * @param {UpdateCategoryRequest} body updateCategoryRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public updateTransactionCategory(body: UpdateCategoryRequest, options?: any) {
        return TransactionsApiFp(this.configuration).updateTransactionCategory(body, options)(this.fetch, this.basePath);
    }

}
/**
 * UserApi - fetch parameter creator
 * @export
 */
export const UserApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The Get Access Tokens service is used to retrieve the access tokens for the application id(s) provided.<br>URL in the response can be used to launch the application for which token is requested.<br><br><b>Note:</b> <li>This endpoint is deprecated for customers using the API Key-based authentication and is applicable only to customers who use the SAML-based authentication.<br>
         * @summary Get Access Tokens
         * @param {string} appIds appIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessTokens(appIds: string, options: any = {}): FetchArgs {
            // verify required parameter 'appIds' is not null or undefined
            if (appIds === null || appIds === undefined) {
                throw new RequiredError('appIds','Required parameter appIds was null or undefined when calling getAccessTokens.');
            }
            const localVarPath = `/user/accessTokens`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (appIds !== undefined) {
                localVarQueryParameter['appIds'] = appIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The get user details service is used to get the user profile information and the application preferences set at the time of user registration.<br>
         * @summary Get User Details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options: any = {}): FetchArgs {
            const localVarPath = `/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The register user service is used to register a user in Yodlee.<br>The loginName cannot include spaces and must be between 3 and 150 characters.<br>locale passed must be one of the supported locales for the customer. <br>Currency provided in the input will be respected in the derived services and the amount fields in the response will be provided in the preferred currency.<br>userParam is accepted as a body parameter. <br><br><b>Note:</b> <li>The content type has to be passed as application/json for the body parameter.</li> <br> Note: We recommend you to not use special characters in loginName other than \"@\", \"#\", \"_\" & \"-\".
         * @summary Register User
         * @param {UserRequest} body userRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(body: UserRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling registerUser.');
            }
            const localVarPath = `/user/register`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The SAML login service is used to authenticate system users with a SAML response.<br>A new user will be created with the input provided if that user isn't already in the system.<br>For existing users, the system will make updates based on changes or new information.<br>When authentication is successful, a user session token is returned.<br><br><b>Note:</b> <li>The content type has to be passed as application/x-www-form-urlencoded. <li>issuer, source and samlResponse should be passed as body parameters.</li>
         * @summary Saml Login
         * @param {string} issuer issuer
         * @param {string} samlResponse samlResponse
         * @param {string} [source] source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        samlLogin(issuer: string, samlResponse: string, source?: string, options: any = {}): FetchArgs {
            // verify required parameter 'issuer' is not null or undefined
            if (issuer === null || issuer === undefined) {
                throw new RequiredError('issuer','Required parameter issuer was null or undefined when calling samlLogin.');
            }
            // verify required parameter 'samlResponse' is not null or undefined
            if (samlResponse === null || samlResponse === undefined) {
                throw new RequiredError('samlResponse','Required parameter samlResponse was null or undefined when calling samlLogin.');
            }
            const localVarPath = `/user/samlLogin`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (issuer !== undefined) {
                localVarQueryParameter['issuer'] = issuer;
            }

            if (samlResponse !== undefined) {
                localVarQueryParameter['samlResponse'] = samlResponse;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The delete user service is used to delete or unregister a user from Yodlee. <br>Once deleted, the information related to the users cannot be retrieved. <br>The HTTP response code is 204 (Success without content)<br>
         * @summary Delete User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unregister(options: any = {}): FetchArgs {
            const localVarPath = `/user/unregister`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The update user details service is used to update user details like name, address, currency preference, etc.<br>Currency provided in the input will be respected in the <a href=\"https://developer.envestnet.com/products/yodlee/core-apis/docs/api-reference#yodlee-coreapis-derivednetworth-get\">Derived</a> services and the amount fields in the response will be provided in the preferred currency.<br>The HTTP response code is 204 (Success without content). <br>
         * @summary Update User Details
         * @param {UpdateUserRequest} body userRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(body: UpdateUserRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateUser.');
            }
            const localVarPath = `/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateUserRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <b>Deprecated</b>: This endpoint is deprecated for API Key-based authentication. The user logout service allows the user to log out of the application.<br>The service does not return a response body. The HTTP response code is 204 (Success with no content).<br>
         * @summary User Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogout(options: any = {}): FetchArgs {
            const localVarPath = `/user/logout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * The Get Access Tokens service is used to retrieve the access tokens for the application id(s) provided.<br>URL in the response can be used to launch the application for which token is requested.<br><br><b>Note:</b> <li>This endpoint is deprecated for customers using the API Key-based authentication and is applicable only to customers who use the SAML-based authentication.<br>
         * @summary Get Access Tokens
         * @param {string} appIds appIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessTokens(appIds: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserAccessTokensResponse> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getAccessTokens(appIds, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The get user details service is used to get the user profile information and the application preferences set at the time of user registration.<br>
         * @summary Get User Details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserDetailResponse> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getUser(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The register user service is used to register a user in Yodlee.<br>The loginName cannot include spaces and must be between 3 and 150 characters.<br>locale passed must be one of the supported locales for the customer. <br>Currency provided in the input will be respected in the derived services and the amount fields in the response will be provided in the preferred currency.<br>userParam is accepted as a body parameter. <br><br><b>Note:</b> <li>The content type has to be passed as application/json for the body parameter.</li> <br> Note: We recommend you to not use special characters in loginName other than \"@\", \"#\", \"_\" & \"-\".
         * @summary Register User
         * @param {UserRequest} body userRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(body: UserRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserResponse> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).registerUser(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The SAML login service is used to authenticate system users with a SAML response.<br>A new user will be created with the input provided if that user isn't already in the system.<br>For existing users, the system will make updates based on changes or new information.<br>When authentication is successful, a user session token is returned.<br><br><b>Note:</b> <li>The content type has to be passed as application/x-www-form-urlencoded. <li>issuer, source and samlResponse should be passed as body parameters.</li>
         * @summary Saml Login
         * @param {string} issuer issuer
         * @param {string} samlResponse samlResponse
         * @param {string} [source] source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        samlLogin(issuer: string, samlResponse: string, source?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserResponse> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).samlLogin(issuer, samlResponse, source, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The delete user service is used to delete or unregister a user from Yodlee. <br>Once deleted, the information related to the users cannot be retrieved. <br>The HTTP response code is 204 (Success without content)<br>
         * @summary Delete User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unregister(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).unregister(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The update user details service is used to update user details like name, address, currency preference, etc.<br>Currency provided in the input will be respected in the <a href=\"https://developer.envestnet.com/products/yodlee/core-apis/docs/api-reference#yodlee-coreapis-derivednetworth-get\">Derived</a> services and the amount fields in the response will be provided in the preferred currency.<br>The HTTP response code is 204 (Success without content). <br>
         * @summary Update User Details
         * @param {UpdateUserRequest} body userRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(body: UpdateUserRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).updateUser(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * <b>Deprecated</b>: This endpoint is deprecated for API Key-based authentication. The user logout service allows the user to log out of the application.<br>The service does not return a response body. The HTTP response code is 204 (Success with no content).<br>
         * @summary User Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogout(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userLogout(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * The Get Access Tokens service is used to retrieve the access tokens for the application id(s) provided.<br>URL in the response can be used to launch the application for which token is requested.<br><br><b>Note:</b> <li>This endpoint is deprecated for customers using the API Key-based authentication and is applicable only to customers who use the SAML-based authentication.<br>
         * @summary Get Access Tokens
         * @param {string} appIds appIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessTokens(appIds: string, options?: any) {
            return UserApiFp(configuration).getAccessTokens(appIds, options)(fetch, basePath);
        },
        /**
         * The get user details service is used to get the user profile information and the application preferences set at the time of user registration.<br>
         * @summary Get User Details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: any) {
            return UserApiFp(configuration).getUser(options)(fetch, basePath);
        },
        /**
         * The register user service is used to register a user in Yodlee.<br>The loginName cannot include spaces and must be between 3 and 150 characters.<br>locale passed must be one of the supported locales for the customer. <br>Currency provided in the input will be respected in the derived services and the amount fields in the response will be provided in the preferred currency.<br>userParam is accepted as a body parameter. <br><br><b>Note:</b> <li>The content type has to be passed as application/json for the body parameter.</li> <br> Note: We recommend you to not use special characters in loginName other than \"@\", \"#\", \"_\" & \"-\".
         * @summary Register User
         * @param {UserRequest} body userRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(body: UserRequest, options?: any) {
            return UserApiFp(configuration).registerUser(body, options)(fetch, basePath);
        },
        /**
         * The SAML login service is used to authenticate system users with a SAML response.<br>A new user will be created with the input provided if that user isn't already in the system.<br>For existing users, the system will make updates based on changes or new information.<br>When authentication is successful, a user session token is returned.<br><br><b>Note:</b> <li>The content type has to be passed as application/x-www-form-urlencoded. <li>issuer, source and samlResponse should be passed as body parameters.</li>
         * @summary Saml Login
         * @param {string} issuer issuer
         * @param {string} samlResponse samlResponse
         * @param {string} [source] source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        samlLogin(issuer: string, samlResponse: string, source?: string, options?: any) {
            return UserApiFp(configuration).samlLogin(issuer, samlResponse, source, options)(fetch, basePath);
        },
        /**
         * The delete user service is used to delete or unregister a user from Yodlee. <br>Once deleted, the information related to the users cannot be retrieved. <br>The HTTP response code is 204 (Success without content)<br>
         * @summary Delete User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unregister(options?: any) {
            return UserApiFp(configuration).unregister(options)(fetch, basePath);
        },
        /**
         * The update user details service is used to update user details like name, address, currency preference, etc.<br>Currency provided in the input will be respected in the <a href=\"https://developer.envestnet.com/products/yodlee/core-apis/docs/api-reference#yodlee-coreapis-derivednetworth-get\">Derived</a> services and the amount fields in the response will be provided in the preferred currency.<br>The HTTP response code is 204 (Success without content). <br>
         * @summary Update User Details
         * @param {UpdateUserRequest} body userRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(body: UpdateUserRequest, options?: any) {
            return UserApiFp(configuration).updateUser(body, options)(fetch, basePath);
        },
        /**
         * <b>Deprecated</b>: This endpoint is deprecated for API Key-based authentication. The user logout service allows the user to log out of the application.<br>The service does not return a response body. The HTTP response code is 204 (Success with no content).<br>
         * @summary User Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogout(options?: any) {
            return UserApiFp(configuration).userLogout(options)(fetch, basePath);
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * The Get Access Tokens service is used to retrieve the access tokens for the application id(s) provided.<br>URL in the response can be used to launch the application for which token is requested.<br><br><b>Note:</b> <li>This endpoint is deprecated for customers using the API Key-based authentication and is applicable only to customers who use the SAML-based authentication.<br>
     * @summary Get Access Tokens
     * @param {string} appIds appIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getAccessTokens(appIds: string, options?: any) {
        return UserApiFp(this.configuration).getAccessTokens(appIds, options)(this.fetch, this.basePath);
    }

    /**
     * The get user details service is used to get the user profile information and the application preferences set at the time of user registration.<br>
     * @summary Get User Details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(options?: any) {
        return UserApiFp(this.configuration).getUser(options)(this.fetch, this.basePath);
    }

    /**
     * The register user service is used to register a user in Yodlee.<br>The loginName cannot include spaces and must be between 3 and 150 characters.<br>locale passed must be one of the supported locales for the customer. <br>Currency provided in the input will be respected in the derived services and the amount fields in the response will be provided in the preferred currency.<br>userParam is accepted as a body parameter. <br><br><b>Note:</b> <li>The content type has to be passed as application/json for the body parameter.</li> <br> Note: We recommend you to not use special characters in loginName other than \"@\", \"#\", \"_\" & \"-\".
     * @summary Register User
     * @param {UserRequest} body userRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public registerUser(body: UserRequest, options?: any) {
        return UserApiFp(this.configuration).registerUser(body, options)(this.fetch, this.basePath);
    }

    /**
     * The SAML login service is used to authenticate system users with a SAML response.<br>A new user will be created with the input provided if that user isn't already in the system.<br>For existing users, the system will make updates based on changes or new information.<br>When authentication is successful, a user session token is returned.<br><br><b>Note:</b> <li>The content type has to be passed as application/x-www-form-urlencoded. <li>issuer, source and samlResponse should be passed as body parameters.</li>
     * @summary Saml Login
     * @param {string} issuer issuer
     * @param {string} samlResponse samlResponse
     * @param {string} [source] source
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public samlLogin(issuer: string, samlResponse: string, source?: string, options?: any) {
        return UserApiFp(this.configuration).samlLogin(issuer, samlResponse, source, options)(this.fetch, this.basePath);
    }

    /**
     * The delete user service is used to delete or unregister a user from Yodlee. <br>Once deleted, the information related to the users cannot be retrieved. <br>The HTTP response code is 204 (Success without content)<br>
     * @summary Delete User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public unregister(options?: any) {
        return UserApiFp(this.configuration).unregister(options)(this.fetch, this.basePath);
    }

    /**
     * The update user details service is used to update user details like name, address, currency preference, etc.<br>Currency provided in the input will be respected in the <a href=\"https://developer.envestnet.com/products/yodlee/core-apis/docs/api-reference#yodlee-coreapis-derivednetworth-get\">Derived</a> services and the amount fields in the response will be provided in the preferred currency.<br>The HTTP response code is 204 (Success without content). <br>
     * @summary Update User Details
     * @param {UpdateUserRequest} body userRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(body: UpdateUserRequest, options?: any) {
        return UserApiFp(this.configuration).updateUser(body, options)(this.fetch, this.basePath);
    }

    /**
     * <b>Deprecated</b>: This endpoint is deprecated for API Key-based authentication. The user logout service allows the user to log out of the application.<br>The service does not return a response body. The HTTP response code is 204 (Success with no content).<br>
     * @summary User Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userLogout(options?: any) {
        return UserApiFp(this.configuration).userLogout(options)(this.fetch, this.basePath);
    }

}
/**
 * VerificationApi - fetch parameter creator
 * @export
 */
export const VerificationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The Holder Profile API service allows retrieving the user's profile details (i.e., PII data such as name, email, phone number, and address) that are available at the provider account and each account level. The API accepts the providerAccountId and retrieves the profile information available under it and all the details available under each of the associated accounts.  <br><br>This service can only be invoked by Yodlee API v1.1, FastLink 3, and FastLink 4 customers. <br><br>
         * @summary Get Holder Profile
         * @param {string} providerAccountId providerAccountId.
         * @param {string} [accountId] accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHolderProfile(providerAccountId: string, accountId?: string, options: any = {}): FetchArgs {
            // verify required parameter 'providerAccountId' is not null or undefined
            if (providerAccountId === null || providerAccountId === undefined) {
                throw new RequiredError('providerAccountId','Required parameter providerAccountId was null or undefined when calling getHolderProfile.');
            }
            const localVarPath = `/verification/holderProfile`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (providerAccountId !== undefined) {
                localVarQueryParameter['providerAccountId'] = providerAccountId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <i>This API implementation notes is intended for FastLink 4 users. For FastLink 3 users, additional integration notes related to this endpoint is available <a href=\"https://developer.envestnet.com/resources/yodlee/fastlink-3/docs/api-integrations\">here</a>.</i><br><br> The get verification status service is used to retrieve the verification status of all accounts for which the CDV process has been initiated.For the CDV process, the account details object returns the user provided account information.
         * @summary Get Verification Status
         * @param {string} [accountId] Comma separated accountId
         * @param {string} [providerAccountId] Comma separated providerAccountId
         * @param {string} [verificationType] verificationType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerificationStatus(accountId?: string, providerAccountId?: string, verificationType?: string, options: any = {}): FetchArgs {
            const localVarPath = `/verification`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (providerAccountId !== undefined) {
                localVarQueryParameter['providerAccountId'] = providerAccountId;
            }

            if (verificationType !== undefined) {
                localVarQueryParameter['verificationType'] = verificationType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The Verified Accounts API v1.1 provides information about the bank and investment accounts that the user  has selected for verification, during the Account Verification flow on FastLink 4. By default, the API only returns information of the accounts that were selected and have been successfully verified. <br><br>
         * @summary Get Verified Accounts
         * @param {string} providerAccountId providerAccountId.
         * @param {string} [accountId] Comma separated accountIds.
         * @param {string} [isSelected] Comma separated isSelected. Allowed values are true, false &lt;br&gt;&lt;b&gt;Note:&lt;/b&gt; If no value is passed, the implicit default value is true.
         * @param {string} [verificationStatus] Comma separated verificationStatus. Allowed values are SUCCESS, FAILED &lt;br&gt;&lt;b&gt;Note:&lt;/b&gt; If no value is passed, the implicit default value is SUCCESS.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerifiedAccounts(providerAccountId: string, accountId?: string, isSelected?: string, verificationStatus?: string, options: any = {}): FetchArgs {
            // verify required parameter 'providerAccountId' is not null or undefined
            if (providerAccountId === null || providerAccountId === undefined) {
                throw new RequiredError('providerAccountId','Required parameter providerAccountId was null or undefined when calling getVerifiedAccounts.');
            }
            const localVarPath = `/verification/verifiedAccounts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (isSelected !== undefined) {
                localVarQueryParameter['isSelected'] = isSelected;
            }

            if (providerAccountId !== undefined) {
                localVarQueryParameter['providerAccountId'] = providerAccountId;
            }

            if (verificationStatus !== undefined) {
                localVarQueryParameter['verificationStatus'] = verificationStatus;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <i>This API implementation notes is intended for FastLink 4 users. For FastLink 3 users, additional integration notes related to this endpoint is available <a href=\"https://developer.envestnet.com/resources/yodlee/fastlink-3/docs/api-integrations\">here</a>.</i><br><br> The post verification service is used to initiate the challenge deposit account verification (CDV) process to verify account ownership.The CDV process can verify ownership of only bank accounts (i.e., checking and savings).Once the CDV process is initiated, Yodlee will post the micro-transaction (i.e., credit and debit) in the user's account. The CDV process takes 2 to 3 days to complete as it requires the user to provide the microtransaction details.<br><br>The CDV process is currently supported only in the United States.
         * @summary Initiaite Challenge Deposit
         * @param {VerificationRequest} body verification information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateMatchingOrChallengeDepositeVerification(body: VerificationRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling initiateMatchingOrChallengeDepositeVerification.');
            }
            const localVarPath = `/verification`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VerificationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The put verification service is used to complete the challenge deposit verification (CDV) process.<br>This service is used only by the customer of CDV flow.<br>In the CDV process, the user-provided microtransaction details (i.e., credit and debit) is matched against the microtransactions posted by Yodlee. For a successful verification of the account's ownership both the microtransaction details should match.<br>The CDV process is currently supported only in the United States.<br><br><b>Notes:</b><ul><li>This endpoint cannot be used to test the CDV functionality in the developer sandbox or test environment. You will need a money transmitter license to implement the CDV functionality and also require the Yodlee Professional Services team's assistance to set up a dedicated environment.</li></ul>
         * @summary Verify Challenge Deposit
         * @param {UpdateVerificationRequest} body verification information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyChallengeDeposit(body: UpdateVerificationRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling verifyChallengeDeposit.');
            }
            const localVarPath = `/verification`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateVerificationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VerificationApi - functional programming interface
 * @export
 */
export const VerificationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * The Holder Profile API service allows retrieving the user's profile details (i.e., PII data such as name, email, phone number, and address) that are available at the provider account and each account level. The API accepts the providerAccountId and retrieves the profile information available under it and all the details available under each of the associated accounts.  <br><br>This service can only be invoked by Yodlee API v1.1, FastLink 3, and FastLink 4 customers. <br><br>
         * @summary Get Holder Profile
         * @param {string} providerAccountId providerAccountId.
         * @param {string} [accountId] accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHolderProfile(providerAccountId: string, accountId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HolderProfileResponse> {
            const localVarFetchArgs = VerificationApiFetchParamCreator(configuration).getHolderProfile(providerAccountId, accountId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * <i>This API implementation notes is intended for FastLink 4 users. For FastLink 3 users, additional integration notes related to this endpoint is available <a href=\"https://developer.envestnet.com/resources/yodlee/fastlink-3/docs/api-integrations\">here</a>.</i><br><br> The get verification status service is used to retrieve the verification status of all accounts for which the CDV process has been initiated.For the CDV process, the account details object returns the user provided account information.
         * @summary Get Verification Status
         * @param {string} [accountId] Comma separated accountId
         * @param {string} [providerAccountId] Comma separated providerAccountId
         * @param {string} [verificationType] verificationType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerificationStatus(accountId?: string, providerAccountId?: string, verificationType?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VerificationStatusResponse> {
            const localVarFetchArgs = VerificationApiFetchParamCreator(configuration).getVerificationStatus(accountId, providerAccountId, verificationType, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The Verified Accounts API v1.1 provides information about the bank and investment accounts that the user  has selected for verification, during the Account Verification flow on FastLink 4. By default, the API only returns information of the accounts that were selected and have been successfully verified. <br><br>
         * @summary Get Verified Accounts
         * @param {string} providerAccountId providerAccountId.
         * @param {string} [accountId] Comma separated accountIds.
         * @param {string} [isSelected] Comma separated isSelected. Allowed values are true, false &lt;br&gt;&lt;b&gt;Note:&lt;/b&gt; If no value is passed, the implicit default value is true.
         * @param {string} [verificationStatus] Comma separated verificationStatus. Allowed values are SUCCESS, FAILED &lt;br&gt;&lt;b&gt;Note:&lt;/b&gt; If no value is passed, the implicit default value is SUCCESS.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerifiedAccounts(providerAccountId: string, accountId?: string, isSelected?: string, verificationStatus?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VerifiedAccountResponse> {
            const localVarFetchArgs = VerificationApiFetchParamCreator(configuration).getVerifiedAccounts(providerAccountId, accountId, isSelected, verificationStatus, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * <i>This API implementation notes is intended for FastLink 4 users. For FastLink 3 users, additional integration notes related to this endpoint is available <a href=\"https://developer.envestnet.com/resources/yodlee/fastlink-3/docs/api-integrations\">here</a>.</i><br><br> The post verification service is used to initiate the challenge deposit account verification (CDV) process to verify account ownership.The CDV process can verify ownership of only bank accounts (i.e., checking and savings).Once the CDV process is initiated, Yodlee will post the micro-transaction (i.e., credit and debit) in the user's account. The CDV process takes 2 to 3 days to complete as it requires the user to provide the microtransaction details.<br><br>The CDV process is currently supported only in the United States.
         * @summary Initiaite Challenge Deposit
         * @param {VerificationRequest} body verification information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateMatchingOrChallengeDepositeVerification(body: VerificationRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VerificationResponse> {
            const localVarFetchArgs = VerificationApiFetchParamCreator(configuration).initiateMatchingOrChallengeDepositeVerification(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The put verification service is used to complete the challenge deposit verification (CDV) process.<br>This service is used only by the customer of CDV flow.<br>In the CDV process, the user-provided microtransaction details (i.e., credit and debit) is matched against the microtransactions posted by Yodlee. For a successful verification of the account's ownership both the microtransaction details should match.<br>The CDV process is currently supported only in the United States.<br><br><b>Notes:</b><ul><li>This endpoint cannot be used to test the CDV functionality in the developer sandbox or test environment. You will need a money transmitter license to implement the CDV functionality and also require the Yodlee Professional Services team's assistance to set up a dedicated environment.</li></ul>
         * @summary Verify Challenge Deposit
         * @param {UpdateVerificationRequest} body verification information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyChallengeDeposit(body: UpdateVerificationRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VerificationResponse> {
            const localVarFetchArgs = VerificationApiFetchParamCreator(configuration).verifyChallengeDeposit(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VerificationApi - factory interface
 * @export
 */
export const VerificationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * The Holder Profile API service allows retrieving the user's profile details (i.e., PII data such as name, email, phone number, and address) that are available at the provider account and each account level. The API accepts the providerAccountId and retrieves the profile information available under it and all the details available under each of the associated accounts.  <br><br>This service can only be invoked by Yodlee API v1.1, FastLink 3, and FastLink 4 customers. <br><br>
         * @summary Get Holder Profile
         * @param {string} providerAccountId providerAccountId.
         * @param {string} [accountId] accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHolderProfile(providerAccountId: string, accountId?: string, options?: any) {
            return VerificationApiFp(configuration).getHolderProfile(providerAccountId, accountId, options)(fetch, basePath);
        },
        /**
         * <i>This API implementation notes is intended for FastLink 4 users. For FastLink 3 users, additional integration notes related to this endpoint is available <a href=\"https://developer.envestnet.com/resources/yodlee/fastlink-3/docs/api-integrations\">here</a>.</i><br><br> The get verification status service is used to retrieve the verification status of all accounts for which the CDV process has been initiated.For the CDV process, the account details object returns the user provided account information.
         * @summary Get Verification Status
         * @param {string} [accountId] Comma separated accountId
         * @param {string} [providerAccountId] Comma separated providerAccountId
         * @param {string} [verificationType] verificationType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerificationStatus(accountId?: string, providerAccountId?: string, verificationType?: string, options?: any) {
            return VerificationApiFp(configuration).getVerificationStatus(accountId, providerAccountId, verificationType, options)(fetch, basePath);
        },
        /**
         * The Verified Accounts API v1.1 provides information about the bank and investment accounts that the user  has selected for verification, during the Account Verification flow on FastLink 4. By default, the API only returns information of the accounts that were selected and have been successfully verified. <br><br>
         * @summary Get Verified Accounts
         * @param {string} providerAccountId providerAccountId.
         * @param {string} [accountId] Comma separated accountIds.
         * @param {string} [isSelected] Comma separated isSelected. Allowed values are true, false &lt;br&gt;&lt;b&gt;Note:&lt;/b&gt; If no value is passed, the implicit default value is true.
         * @param {string} [verificationStatus] Comma separated verificationStatus. Allowed values are SUCCESS, FAILED &lt;br&gt;&lt;b&gt;Note:&lt;/b&gt; If no value is passed, the implicit default value is SUCCESS.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerifiedAccounts(providerAccountId: string, accountId?: string, isSelected?: string, verificationStatus?: string, options?: any) {
            return VerificationApiFp(configuration).getVerifiedAccounts(providerAccountId, accountId, isSelected, verificationStatus, options)(fetch, basePath);
        },
        /**
         * <i>This API implementation notes is intended for FastLink 4 users. For FastLink 3 users, additional integration notes related to this endpoint is available <a href=\"https://developer.envestnet.com/resources/yodlee/fastlink-3/docs/api-integrations\">here</a>.</i><br><br> The post verification service is used to initiate the challenge deposit account verification (CDV) process to verify account ownership.The CDV process can verify ownership of only bank accounts (i.e., checking and savings).Once the CDV process is initiated, Yodlee will post the micro-transaction (i.e., credit and debit) in the user's account. The CDV process takes 2 to 3 days to complete as it requires the user to provide the microtransaction details.<br><br>The CDV process is currently supported only in the United States.
         * @summary Initiaite Challenge Deposit
         * @param {VerificationRequest} body verification information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateMatchingOrChallengeDepositeVerification(body: VerificationRequest, options?: any) {
            return VerificationApiFp(configuration).initiateMatchingOrChallengeDepositeVerification(body, options)(fetch, basePath);
        },
        /**
         * The put verification service is used to complete the challenge deposit verification (CDV) process.<br>This service is used only by the customer of CDV flow.<br>In the CDV process, the user-provided microtransaction details (i.e., credit and debit) is matched against the microtransactions posted by Yodlee. For a successful verification of the account's ownership both the microtransaction details should match.<br>The CDV process is currently supported only in the United States.<br><br><b>Notes:</b><ul><li>This endpoint cannot be used to test the CDV functionality in the developer sandbox or test environment. You will need a money transmitter license to implement the CDV functionality and also require the Yodlee Professional Services team's assistance to set up a dedicated environment.</li></ul>
         * @summary Verify Challenge Deposit
         * @param {UpdateVerificationRequest} body verification information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyChallengeDeposit(body: UpdateVerificationRequest, options?: any) {
            return VerificationApiFp(configuration).verifyChallengeDeposit(body, options)(fetch, basePath);
        },
    };
};

/**
 * VerificationApi - object-oriented interface
 * @export
 * @class VerificationApi
 * @extends {BaseAPI}
 */
export class VerificationApi extends BaseAPI {
    /**
     * The Holder Profile API service allows retrieving the user's profile details (i.e., PII data such as name, email, phone number, and address) that are available at the provider account and each account level. The API accepts the providerAccountId and retrieves the profile information available under it and all the details available under each of the associated accounts.  <br><br>This service can only be invoked by Yodlee API v1.1, FastLink 3, and FastLink 4 customers. <br><br>
     * @summary Get Holder Profile
     * @param {string} providerAccountId providerAccountId.
     * @param {string} [accountId] accountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerificationApi
     */
    public getHolderProfile(providerAccountId: string, accountId?: string, options?: any) {
        return VerificationApiFp(this.configuration).getHolderProfile(providerAccountId, accountId, options)(this.fetch, this.basePath);
    }

    /**
     * <i>This API implementation notes is intended for FastLink 4 users. For FastLink 3 users, additional integration notes related to this endpoint is available <a href=\"https://developer.envestnet.com/resources/yodlee/fastlink-3/docs/api-integrations\">here</a>.</i><br><br> The get verification status service is used to retrieve the verification status of all accounts for which the CDV process has been initiated.For the CDV process, the account details object returns the user provided account information.
     * @summary Get Verification Status
     * @param {string} [accountId] Comma separated accountId
     * @param {string} [providerAccountId] Comma separated providerAccountId
     * @param {string} [verificationType] verificationType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerificationApi
     */
    public getVerificationStatus(accountId?: string, providerAccountId?: string, verificationType?: string, options?: any) {
        return VerificationApiFp(this.configuration).getVerificationStatus(accountId, providerAccountId, verificationType, options)(this.fetch, this.basePath);
    }

    /**
     * The Verified Accounts API v1.1 provides information about the bank and investment accounts that the user  has selected for verification, during the Account Verification flow on FastLink 4. By default, the API only returns information of the accounts that were selected and have been successfully verified. <br><br>
     * @summary Get Verified Accounts
     * @param {string} providerAccountId providerAccountId.
     * @param {string} [accountId] Comma separated accountIds.
     * @param {string} [isSelected] Comma separated isSelected. Allowed values are true, false &lt;br&gt;&lt;b&gt;Note:&lt;/b&gt; If no value is passed, the implicit default value is true.
     * @param {string} [verificationStatus] Comma separated verificationStatus. Allowed values are SUCCESS, FAILED &lt;br&gt;&lt;b&gt;Note:&lt;/b&gt; If no value is passed, the implicit default value is SUCCESS.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerificationApi
     */
    public getVerifiedAccounts(providerAccountId: string, accountId?: string, isSelected?: string, verificationStatus?: string, options?: any) {
        return VerificationApiFp(this.configuration).getVerifiedAccounts(providerAccountId, accountId, isSelected, verificationStatus, options)(this.fetch, this.basePath);
    }

    /**
     * <i>This API implementation notes is intended for FastLink 4 users. For FastLink 3 users, additional integration notes related to this endpoint is available <a href=\"https://developer.envestnet.com/resources/yodlee/fastlink-3/docs/api-integrations\">here</a>.</i><br><br> The post verification service is used to initiate the challenge deposit account verification (CDV) process to verify account ownership.The CDV process can verify ownership of only bank accounts (i.e., checking and savings).Once the CDV process is initiated, Yodlee will post the micro-transaction (i.e., credit and debit) in the user's account. The CDV process takes 2 to 3 days to complete as it requires the user to provide the microtransaction details.<br><br>The CDV process is currently supported only in the United States.
     * @summary Initiaite Challenge Deposit
     * @param {VerificationRequest} body verification information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerificationApi
     */
    public initiateMatchingOrChallengeDepositeVerification(body: VerificationRequest, options?: any) {
        return VerificationApiFp(this.configuration).initiateMatchingOrChallengeDepositeVerification(body, options)(this.fetch, this.basePath);
    }

    /**
     * The put verification service is used to complete the challenge deposit verification (CDV) process.<br>This service is used only by the customer of CDV flow.<br>In the CDV process, the user-provided microtransaction details (i.e., credit and debit) is matched against the microtransactions posted by Yodlee. For a successful verification of the account's ownership both the microtransaction details should match.<br>The CDV process is currently supported only in the United States.<br><br><b>Notes:</b><ul><li>This endpoint cannot be used to test the CDV functionality in the developer sandbox or test environment. You will need a money transmitter license to implement the CDV functionality and also require the Yodlee Professional Services team's assistance to set up a dedicated environment.</li></ul>
     * @summary Verify Challenge Deposit
     * @param {UpdateVerificationRequest} body verification information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerificationApi
     */
    public verifyChallengeDeposit(body: UpdateVerificationRequest, options?: any) {
        return VerificationApiFp(this.configuration).verifyChallengeDeposit(body, options)(this.fetch, this.basePath);
    }

}
/**
 * VerifyAccountApi - fetch parameter creator
 * @export
 */
export const VerifyAccountApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The verify account service is used to verify the account's ownership by  matching the transaction details with the accounts aggregated for the user.<br><ul><li>If a match is identified, the service returns details of all the accounts along with the matched transaction's details.<li>If no transaction match is found, an empty response will be returned.<li>A maximum of 5 transactionCriteria can be passed in a request.<li>The baseType, date, and amount parameters should mandatorily be passed.<li>The optional dateVariance parameter cannot be more than 7 days. For example, +7, -4, or +/-2.<li>Pass the container or accountId parameters for better performance.<li>This service supports the localization feature and accepts locale as a header parameter.</li></ul>
         * @summary Verify Accounts Using Transactions
         * @param {VerifyAccountRequest} body verificationParam
         * @param {string} providerAccountId providerAccountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateAccountVerification(body: VerifyAccountRequest, providerAccountId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling initiateAccountVerification.');
            }
            // verify required parameter 'providerAccountId' is not null or undefined
            if (providerAccountId === null || providerAccountId === undefined) {
                throw new RequiredError('providerAccountId','Required parameter providerAccountId was null or undefined when calling initiateAccountVerification.');
            }
            const localVarPath = `/verifyAccount/{providerAccountId}`
                .replace(`{${"providerAccountId"}}`, encodeURIComponent(String(providerAccountId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VerifyAccountRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VerifyAccountApi - functional programming interface
 * @export
 */
export const VerifyAccountApiFp = function(configuration?: Configuration) {
    return {
        /**
         * The verify account service is used to verify the account's ownership by  matching the transaction details with the accounts aggregated for the user.<br><ul><li>If a match is identified, the service returns details of all the accounts along with the matched transaction's details.<li>If no transaction match is found, an empty response will be returned.<li>A maximum of 5 transactionCriteria can be passed in a request.<li>The baseType, date, and amount parameters should mandatorily be passed.<li>The optional dateVariance parameter cannot be more than 7 days. For example, +7, -4, or +/-2.<li>Pass the container or accountId parameters for better performance.<li>This service supports the localization feature and accepts locale as a header parameter.</li></ul>
         * @summary Verify Accounts Using Transactions
         * @param {VerifyAccountRequest} body verificationParam
         * @param {string} providerAccountId providerAccountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateAccountVerification(body: VerifyAccountRequest, providerAccountId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VerifyAccountResponse> {
            const localVarFetchArgs = VerifyAccountApiFetchParamCreator(configuration).initiateAccountVerification(body, providerAccountId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VerifyAccountApi - factory interface
 * @export
 */
export const VerifyAccountApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * The verify account service is used to verify the account's ownership by  matching the transaction details with the accounts aggregated for the user.<br><ul><li>If a match is identified, the service returns details of all the accounts along with the matched transaction's details.<li>If no transaction match is found, an empty response will be returned.<li>A maximum of 5 transactionCriteria can be passed in a request.<li>The baseType, date, and amount parameters should mandatorily be passed.<li>The optional dateVariance parameter cannot be more than 7 days. For example, +7, -4, or +/-2.<li>Pass the container or accountId parameters for better performance.<li>This service supports the localization feature and accepts locale as a header parameter.</li></ul>
         * @summary Verify Accounts Using Transactions
         * @param {VerifyAccountRequest} body verificationParam
         * @param {string} providerAccountId providerAccountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateAccountVerification(body: VerifyAccountRequest, providerAccountId: string, options?: any) {
            return VerifyAccountApiFp(configuration).initiateAccountVerification(body, providerAccountId, options)(fetch, basePath);
        },
    };
};

/**
 * VerifyAccountApi - object-oriented interface
 * @export
 * @class VerifyAccountApi
 * @extends {BaseAPI}
 */
export class VerifyAccountApi extends BaseAPI {
    /**
     * The verify account service is used to verify the account's ownership by  matching the transaction details with the accounts aggregated for the user.<br><ul><li>If a match is identified, the service returns details of all the accounts along with the matched transaction's details.<li>If no transaction match is found, an empty response will be returned.<li>A maximum of 5 transactionCriteria can be passed in a request.<li>The baseType, date, and amount parameters should mandatorily be passed.<li>The optional dateVariance parameter cannot be more than 7 days. For example, +7, -4, or +/-2.<li>Pass the container or accountId parameters for better performance.<li>This service supports the localization feature and accepts locale as a header parameter.</li></ul>
     * @summary Verify Accounts Using Transactions
     * @param {VerifyAccountRequest} body verificationParam
     * @param {string} providerAccountId providerAccountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerifyAccountApi
     */
    public initiateAccountVerification(body: VerifyAccountRequest, providerAccountId: string, options?: any) {
        return VerifyAccountApiFp(this.configuration).initiateAccountVerification(body, providerAccountId, options)(this.fetch, this.basePath);
    }

}
